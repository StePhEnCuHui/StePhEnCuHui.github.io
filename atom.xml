<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Step By Step</title>
  
  <subtitle>耀出千分光</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-03-13T13:03:31.398Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LiMinghui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>SpringMVC——什么是SpringMVC，第一个SpringMVC程序</title>
    <link href="http://yoursite.com/2020/03/13/SpringMVC%E2%80%94%E2%80%94%E4%BB%80%E4%B9%88%E6%98%AFSpringMVC%EF%BC%8C%E7%AC%AC%E4%B8%80%E4%B8%AASpringMVC%E7%A8%8B%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/03/13/SpringMVC——什么是SpringMVC，第一个SpringMVC程序/</id>
    <published>2020-03-13T11:50:36.000Z</published>
    <updated>2020-03-13T13:03:31.398Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-SpringMVC？"><a href="#什么是-SpringMVC？" class="headerlink" title="什么是 SpringMVC？"></a>什么是 SpringMVC？</h1><p>​        SpringMVC 是一种基于 Java 实现的 MVC 设计模式的请求驱动类型的轻量级 web 框架，使用了 MVC 架构模式的思想，将 web 层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发</p><a id="more"></a><h2 id="SpringMVC-的前置控制器（DispatchServlet-）"><a href="#SpringMVC-的前置控制器（DispatchServlet-）" class="headerlink" title="SpringMVC 的前置控制器（DispatchServlet ）"></a>SpringMVC 的前置控制器（DispatchServlet ）</h2><p>​        Spring 的 web 框架围绕 DispatchServlet 设计，DispatchServlet 的作用是将请求分发到不同的处理器，DispatcherServlet 是一个实际的 Servlet，继承自 HttpServlet 基类</p><h2 id="SpringMVC-的运行流程"><a href="#SpringMVC-的运行流程" class="headerlink" title="SpringMVC 的运行流程"></a>SpringMVC 的运行流程</h2><p>​        当用户发起请求时，前置控制器拦截到请求，根据请求参数生成代理请求，找到请求所对应的实际控制器（Controller），控制器处理请求，创建数据模型并与后端进行交互，随后将处理过的数据模型响应给中心控制器，控制器使用数据模型与视图渲染视图结果，结果被返回给中心控制器随后被返回给用户，如下图：</p><p><img src="https://img-blog.csdnimg.cn/20200313205526835.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70" alt></p><h1 id="Hello！SpringMVC（使用注解配置-SpringMVC）"><a href="#Hello！SpringMVC（使用注解配置-SpringMVC）" class="headerlink" title="Hello！SpringMVC（使用注解配置 SpringMVC）"></a>Hello！SpringMVC（使用注解配置 SpringMVC）</h1><p>​        首先我们创建一个项目，我这里是使用的 Maven 项目，第一步是导入 jar 包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 导入依赖 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.12<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.1.9.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.5<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet.jsp<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jsp-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>jstl<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        随后我们要将我们的项目升级为 web 项目，我是使用 idea 进行开发的，操作如下:</p><p>​        添加框架支持</p><p><img src="https://img-blog.csdnimg.cn/2020031320554914.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70" alt></p><p>​        升级为 web 项目</p><p><img src="https://img-blog.csdnimg.cn/20200313205608875.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70" alt></p><p>​        随后我们要在<code>web.xml</code>中配置 DispatchServlet，先看代码：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">servlet</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc_anno<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="tag">&lt;/<span class="name">servlet-class</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">init-param</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-name</span>&gt;</span>contextConfigLocation<span class="tag">&lt;/<span class="name">param-name</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">param-value</span>&gt;</span>classpath:spring_servlet.xml<span class="tag">&lt;/<span class="name">param-value</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">init-param</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">load-on-startup</span>&gt;</span>1<span class="tag">&lt;/<span class="name">load-on-startup</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">servlet-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">servlet-name</span>&gt;</span>springmvc_anno<span class="tag">&lt;/<span class="name">servlet-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">servlet-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        这里我们配置了一个<code>DispatcherServlet</code>类的 Servlet，命名为 springmvc_anno，和以往不同的是，我们这里需要使用<code>&lt;init-param&gt;</code>标签关联一个 Spring 配置文件，因为我们需要 Spring 框架帮我们找到 Contorller</p><p>​        <code>&lt;load-on-startup&gt;</code>标签是设置启动级别，数字越小，启动越早，我们直接设置为<code>1</code>即可，映射路径直接写<code>/</code></p><p>​        随后我们配置在<code>web.xml</code>中声明的<code>spring_servlet.xml</code>，这是一个 Spring 配置文件，所以我们在<code>src</code>下的<code>resources</code>目录下创建它，因为我们是使用注解配置，毫无疑问要导入<code>context</code>命名空间</p><p>​        我们在<code>spring_servlet.xml</code>中进行四步操作：首先让 IOC 注解生效，即设置注解扫描，第二部过滤掉静态资源，如 HTML、JS、CSS、图片、视频等，第三步启动 MVC 注解驱动，这里会注入<code>DefaultAnnotationHandlerMapping</code>和<code>AnnotationMethodHandlerAdapter</code>实例，最后一步是配置视图解析器，用于帮助我们更便捷的设计 Controller 类，<code>spring_servlet.xml</code>的代码如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:mvc</span>=<span class="string">"http://www.springframework.org/schema/mvc"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/context/spring-context.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/mvc</span></span></span><br><span class="line"><span class="tag"><span class="string">        https://www.springframework.org/schema/mvc/spring-mvc.xsd"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 自动扫描包，让指定包下的注解生效,由IOC容器统一管理 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.lmh.controller"</span>/&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 让Spring MVC不处理静态资源 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:default-servlet-handler</span> /&gt;</span></span><br><span class="line">    <span class="comment">&lt;!--</span></span><br><span class="line"><span class="comment">    支持mvc注解驱动</span></span><br><span class="line"><span class="comment">        在spring中一般采用@RequestMapping注解来完成映射关系</span></span><br><span class="line"><span class="comment">        要想使@RequestMapping注解生效</span></span><br><span class="line"><span class="comment">        必须向上下文中注册DefaultAnnotationHandlerMapping</span></span><br><span class="line"><span class="comment">        和一个AnnotationMethodHandlerAdapter实例</span></span><br><span class="line"><span class="comment">        这两个实例分别在类级别和方法级别处理。</span></span><br><span class="line"><span class="comment">        而annotation-driven配置帮助我们自动完成上述两个实例的注入。</span></span><br><span class="line"><span class="comment">     --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">mvc:annotation-driven</span> /&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">&lt;!-- 视图解析器 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">class</span>=<span class="string">"org.springframework.web.servlet.view.InternalResourceViewResolver"</span></span></span><br><span class="line"><span class="tag">          <span class="attr">id</span>=<span class="string">"internalResourceViewResolver"</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 前缀 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"prefix"</span> <span class="attr">value</span>=<span class="string">"/WEB-INF/jsp/"</span> /&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- 后缀 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"suffix"</span> <span class="attr">value</span>=<span class="string">".jsp"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        下一步就是创建我们的 Controller，我们实现的功能就是向前端传一个字符串并显示出来，我们起名为<code>com.lmh.controller.HelloController</code></p><p>​        因为是用过注解实现，首先我们要用<code>@Controller</code>注解来修饰这个 Controller 类，随后我们只需要在类中创建一个返回值为<code>String</code>类型的方法即可，这个方法的返回值，就是我们视图名称，假如我们的返回值是<code>test</code>，再加上<code>spring_servlet.xml</code>的配置，我们实际上就会访问<code>WEB-INF/jsp/test.jsp</code></p><p>​        另外，我们需要使用<code>@RequestMapping</code>注解来修饰我们这个函数，<code>@RequestMapping</code>注解用来声明我们的映射路径，即定义什么样的<code>url</code>可以访问到这个 Controller 中的 这个方法，HelloController.java 代码如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lmh.controller;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.ui.Model;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">(Model model)</span> </span>&#123;</span><br><span class="line">        model.addAttribute(<span class="string">"msg"</span>, <span class="string">"Hello"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这里我们设置返回的是<code>hello.jsp</code>。<code>Model</code>中为我们包装的数据模型，即返回给前端的信息，随后我们在<code>WEB-INF/jsp/</code>目录下创建<code>hello.jsp</code>并接收返回的数据模型：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page contentType=<span class="string">"text/html;charset=UTF-8"</span> language=<span class="string">"java"</span> %&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">&lt;head&gt;</span><br><span class="line">    &lt;title&gt;Title&lt;/title&gt;</span><br><span class="line">&lt;/head&gt;</span><br><span class="line">    &lt;body&gt;</span><br><span class="line">        $&#123;msg&#125;</span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure><p>​        到这里，我们的所有配置就都已经结束，我们只需要配置 Tomcat 启动项目即可，在浏览器地址栏输入我们配置的映射路径<code>localhost:8080/hello</code>，就会出现如下结果</p><p><img src="https://img-blog.csdnimg.cn/20200313205633499.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是-SpringMVC？&quot;&gt;&lt;a href=&quot;#什么是-SpringMVC？&quot; class=&quot;headerlink&quot; title=&quot;什么是 SpringMVC？&quot;&gt;&lt;/a&gt;什么是 SpringMVC？&lt;/h1&gt;&lt;p&gt;​        SpringMVC 是一种基于 Java 实现的 MVC 设计模式的请求驱动类型的轻量级 web 框架，使用了 MVC 架构模式的思想，将 web 层进行职责解耦，基于请求驱动指的就是使用请求-响应模型，框架的目的就是帮助我们简化开发&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringMVC" scheme="http://yoursite.com/tags/SpringMVC/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——使用cglib实现动态代理</title>
    <link href="http://yoursite.com/2020/03/08/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8cglib%E5%AE%9E%E7%8E%B0%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2020/03/08/JAVA基础——使用cglib实现动态代理/</id>
    <published>2020-03-08T14:23:30.000Z</published>
    <updated>2020-03-08T15:03:20.660Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA-代理模式"><a href="#JAVA-代理模式" class="headerlink" title="JAVA 代理模式"></a>JAVA 代理模式</h1><p>​        简而言之，代理是一种通过创建代理对象的方式，从而实现对被代理对象实现功能增强的一种方式，JAVA 中有静态和动态两种代理，动态代理又可以分为_基于接口的动态代理_（JDK 实现）和_基于子类的动态代理_（cglib 实现），这里我们讲解基于子类的动态代理</p><a id="more"></a><h1 id="基于子类的动态代理（cglib-实现的动态代理）"><a href="#基于子类的动态代理（cglib-实现的动态代理）" class="headerlink" title="基于子类的动态代理（cglib 实现的动态代理）"></a>基于子类的动态代理（cglib 实现的动态代理）</h1><p>​        使用代理的好处就是在不修改原代码的基础上可以实现对原方法的增强，使用<code>JDK</code>官方的动态代理主要是依靠<code>Proxy</code>类，这种方法实现的动态代理要求被代理类_至少实现一个接口_，没有实现接口的类是不能被代理的</p><p>​        那么没有实现接口或者不需要实现接口的类，我们怎么对它进行代理呢？</p><p>​        通过引入第三方<code>cglib</code>库，我们可以实现基于子类的动态代理，使用<code>cglib</code>实现的动态代理也有一个约束条件，就是<em>被代理类不能是最终类</em></p><p>​        使用<code>cglib</code>实现的动态代理核心是<code>Enhancer</code>类，其实实现的过程和<code>JDK</code>实现动态代理的过程极其类似</p><h2 id="导入-jar-包"><a href="#导入-jar-包" class="headerlink" title="导入 jar 包"></a>导入 jar 包</h2><p>​        我是用的是<code>maven</code>工程，所以第一步是要导入<code>cglib</code>的 jar 包，当然手动导入也没有问题，<code>pom.xml</code>文件配置如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cglib<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.1_3<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="编写被代理类"><a href="#编写被代理类" class="headerlink" title="编写被代理类"></a>编写被代理类</h2><p>​        我这里被代理类主要就实现一个卖东西的功能，之后我们会通过代理类对被代理类中的方法进行增强操作：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lmh.cglib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmh.proxy.IPorducer;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 生产者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Producer</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saleProduct</span><span class="params">(<span class="keyword">float</span> money)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"销售产品，拿到钱 "</span> + money);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="编写代理类（这里也是一个测试类）"><a href="#编写代理类（这里也是一个测试类）" class="headerlink" title="编写代理类（这里也是一个测试类）"></a>编写代理类（这里也是一个测试类）</h2><p>​        这一步是整个过程的关键，代理类的实现要通过<code>Enhancer</code>类，我们需要通过<code>Enhancer</code>类中的<code>create</code>方法创建一个代理对象，具体实现方法如下，作用是给售价打八折，后面我会详细的解释各部分的功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lmh.cglib;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmh.proxy.IPorducer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.Enhancer;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodInterceptor;</span><br><span class="line"><span class="keyword">import</span> net.sf.cglib.proxy.MethodProxy;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 模拟一个消费者</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Client</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Producer producer = <span class="keyword">new</span> Producer();</span><br><span class="line">        Producer enhancerProducer = (Producer) Enhancer.create(producer.getClass(), <span class="keyword">new</span> MethodInterceptor() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> Object <span class="title">intercept</span><span class="params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                <span class="comment">// 提供增强代码</span></span><br><span class="line">                Object returnValue = <span class="keyword">null</span>;</span><br><span class="line">                Float money = (Float) objects[<span class="number">0</span>];</span><br><span class="line">                <span class="keyword">if</span> (<span class="string">"saleProduct"</span>.equals(method.getName())) &#123;</span><br><span class="line">                    returnValue = method.invoke(producer, money * <span class="number">0.8f</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> returnValue;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        enhancerProducer.saleProduct(<span class="number">1000f</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这里我们可以看到，<code>enhancerProducer</code>就是我们创建的代理对象，这个对象可以执行被代理类中所有的方法，并且我们可以在代理对象中对被代理类的方法进行增强，这里使用了强转，因为<code>create</code>方法的返回值是<code>Object</code>类型的对象</p><p>​        <code>create</code>方法有两个参数，分别是<code>Class type</code>和<code>Callback callback</code>，其中<code>Class type</code>是值被代理类的字节码文件，这是固定的，因为有了被代理类的字节码后，就相当于可以获取被代理类的全部信息；<code>Callback callback</code>是用于提供增强代码的，一般都是写一个接口的实现，通常情况下都是匿名内部类，这里我们一般不适用<code>Callback</code>接口，而是使用它的子接口实现类<code>MethodInterceptor</code></p><p>​        <code>MethodInterceptor</code>接口需要重写<code>intercept</code>方法，<code>intercept</code>方法中的内容即为对被代理类的增强，该方法有四个参数：<code>Object o</code>、<code>Method method</code>、<code>Object[] objects</code>和<code>MethodProxy methodProxy</code></p><p>​        <code>Object o</code>参数，是一个代理对象的引用，<code>Method method</code>是当前执行，即被拦截的被代理类方法，<code>Objects[] objects</code>是当前执行方法所用的参数，索引顺序即为方法定义时参数的顺序，<code>MethodProxy methodProxy</code>指的是当前执行的方法的代理对象</p><p>​        通过向上述代码一样编写，我们就可以实现对被代理类功能的增强！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JAVA-代理模式&quot;&gt;&lt;a href=&quot;#JAVA-代理模式&quot; class=&quot;headerlink&quot; title=&quot;JAVA 代理模式&quot;&gt;&lt;/a&gt;JAVA 代理模式&lt;/h1&gt;&lt;p&gt;​        简而言之，代理是一种通过创建代理对象的方式，从而实现对被代理对象实现功能增强的一种方式，JAVA 中有静态和动态两种代理，动态代理又可以分为_基于接口的动态代理_（JDK 实现）和_基于子类的动态代理_（cglib 实现），这里我们讲解基于子类的动态代理&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Spring框架——使用注解实现Spring IOC</title>
    <link href="http://yoursite.com/2020/03/06/Spring%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%AE%9E%E7%8E%B0Spring-IOC/"/>
    <id>http://yoursite.com/2020/03/06/Spring框架——使用注解实现Spring-IOC/</id>
    <published>2020-03-06T14:33:50.000Z</published>
    <updated>2020-03-06T15:46:57.740Z</updated>
    
    <content type="html"><![CDATA[<h1 id="完全使用注解实现-IOC"><a href="#完全使用注解实现-IOC" class="headerlink" title="完全使用注解实现 IOC"></a>完全使用注解实现 IOC</h1><p>​        通过使用注解的方式，可以更方便的将我们自己创建的对象放入到 Spring bean 容器中，我们这里介绍使用纯注解的方式实现 IOC，并且主要介绍替代<code>.xml</code>文件配置的过程，虽然这种方式对于包装好的对象使用起来有些麻烦</p><a id="more"></a><h1 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h1><p>​        首先我们需要准备一个<code>.java</code>的配置文件，用于取代<code>bean.xml</code>，我们将它建在<code>com</code>的父目录<code>java</code>中的<code>config</code>包下，取名为<code>SpringConfiguration.java</code></p><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><p>​        既然说是取代，那这个类就要通过注解的方式，实现原本使用<code>bean.xml</code>配置 IOC 时的全部功能，我们先来看看之前使用注解和<code>bean.xml</code>结合配置 IOC 时的<code>bean.xml</code>是如何编写的</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xmlns:context</span>=<span class="string">"http://www.springframework.org/schema/context"</span></span></span><br><span class="line"><span class="tag">       <span class="attr">xsi:schemaLocation</span>=<span class="string">"</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/context/spring-context.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">context:component-scan</span> <span class="attr">base-package</span>=<span class="string">"com.lmh"</span>/&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 配置 QueryRunner 对象 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"runner"</span> <span class="attr">class</span>=<span class="string">"org.apache.commons.dbutils.QueryRunner"</span> <span class="attr">scope</span>=<span class="string">"prototype"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"ds"</span> <span class="attr">ref</span>=<span class="string">"dataSource"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.mchange.v2.c3p0.ComboPooledDataSource"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"driverClass"</span> <span class="attr">value</span>=<span class="string">"com.mysql.cj.jdbc.Driver"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"jdbcUrl"</span> <span class="attr">value</span>=<span class="string">"jdbc:mysql://localhost:3306/spring?useSSL=false&amp;amp;serverTimezone=UTC"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">value</span>=<span class="string">"root"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"lmh12358"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        下面，我们就根据 xml 文件所提供的功能，一个一个转化为注解实现</p><h1 id="定义配置类（-Configuration）"><a href="#定义配置类（-Configuration）" class="headerlink" title="定义配置类（@Configuration）"></a>定义配置类（@Configuration）</h1><p>​        配置类<code>config.SpringConfiguration.java</code>我们已经创建好了，我们需要使用<code>@Configuration</code>来说明它是一个配置类如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpringConfiguration</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="指定注解存在的位置（-ComponentScan）"><a href="#指定注解存在的位置（-ComponentScan）" class="headerlink" title="指定注解存在的位置（@ComponentScan）"></a>指定注解存在的位置（@ComponentScan）</h1><p>​        随后，在<code>bean.xml</code>中有<code>&lt;context:component-scan base-package=&quot;com.lmh&quot;/&gt;</code>这样一句话，它是说明在我们的项目中需要被扫描的使用注解的位置，我们在配置类中使用<code>@ComponentScans</code>注解实现这一功能</p><p>​        <code>@ComponentScans</code>注解用来指定 Spring 在创建容器所扫描的包，它里边需要使用<code>@ComponentScan</code>注解来指定包名，使用方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ComponentScans</span>(</span><br><span class="line">        <span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"com.lmh"</span>, ...&#125;)</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>​        通过这种方式可以指定需要扫描的包名，<code>basePackages</code>是一个数组，可以包含多个包名</p><h1 id="使用注解将外部类放入容器（-Bean）"><a href="#使用注解将外部类放入容器（-Bean）" class="headerlink" title="使用注解将外部类放入容器（@Bean）"></a>使用注解将外部类放入容器（@Bean）</h1><p>​        以上的功能只能将我们自己的对象存入到 Spring 容器中，那如果是像<code>QueryRunner</code>这样的对象呢</p><p>​        这是需要使用<code>@Bean</code>注解，<code>@Bean</code>注解用来修饰一个方法，可以把当前方法的返回值作为 bean 对象存入 Spring 的 IOC 容器中，<code>name</code>属性即为该 bean 的<code>id</code>，并且我们可以使用<code>@Scope</code>等注解来修饰它，使用如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"runner"</span>)</span><br><span class="line"><span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> QueryRunner <span class="title">createQueryRunner</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> QueryRunner(dataSource);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span>(name = <span class="string">"dataSource"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource</span><span class="params">()</span> <span class="keyword">throws</span> PropertyVetoException </span>&#123;</span><br><span class="line">    ComboPooledDataSource ds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">    ds.setDriverClass(driver);</span><br><span class="line">    ds.setJdbcUrl(url);</span><br><span class="line">    ds.setUser(username);</span><br><span class="line">    ds.setPassword(password);</span><br><span class="line">    <span class="keyword">return</span> ds;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        我们可以看到，<code>QueryRunner</code>对象是需要使用<code>DataSource</code>类型的对象作为参数来创建的，这是就需要为这个 bean 注入<code>DataSource dataSource</code>，此时我们只需要定义一个<code>id</code>和参数名相同的<code>bean</code>即可，即使用注解配置方法时，如果方法有参数，Spring 框架会去容器中查找有没有可用的 bean，查找方式和 AutoWired 相同</p><h1 id="其他一些常用注解"><a href="#其他一些常用注解" class="headerlink" title="其他一些常用注解"></a>其他一些常用注解</h1><h2 id="Import"><a href="#Import" class="headerlink" title="@Import"></a>@Import</h2><p>​        <code>@Import</code>注解用来定义子配置文件，假设我们要在<code>JdbcConfig.java</code>中配置 JDBC 连接信息，就可以通过在父配置类中使用<code>@Import</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Import</span>(value = &#123;</span><br><span class="line">        JdbcConfig.class</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h2 id="PropertySources、-Value"><a href="#PropertySources、-Value" class="headerlink" title="@PropertySources、@Value"></a>@PropertySources、@Value</h2><p>​        <code>@PropertySources</code>注解用来指定<code>.properties</code>的配置文件，<code>@Value</code>用来调用配置文件中的值，通过这两个注解，我们可以调用配置文件的信息，例如将 JDBC 连接包装在配置文件中我们可这样使用</p><p>​        配置文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driver=com.mysql.cj.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://localhost:3306/spring?useSSL=false&amp;serverTimezone=UTC</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=lmh12358</span><br></pre></td></tr></table></figure><p>​        JdbcConfig.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.mchange.v2.c3p0.ComboPooledDataSource;</span><br><span class="line"><span class="keyword">import</span> org.apache.commons.dbutils.QueryRunner;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Value;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.sql.DataSource;</span><br><span class="line"><span class="keyword">import</span> java.beans.PropertyVetoException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@PropertySources</span>(</span><br><span class="line">        <span class="meta">@PropertySource</span>(<span class="string">"classpath:jdbcConfig.properties"</span>)</span><br><span class="line">)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.driver&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String driver;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.url&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.username&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.password&#125;"</span>)</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 用于创建一个 QueryRunner 对象</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> dataSource</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"runner"</span>)</span><br><span class="line">    <span class="meta">@Scope</span>(<span class="string">"prototype"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> QueryRunner <span class="title">createQueryRunner</span><span class="params">(DataSource dataSource)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> QueryRunner(dataSource);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span>(name = <span class="string">"dataSource"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">createDataSource</span><span class="params">()</span> <span class="keyword">throws</span> PropertyVetoException </span>&#123;</span><br><span class="line">        ComboPooledDataSource ds = <span class="keyword">new</span> ComboPooledDataSource();</span><br><span class="line">        ds.setDriverClass(driver);</span><br><span class="line">        ds.setJdbcUrl(url);</span><br><span class="line">        ds.setUser(username);</span><br><span class="line">        ds.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> ds;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>​        由于不再使用 XML 文件，我们调用 bean 工厂的方法就要有变化，我们通过一下语句来指定配置类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> ApplicationContext context;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Before</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    context = <span class="keyword">new</span> AnnotationConfigApplicationContext(SpringConfiguration.class);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这样我们就指定了<code>SpringConfiguration.java</code>为配置类，并且还可以直接使用它内部使用的子配置类</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;完全使用注解实现-IOC&quot;&gt;&lt;a href=&quot;#完全使用注解实现-IOC&quot; class=&quot;headerlink&quot; title=&quot;完全使用注解实现 IOC&quot;&gt;&lt;/a&gt;完全使用注解实现 IOC&lt;/h1&gt;&lt;p&gt;​        通过使用注解的方式，可以更方便的将我们自己创建的对象放入到 Spring bean 容器中，我们这里介绍使用纯注解的方式实现 IOC，并且主要介绍替代&lt;code&gt;.xml&lt;/code&gt;文件配置的过程，虽然这种方式对于包装好的对象使用起来有些麻烦&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring框架" scheme="http://yoursite.com/tags/Spring%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Spring框架——使用构造函数或set实现的依赖注入</title>
    <link href="http://yoursite.com/2020/03/03/Spring%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E6%88%96set%E5%AE%9E%E7%8E%B0%E7%9A%84%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5/"/>
    <id>http://yoursite.com/2020/03/03/Spring框架——使用构造函数或set实现的依赖注入/</id>
    <published>2020-03-03T10:11:24.000Z</published>
    <updated>2020-03-03T10:40:54.424Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-中的依赖注入"><a href="#Spring-中的依赖注入" class="headerlink" title="Spring 中的依赖注入"></a>Spring 中的依赖注入</h1><p>​        依赖注入：Dependency Injection，它是 spring 框架核心 ioc 的具体实现</p><p>​        我们的程序在编写时，通过控制反转，把对象的创建交给了 spring，但是代码中不可能出现没有依赖的情况，ioc 解耦只是降低他们的依赖关系，但不会消除</p><p>​        例如：我们的业务层仍会调用持久层的方法，那这种业务层和持久层的依赖关系，在使用 spring 之后，就让 spring 来维护了，简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取</p><a id="more"></a><h1 id="通过构造函数实现依赖注入"><a href="#通过构造函数实现依赖注入" class="headerlink" title="通过构造函数实现依赖注入"></a>通过构造函数实现依赖注入</h1><p>​        顾名思义，就是使用类中的构造函数，给成员变量赋值，赋值的操作不是我们自己做的，而是通过配置的方式，让 Spring 框架来为我们注入的，下面我们来看具体代码：</p><p>​        AccountServiceImpl 类中存在着<code>String</code>、<code>Integer</code>、<code>Date</code>三种类型的变量。分别代表<code>基本类型及 String</code>、<code>其他特殊类型</code>两大类，并提供他们的构造函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lmh.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmh.dao.IAccountDao;</span><br><span class="line"><span class="keyword">import</span> com.lmh.dao.impl.AccountDaoImpl;</span><br><span class="line"><span class="keyword">import</span> com.lmh.service.IAccountService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的业务层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountServiceImpl</span><span class="params">(String name, Integer age, Date birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"save service"</span>);</span><br><span class="line">        System.out.println(name + <span class="string">", "</span> + age + <span class="string">", "</span> + birthday);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        在<code>bean.xml</code>中配置依赖注入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"now"</span> <span class="attr">class</span>=<span class="string">"java.util.Date"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.lmh.service.impl.AccountServiceImpl"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"test"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"18"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">constructor-arg</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"now"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        这里需要注意，由于<code>Date</code>是其他特殊类型，不被包含在 Java 的基本类型或字符串中，所以我们需要为<code>Date</code>类型创建一个<code>&lt;bean&gt;</code>，然后在另一个<code>&lt;bean&gt;</code>的<code>&lt;constructor-arg&gt;</code>标签中使用<code>ref</code>属性来引用它，实现依赖注入</p><p>​        这里我是使用<code>&lt;constructor-arg&gt;</code>标签的<code>name</code>属性来指定变量名实现依赖注入的，<code>&lt;constructor-arg&gt;</code>标签还支持使用<code>type</code>和<code>index</code>两个属性，其中<code>type</code>是根据变量类型为变量赋值，这里存在使用的局限性，<code>index</code>通过变量在构造函数参数列表中的位置（从 0 开始）来为变量赋值，可以看到，使用<code>name</code>还是比较实用的</p><p>​        而<code>value</code>标签是为基本类型变量直接赋值，它可以将<code>&quot; &quot;</code>中的值自动转换为相应的数据类型，<code>ref</code>是专门为特殊的类型进行赋值的，它通过引用定义好的<code>&lt;bean&gt;</code>来进行赋值</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>​        优势：在获取 bean 对象时，注入数据是必须的操作，否则对象无法创建成功</p><p>​        弊端：改变了 bean 对象的实例化方式，在我们创建对象时，如果用不到这些数据，也必须提供</p><h1 id="通过-Set-方法实现依赖注入"><a href="#通过-Set-方法实现依赖注入" class="headerlink" title="通过 Set 方法实现依赖注入"></a>通过 Set 方法实现依赖注入</h1><p>​        该方法我们需要在类中为变量添加对应的 set 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lmh.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmh.service.IAccountService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Date;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的业务层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl2</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 如果是经常变化的数据，并不适用于注入的方式</span></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line">    <span class="keyword">private</span> Integer age;</span><br><span class="line">    <span class="keyword">private</span> Date birthday;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setAge</span><span class="params">(Integer age)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.age = age;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setBirthday</span><span class="params">(Date birthday)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.birthday = birthday;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"save service"</span>);</span><br><span class="line">        System.out.println(name + <span class="string">", "</span> + age + <span class="string">", "</span> + birthday);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        在<code>bean.xml</code>中配置依赖注入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService2"</span> <span class="attr">class</span>=<span class="string">"com.lmh.service.impl.AccountServiceImpl2"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"name"</span> <span class="attr">value</span>=<span class="string">"test"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"age"</span> <span class="attr">value</span>=<span class="string">"21"</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"birthday"</span> <span class="attr">ref</span>=<span class="string">"now"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        使用 set 方法实现依赖注入时，我们使用<code>&lt;bean&gt;</code>标签内部的<code>&lt;property&gt;</code>标签，<code>&lt;property&gt;</code>标签的使用以及内部的属性和<code>&lt;constructor-arg&gt;</code>标签相同，对于<code>Date</code>这种类型，同样需要使用引用的方式进行赋值</p><h2 id="优缺点-1"><a href="#优缺点-1" class="headerlink" title="优缺点"></a>优缺点</h2><p>​        优势：创建对象时没有明确的限制，可以直接使用默认构造函数</p><p>​        弊端：如果有某个成员必须有值，则获取对象时有可能 set 方法没有执行</p><h1 id="集合类型变量的依赖注入"><a href="#集合类型变量的依赖注入" class="headerlink" title="集合类型变量的依赖注入"></a>集合类型变量的依赖注入</h1><p>​        集合类型的变量如何实现依赖注入呢？我们这里以 set 方法为例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lmh.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmh.service.IAccountService;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.*;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的业务层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl3</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String[] myStrs;</span><br><span class="line">    <span class="keyword">private</span> List&lt;String&gt; myList;</span><br><span class="line">    <span class="keyword">private</span> Set&lt;String&gt; mySet;</span><br><span class="line">    <span class="keyword">private</span> Map&lt;String, String&gt; myMap;</span><br><span class="line">    <span class="keyword">private</span> Properties myProps;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyStrs</span><span class="params">(String[] myStrs)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myStrs = myStrs;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyList</span><span class="params">(List&lt;String&gt; myList)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myList = myList;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMySet</span><span class="params">(Set&lt;String&gt; mySet)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.mySet = mySet;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyMap</span><span class="params">(Map&lt;String, String&gt; myMap)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myMap = myMap;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setMyProps</span><span class="params">(Properties myProps)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.myProps = myProps;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"save service"</span>);</span><br><span class="line">        System.out.println(Arrays.toString(myStrs));</span><br><span class="line">        System.out.println(myList);</span><br><span class="line">        System.out.println(mySet);</span><br><span class="line">        System.out.println(myMap);</span><br><span class="line">        System.out.println(myProps);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        在<code>bean.xml</code>中配置依赖注入：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService3"</span> <span class="attr">class</span>=<span class="string">"com.lmh.service.impl.AccountServiceImpl3"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myStrs"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">array</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>DDD<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">array</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myList"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">list</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>DDD<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">list</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"mySet"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">set</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>BBB<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>CCC<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">value</span>&gt;</span>AAA<span class="tag">&lt;/<span class="name">value</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">set</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myMap"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">map</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"testA"</span> <span class="attr">value</span>=<span class="string">"aaa"</span>/&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">entry</span> <span class="attr">key</span>=<span class="string">"testB"</span> <span class="attr">value</span>=<span class="string">"bbb"</span>/&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">map</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"myProps"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">props</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"testc"</span>&gt;</span>ccc<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">prop</span> <span class="attr">key</span>=<span class="string">"testd"</span>&gt;</span>ddd<span class="tag">&lt;/<span class="name">prop</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">props</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        以上是集合类型变量使用 set 方法实现依赖注入的代码，这里需要注意一点，相同类型的集合可以使用相同的标签实现依赖注入，即<code>array、List、Set</code>属于同类型，<code>Map、Properties</code>属于同类型，例如<code>array</code>可以通过<code>&lt;list&gt;</code>标签实现依赖注入</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring-中的依赖注入&quot;&gt;&lt;a href=&quot;#Spring-中的依赖注入&quot; class=&quot;headerlink&quot; title=&quot;Spring 中的依赖注入&quot;&gt;&lt;/a&gt;Spring 中的依赖注入&lt;/h1&gt;&lt;p&gt;​        依赖注入：Dependency Injection，它是 spring 框架核心 ioc 的具体实现&lt;/p&gt;
&lt;p&gt;​        我们的程序在编写时，通过控制反转，把对象的创建交给了 spring，但是代码中不可能出现没有依赖的情况，ioc 解耦只是降低他们的依赖关系，但不会消除&lt;/p&gt;
&lt;p&gt;​        例如：我们的业务层仍会调用持久层的方法，那这种业务层和持久层的依赖关系，在使用 spring 之后，就让 spring 来维护了，简单的说，就是坐等框架把持久层对象传入业务层，而不用我们自己去获取&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring框架" scheme="http://yoursite.com/tags/Spring%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Spring框架——SpringIOC中使用XML创建bean的三种方式</title>
    <link href="http://yoursite.com/2020/03/03/Spring%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94Spring%E4%B8%AD%E4%BD%BF%E7%94%A8XML%E5%88%9B%E5%BB%BAbean%E7%9A%84%E4%B8%89%E7%A7%8D%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/03/03/Spring框架——Spring中使用XML创建bean的三种方式/</id>
    <published>2020-03-03T02:10:11.000Z</published>
    <updated>2020-03-03T03:04:14.222Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-IOC"><a href="#Spring-IOC" class="headerlink" title="Spring-IOC"></a>Spring-IOC</h1><p>​        IOC（Inversion of Control）意为控制反转，把创建对象的权利交给框架，是框架的重要特征，IOC 的作用是消减程序的耦合，解除我们代码中的依赖关系</p><p>​        下面我们主要说明基于XML 文件来使用 IOC 的过程，以及使用 XML 文件创建 bean 的三种方式</p><a id="more"></a><h1 id="通过配置-XML-文件实现-IOC"><a href="#通过配置-XML-文件实现-IOC" class="headerlink" title="通过配置 XML 文件实现 IOC"></a>通过配置 XML 文件实现 IOC</h1><p>​        首先我这里是使用 Maven 工程创建的 Spring java 工程，而不是 java web 工程，首先我们已经配置了 Spring 的开发环境，<code>pom.xml</code>文件、<code>IAccountService</code>、<code>IAccountDao</code>、<code>AccountServiceImpl</code>、<code>AccountDaoImpl</code>以及测试类<code>Client</code>等，代码如下（此处可以跳过）</p><p>pom.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">packaging</span>&gt;</span>jar<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-context<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>5.0.2.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>IAccountService：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lmh.service;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户业务层的接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 模拟保存账户</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>IAccountDao：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lmh.dao;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的持久层接口</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AccountServiceImpl：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lmh.service.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmh.dao.IAccountDao;</span><br><span class="line"><span class="keyword">import</span> com.lmh.dao.impl.AccountDaoImpl;</span><br><span class="line"><span class="keyword">import</span> com.lmh.service.IAccountService;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 账户的业务层实现类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountServiceImpl</span> <span class="keyword">implements</span> <span class="title">IAccountService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AccountServiceImpl</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"save service"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>AccountDaoImpl：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lmh.dao.impl;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmh.dao.IAccountDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AccountDaoImpl</span> <span class="keyword">implements</span> <span class="title">IAccountDao</span> </span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 账户的持久层实现类</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">saveAccount</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"dao save"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="配置-XML-文件"><a href="#配置-XML-文件" class="headerlink" title="配置 XML 文件"></a>配置 XML 文件</h2><p>​        首先我们将 Spring 官方文档中的配置文件规范复制下来，粘贴到<code>resource</code>文件夹下的<code>bean.xml</code>中，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">beans</span> <span class="attr">xmlns</span>=<span class="string">"http://www.springframework.org/schema/beans"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">    <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://www.springframework.org/schema/beans</span></span></span><br><span class="line"><span class="tag"><span class="string">        http://www.springframework.org/schema/beans/spring-beans.xsd"</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;/<span class="name">beans</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        接下来我们要在<code>&lt;beans&gt;</code>标签中创建<code>&lt;bean&gt;</code>子标签，在 Spring 中，每个 bean 都是一个对象，Spring 通过这种方式，解除程序中使用<code>new</code>创建对象的高耦合，也就是说，创建对象的过程，Spring 框架都为我们做了</p><h2 id="XML-中三种配置-bean-的方法"><a href="#XML-中三种配置-bean-的方法" class="headerlink" title="XML 中三种配置 bean 的方法"></a>XML 中三种配置 bean 的方法</h2><h3 id="使用默认构造函数创建"><a href="#使用默认构造函数创建" class="headerlink" title="使用默认构造函数创建"></a>使用默认构造函数创建</h3><p>​        在<code>&lt;beans&gt;</code>标签中添加如下<code>&lt;bean&gt;</code>标签</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.lmh.service.impl.AccountServiceImpl"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        在 Spring 的配置文件中使用<code>&lt;bean&gt;</code>标签，配以<code>id</code>和<code>class</code>属性之后，且没有其他属性和标签时采用的是默认构造函数创建 bean 对象，此时如果类中没有默认构造函数，则对象无法创建</p><h3 id="使用普通工厂方法"><a href="#使用普通工厂方法" class="headerlink" title="使用普通工厂方法"></a>使用普通工厂方法</h3><p>​        这种方法是在需要创建的对象是在另一个不能修改的（jar包中）类中的方法创建的对象时，我们需要通过创建一个工厂的<code>&lt;bean&gt;</code>和所需对象的<code>&lt;bean&gt;</code>两组标签来实现</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"instanceFactory"</span> <span class="attr">class</span>=<span class="string">"com.lmh.factory.InstanceFactory"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountDao"</span> <span class="attr">factory-bean</span>=<span class="string">"instanceFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getAccountDao"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        被创建的类需要指明 factory 的<code>&lt;bean&gt;</code>标签中的<code>factory-bean</code>属性以确定调用哪个 factory，并通过<code>factory-method</code>属性来指定 factory 的方法名从而调用方法创建对象</p><h3 id="使用工厂中的静态方法创建对象"><a href="#使用工厂中的静态方法创建对象" class="headerlink" title="使用工厂中的静态方法创建对象"></a>使用工厂中的静态方法创建对象</h3><p>​        当所需对象是被其他类中的静态方法创建时，我们可以不去创建 factory 对象而直接调用静态方法创建 bean</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"accountService"</span> <span class="attr">class</span>=<span class="string">"com.lmh.factory.StaticFactory"</span> <span class="attr">factory-method</span>=<span class="string">"getAccountService"</span>&gt;</span><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring-IOC&quot;&gt;&lt;a href=&quot;#Spring-IOC&quot; class=&quot;headerlink&quot; title=&quot;Spring-IOC&quot;&gt;&lt;/a&gt;Spring-IOC&lt;/h1&gt;&lt;p&gt;​        IOC（Inversion of Control）意为控制反转，把创建对象的权利交给框架，是框架的重要特征，IOC 的作用是消减程序的耦合，解除我们代码中的依赖关系&lt;/p&gt;
&lt;p&gt;​        下面我们主要说明基于XML 文件来使用 IOC 的过程，以及使用 XML 文件创建 bean 的三种方式&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring框架" scheme="http://yoursite.com/tags/Spring%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JAVA中的静态代码块和构造代码块</title>
    <link href="http://yoursite.com/2020/03/02/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JAVA%E4%B8%AD%E7%9A%84%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97%E5%92%8C%E6%9E%84%E9%80%A0%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
    <id>http://yoursite.com/2020/03/02/JAVA基础——JAVA中的静态代码块和构造代码块/</id>
    <published>2020-03-02T12:20:48.000Z</published>
    <updated>2020-03-02T12:36:43.851Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA-中的代码块"><a href="#JAVA-中的代码块" class="headerlink" title="JAVA 中的代码块"></a>JAVA 中的代码块</h1><p>​        在 Java 的 Class 中，存在着静态代码块、构造代码块、构造函数、普通代码块等结构，他们在 Class 中执行的顺序以及功能也有区别</p><a id="more"></a><h1 id="静态代码块"><a href="#静态代码块" class="headerlink" title="静态代码块"></a>静态代码块</h1><p>​        静态代码块的编写格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> &#123;</span><br><span class="line">    System.out.println(<span class="string">"Static"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        静态代码块在 Class 被加载时运行，且只运行一次，它的执行顺序优先于各种其他代码块以及构造函数，当一个类中有许多静态代码块时，会按照编写的顺序执行</p><p>​        静态代码块不能存在于任何方法体中，原因很简单，所有的方法都要在 Class 对象被创建时或者创建后执行，并且是主动执行的（除构造方法外，所有的方法都是被动执行的），而静态代码块在类被加载时就需要执行，这是冲突的</p><p>​        另外，静态代码块中是不能调用普通的类变量的，因为普通的类变量必须通过类来进行调用，所以静态代码块只能使用类中的静态变量</p><h1 id="构造代码块"><a href="#构造代码块" class="headerlink" title="构造代码块"></a>构造代码块</h1><p>​        构造代码块的编写格式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">System.out.println(<span class="string">"construction"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        和构造函数类似，构造代码块在 Class 被创建时执行，虽然构造代码块在构造函数“前”执行，但不是真的前，实际上，我们可以理解为：构造代码块是被作为一部分代码，插入到构造函数的最前端被执行的，构造代码块常用来执行一些所有构造函数中都需要存在的代码</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JAVA-中的代码块&quot;&gt;&lt;a href=&quot;#JAVA-中的代码块&quot; class=&quot;headerlink&quot; title=&quot;JAVA 中的代码块&quot;&gt;&lt;/a&gt;JAVA 中的代码块&lt;/h1&gt;&lt;p&gt;​        在 Java 的 Class 中，存在着静态代码块、构造代码块、构造函数、普通代码块等结构，他们在 Class 中执行的顺序以及功能也有区别&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>算法——使用DFS解决全排列问题</title>
    <link href="http://yoursite.com/2020/02/27/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8DFS%E8%A7%A3%E5%86%B3%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/02/27/算法——使用DFS解决全排列问题/</id>
    <published>2020-02-27T14:48:40.000Z</published>
    <updated>2020-02-27T15:25:11.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-DFS"><a href="#什么是-DFS" class="headerlink" title="什么是 DFS"></a>什么是 DFS</h1><p>​        DFS 是深度优先遍历，将序列抽象成树状结构，以优先深度的方式进行遍历，获取想要的结果</p><a id="more"></a><h2 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h2><p>​        假设一个树的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    1 </span><br><span class="line">  2   3</span><br><span class="line">4  5 5  7</span><br></pre></td></tr></table></figure><p>​        使用深度优先遍历的遍历顺序就是<code>1-&gt;2-&gt;4-&gt;5-&gt;3-&gt;5-&gt;7</code>，也就是说，深度优先遍历会从根节点<code>root</code>开始，以深度优先遍历到其一个 <em>不能再继续向下遍历</em> 的子孙节点，然后回溯到该节点的父节点，再重复向下遍历和回溯的过程</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>​        DFS 的优点是，使用 DFS 进行遍历，空间的占用是<code>O(h)</code>（h 为树的高度）级别的，因为空间占有最多的时候，也就是遍历到最深的叶子节点时，此时空间的使用是等于树的高度的</p><p>​        而由于 DFS 执着与向下搜索，可能会错过更近的答案，从而浪费运算的时间，即如果树的第二层和第五层都存在答案，DFS 可能会先找到第五层的目标而不是第二层的</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>​        这是一道全排列问题，即给定<code>n</code>，我们要给出<code>1 ~ n</code>这些数字所能排列出的所有情况，这里<code>1 ≤ n ≤ 7</code></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>​        首先考虑思路，全排列问题是经典的 DFS 问题，假定<code>n = 3</code>，我们要给出<code>1 ~ 3</code>的全排列，正确结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 </span><br><span class="line">1 3 2 </span><br><span class="line">2 1 3 </span><br><span class="line">2 3 1 </span><br><span class="line">3 1 2 </span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure><p>​        我们可以把它抽象为一个树，我们首先考虑第一位的元素，有三种情况<code>1、2、3</code>，这就是树的三个分支，再考虑<code>1</code>的分支的第二位，有<code>12、13</code>两种情况，这两种情况又是<code>1</code>的两个分支，在考虑<code>12</code>，只剩<code>123</code>一种情况了，到此，从<code>1</code>开始的一个分支就彻底结束了，我们也得到了全排列的第一个情况</p><p>​        这是我们还位于<code>123</code>，下一步就是回溯，向上回溯，首先来到<code>12</code>，我们发现它只有<code>123</code>一个分支，已经被遍历完了，所以继续向上回溯，来到<code>1</code>，我们发现它还有一个<code>13</code>分支没有遍历，我们就继续遍历<code>13</code>，如此一直重复下去，直到所有的分支都遍历结束后，我们也就得到了全排列的全部结果</p><h2 id="代码-注释"><a href="#代码-注释" class="headerlink" title="代码 + 注释"></a>代码 + 注释</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="comment">// 用来存储结果的数组</span></span><br><span class="line"><span class="keyword">int</span> path[N];</span><br><span class="line"><span class="comment">// 用来标志元素是否被使用过的数组</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 dfs 层数 == 最大深度，就输出这种情况</span></span><br><span class="line">    <span class="keyword">if</span> (u == n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, path[i]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 深度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 每遍历到一个元素，先检测是否重复</span></span><br><span class="line">        <span class="keyword">if</span> (!st[i]) &#123;</span><br><span class="line">            <span class="comment">// 设定当前位置的值</span></span><br><span class="line">            path[u] = i;</span><br><span class="line">            <span class="comment">// 将这个值标记为已用</span></span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 继续向下遍历</span></span><br><span class="line">            dfs(u + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 恢复原样</span></span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="comment">// 从 0 开始 DFS</span></span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是-DFS&quot;&gt;&lt;a href=&quot;#什么是-DFS&quot; class=&quot;headerlink&quot; title=&quot;什么是 DFS&quot;&gt;&lt;/a&gt;什么是 DFS&lt;/h1&gt;&lt;p&gt;​        DFS 是深度优先遍历，将序列抽象成树状结构，以优先深度的方式进行遍历，获取想要的结果&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JDK实现的动态代理</title>
    <link href="http://yoursite.com/2020/02/21/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JDK%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2020/02/21/JAVA基础——JDK实现的动态代理/</id>
    <published>2020-02-21T03:02:32.000Z</published>
    <updated>2020-02-22T01:47:27.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA-中的动态代理"><a href="#JAVA-中的动态代理" class="headerlink" title="JAVA 中的动态代理"></a>JAVA 中的动态代理</h1><p>​        动态代理和静态代理类的区别在于，动态代理可以在程序运行时，动态地创建代理类，执行被代理类方法的同时，可以运行被代理类调用的拓展方法</p><a id="more"></a><h1 id="JDK-实现的动态代理"><a href="#JDK-实现的动态代理" class="headerlink" title="JDK 实现的动态代理"></a>JDK 实现的动态代理</h1><p>​        </p><p>​        JDK 的动态代理要通过<code>import java.lang.reflect</code>包中的内容实现，代理类需要调用该包下的<code>Proxy</code>类下的<code>newProxyInstance</code>方法，返回一个<code>Object</code>类型的对象，这个对象就是实现代理类功能的对象，通过强制转换，可以转换为被代理类的对象使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure><p>​        上边是<code>newProxyInstance</code>方法的定义，该方法中有三个参数，第一个<code>ClassLoader</code>类型是一个类加载器，这个参数是要加载当前的代理类，即假如代理类名为<code>userServiceProxy</code>，这里的参数即为<code>userServiceProxy.class.getClassLoader()</code>，第二个则是一个接口，用来表示包含被代理类全部内容的接口</p><p>​        最后一个参数是一个<code>InvocationHandler</code>的接口，它内部只有一个<code>invoke</code>方法，用来实现代理类中向被代理类拓展内容的功能，<code>InvocationHandler</code>类定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        所以我们实现的<code>InvocationHandler</code>接口也需要重写这个方法，这个方法也是我们关联代理类和被代理类的关键，该方法需要返回一个<code>Object</code>类型的对象，我们通过反射，让被代理类和代理类产生关联，并且在这方法中，我们可以自行在其中定义拓展内容</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>​        接口、实现类（被代理类）、切面方法类同之前静态代理的没有区别，地址戳：<a href="https://blog.csdn.net/scfor333/article/details/104420155" target="_blank" rel="noopener">https://blog.csdn.net/scfor333/article/details/104420155</a></p><h2 id="代理类"><a href="#代理类" class="headerlink" title="代理类"></a>代理类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jdkProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserService <span class="title">createUserService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        MyAspcet aspcet = <span class="keyword">new</span> MyAspcet();</span><br><span class="line">        UserService userServiceProxy = (UserService) Proxy.newProxyInstance(</span><br><span class="line">            UserServiceProxy.class.getClassLoader(), </span><br><span class="line">            userService.getClass().getInterfaces(), </span><br><span class="line">            <span class="keyword">new</span> InvocationHandler()&#123;</span><br><span class="line">            </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                    aspcet.before();</span><br><span class="line">                    Object retObj = method.invoke(userService, args);</span><br><span class="line">                    System.out.println(<span class="string">"拦截到的返回值"</span> + retObj);</span><br><span class="line">                    aspcet.after();</span><br><span class="line">                    <span class="keyword">return</span> retObj;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">return</span> userServiceProxy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jdkProxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService userService = UserServiceProxy.createUserService();</span><br><span class="line">        userService.add();</span><br><span class="line">        userService.delete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">before method</span><br><span class="line">service add</span><br><span class="line">拦截到的返回值null</span><br><span class="line">after method</span><br><span class="line">before method</span><br><span class="line">service delete</span><br><span class="line">拦截到的返回值null</span><br><span class="line">after method</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JAVA-中的动态代理&quot;&gt;&lt;a href=&quot;#JAVA-中的动态代理&quot; class=&quot;headerlink&quot; title=&quot;JAVA 中的动态代理&quot;&gt;&lt;/a&gt;JAVA 中的动态代理&lt;/h1&gt;&lt;p&gt;​        动态代理和静态代理类的区别在于，动态代理可以在程序运行时，动态地创建代理类，执行被代理类方法的同时，可以运行被代理类调用的拓展方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——静态代理</title>
    <link href="http://yoursite.com/2020/02/20/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2020/02/20/JAVA基础——静态代理/</id>
    <published>2020-02-20T14:19:45.000Z</published>
    <updated>2020-02-20T14:56:22.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA-中的代理"><a href="#JAVA-中的代理" class="headerlink" title="JAVA 中的代理"></a>JAVA 中的代理</h1><p>​        代理是一种<code>23</code>种经典设计模式之一，可以实现在不改变功能函数的情况下，实现对该函数、对象的功能拓展</p><a id="more"></a><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>​        静态代理是一种手动实现的，在程序运行之前代理类和被代理类的代理关系已经被确定好了，在使用静态代理时，代理类和被代理类必须实现同一个接口，演示如下</p><p>​        首先是接口类，很简单，就两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Aspect;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        然后是被代理类，直接实现接口类的方法，并打印输出以区分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Aspect;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被代理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">"service add"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">"service delete"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这里我还自己定义了一个切面方法类，用来表示需要插入在功能函数前后的拓展方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Aspect;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切面方法类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        然后我们来实现代理类，所谓代理类就是要代理执行被代理类中的功能，所以要在代理类中创建一个被代理类对象，之前说过，静态代理实现的前提是代理类和被代理类必须实现同一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Aspect;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line"></span><br><span class="line">    myAspect aspect = <span class="keyword">new</span> myAspect();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        aspect.before();</span><br><span class="line">        userService.add();</span><br><span class="line">        aspect.after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        aspect.before();</span><br><span class="line">        userService.delete();</span><br><span class="line">        aspect.after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        最后我们实现一个测试类，通过接口指向实现类来创建一个代理类对象，调用其中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Aspect;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserServiceProxy();</span><br><span class="line">        userService.add();</span><br><span class="line">        userService.delete();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">before method</span><br><span class="line">service add</span><br><span class="line">after method</span><br><span class="line">before method</span><br><span class="line">service delete</span><br><span class="line">after method</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​        这就是 JAVA 中的静态代理，静态代理很简陋，没有什么不好理解的地方，在使用上也没有十分方便，由于静态的原因，使用前代理类和被代理类的关系需要提前设定好，所以静态代理也存在很大的局限性</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JAVA-中的代理&quot;&gt;&lt;a href=&quot;#JAVA-中的代理&quot; class=&quot;headerlink&quot; title=&quot;JAVA 中的代理&quot;&gt;&lt;/a&gt;JAVA 中的代理&lt;/h1&gt;&lt;p&gt;​        代理是一种&lt;code&gt;23&lt;/code&gt;种经典设计模式之一，可以实现在不改变功能函数的情况下，实现对该函数、对象的功能拓展&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>算法——插入排序及优化（希尔排序）</title>
    <link href="http://yoursite.com/2020/02/17/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%8F%8A%E4%BC%98%E5%8C%96%EF%BC%88%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%89/"/>
    <id>http://yoursite.com/2020/02/17/算法——插入排序及优化（希尔排序）/</id>
    <published>2020-02-17T07:56:47.000Z</published>
    <updated>2020-02-17T08:22:52.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>​        插入排序是排序算法的一种，顾名思义，是一种插入的形态进行排序的算法</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>​        插入排序的过程可以形象的比做我们打扑克抓牌时，整理扑克牌的过程，每次我们抽一张新牌时，会以特定的规律，将其插入到已有的牌中，使手中的牌形成一个有序的牌的集合</p><p>​        插入排序也是如此我们使用两个嵌套的<code>for</code>循环从头开始遍历一个序列，外部的<code>for</code>循环顺序向下执行，内部的<code>for</code>循环负责比较其当前遍历的位置元素是否小于（或大于）它前面的所有元素，如果是，就调换其位置，以此类推，最后得到一个有序的序列</p><h2 id="Java-代码"><a href="#Java-代码" class="headerlink" title="Java 代码"></a>Java 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; nums[j] &lt; nums[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> item = nums[j - <span class="number">1</span>];</span><br><span class="line">            nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">            nums[j] = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>​        从插入排序的定义中我们可以发现，如果一个尽量有序的序列，例如<code>[1, 2, 3, 4, 0]</code>，实际上插入排序的效率是接近<code>O(N)</code>的，因为它的内层循环实际上只运行了一次，所以插入排序十分适合对已经尽量有序的序列来进行排序</p><h1 id="优化插入排序——希尔排序"><a href="#优化插入排序——希尔排序" class="headerlink" title="优化插入排序——希尔排序"></a>优化插入排序——希尔排序</h1><p>​        为了优化插入排序，我们可以先使数组尽可能多的有序化，或者说局部有序化，希尔排序就诞生了</p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>​        希尔排序的原理是通过间隔<code>h</code>分组，将原序列分成又干个不相邻的间隔为<code>h</code>的两两一组的序列，对这两个元素进行插入排序，然后缩小间隔<code>h</code>，再两两进行插入排序，在这个过程中，原序列会从无序越来越趋近于有序，当<code>h = 0</code>时，虽然是对整个序列进行插入排序，但此时序列已经相对的更加有序，所以效率会得到提高</p><h2 id="Java-代码-1"><a href="#Java-代码-1" class="headerlink" title="Java 代码"></a>Java 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellsort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = nums.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; N / <span class="number">3</span>)</span><br><span class="line">        h = h * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; nums[j] &lt; nums[j - h]; j -= h) &#123;</span><br><span class="line">                <span class="keyword">int</span> item = nums[j];</span><br><span class="line">                nums[j] = nums[j - h];</span><br><span class="line">                nums[j - h] = item;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h1&gt;&lt;p&gt;​        插入排序是排序算法的一种，顾名思义，是一种插入的形态进行排序的算法&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽得算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E5%BE%97%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-98——验证二叉搜索树</title>
    <link href="http://yoursite.com/2020/02/15/LeetCode-98%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88Java%E3%80%81Python%EF%BC%89/"/>
    <id>http://yoursite.com/2020/02/15/LeetCode-98——验证二叉搜索树（Java、Python）/</id>
    <published>2020-02-15T13:57:56.000Z</published>
    <updated>2020-02-15T14:26:11.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>​        给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>​        假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含小于当前节点的数</li><li>节点的右子树只包含大于当前节点的数</li><li>所有左子树和右子树自身必须也是二叉搜索树</li></ul><p>​        示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  1   4</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>​        这道题提供三种解法</p><h2 id="使用二叉树中序遍历的方法"><a href="#使用二叉树中序遍历的方法" class="headerlink" title="使用二叉树中序遍历的方法"></a>使用二叉树中序遍历的方法</h2><p>​        根据二叉搜索树的性质，可以得出二叉搜索树使用中序遍历得到的序列应该是一个升序的序列，所以我们可以利用这一性质来判断其是否为二叉搜索树</p><h2 id="Python-代码"><a href="#Python-代码" class="headerlink" title="Python 代码"></a>Python 代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    inorder = self.inorder(root)</span><br><span class="line">    <span class="keyword">return</span> inorder == list(sorted(set(inorder)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">return</span> self.inorder(root.left) + [root.val] + self.inorder(root.right)</span><br></pre></td></tr></table></figure><h2 id="只考虑当前节点的上一级"><a href="#只考虑当前节点的上一级" class="headerlink" title="只考虑当前节点的上一级"></a>只考虑当前节点的上一级</h2><p>​        另外，我们可以简化上面的方法，因为二叉搜索树实际上就是要保证，在中序遍历的顺序下，当前节点的值一定要大于前一个节点的值</p><h2 id="Python-代码-1"><a href="#Python-代码-1" class="headerlink" title="Python 代码"></a>Python 代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    self.prev = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> self.helper(root)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.helper(root.left):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> self.prev <span class="keyword">and</span> self.prev.val &gt;= root.val:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    self.prev = root</span><br><span class="line">    <span class="keyword">return</span> self.helper(root.right)</span><br></pre></td></tr></table></figure><h2 id="使用递归"><a href="#使用递归" class="headerlink" title="使用递归"></a>使用递归</h2><p>​        除中序遍历的方法外，我们还可以使用递归的思想，根据二叉搜索树的性质，我们只需要满足<code>当前节点的左子树中的最大值比节点值小，右子树中的最小值比节点值大</code>即可证明其为二叉搜索树</p><h2 id="Java-代码"><a href="#Java-代码" class="headerlink" title="Java 代码"></a>Java 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(TreeNode root, Integer min, Integer max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (min != <span class="keyword">null</span> &amp;&amp; root.val &lt;= min)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (max != <span class="keyword">null</span> &amp;&amp; root.val &gt;= max)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> helper(root.left, min, root.val) &amp;&amp; helper(root.right, root.val, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;​        给定一个二叉树，判断其是否是一个有效的二叉搜索树。&lt;/p&gt;
&lt;p&gt;​        假设一个二叉搜索树具有如下特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点的左子树只包含小于当前节点的数&lt;/li&gt;
&lt;li&gt;节点的右子树只包含大于当前节点的数&lt;/li&gt;
&lt;li&gt;所有左子树和右子树自身必须也是二叉搜索树&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​        示例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  1   3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  1   4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    3   6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 输入为: [5,1,4,null,null,3,6]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     根节点的值为 5 ，但是其右子节点值为 4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-242——有效的字母异位词（Java、Python）</title>
    <link href="http://yoursite.com/2020/02/15/LeetCode-242%E2%80%94%E2%80%94%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%EF%BC%88Java%E3%80%81Python%EF%BC%89/"/>
    <id>http://yoursite.com/2020/02/15/LeetCode-242——有效的字母异位词（Java、Python）/</id>
    <published>2020-02-15T13:22:07.000Z</published>
    <updated>2020-02-15T13:51:06.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>​        给定两个字符串<code>s</code>和<code>t</code>，编写一个函数来判断<code>t</code>是否是<code>s</code>的字母异位词</p><p>​        示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>​        这里提供三种解法</p><h2 id="直接排序"><a href="#直接排序" class="headerlink" title="直接排序"></a>直接排序</h2><p>​        因为大部分语言中都自带排序函数，我们可以直接把两个字符串进行排序，因为如果两个字符串互为字母异位词的话，那么他们所包含的字母及每个字母的数量就是一致的，代码很简洁，使用 Python 的话只有两行</p><h2 id="Python-代码"><a href="#Python-代码" class="headerlink" title="Python 代码"></a>Python 代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sorted(s) == sorted(t)</span><br></pre></td></tr></table></figure><h2 id="使用-map-记住每个字母的数量"><a href="#使用-map-记住每个字母的数量" class="headerlink" title="使用 map 记住每个字母的数量"></a>使用 map 记住每个字母的数量</h2><p>​        我们也可以利用 map 键值对的特性，使用两个 map 来存储每个字符串中的每一个字母出现的次数，最后直接比较这两个 map 是否相等即可，代码使用的是 Python 中的字典</p><h2 id="Python-代码-1"><a href="#Python-代码-1" class="headerlink" title="Python 代码"></a>Python 代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">    dic1, dic2 = &#123;&#125;, &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> s:</span><br><span class="line">        dic1[item] = dic1.get(item, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> t:</span><br><span class="line">        dic2[item] = dic2.get(item, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dic1 == dic2</span><br></pre></td></tr></table></figure><h2 id="使用长度为-26-的数组计数"><a href="#使用长度为-26-的数组计数" class="headerlink" title="使用长度为 26 的数组计数"></a>使用长度为 26 的数组计数</h2><p>​        题目给出了两个字符串中的字符均为小写，我们可以直接初始化两个长为 26，初始值都为 0 的数组，然后遍历两个字符串来给字符串中的字符进行计数，最后比较数组是否相等</p><h2 id="Java-代码"><a href="#Java-代码" class="headerlink" title="Java 代码"></a>Java 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        a[(<span class="keyword">int</span>)c - (<span class="keyword">int</span>)(<span class="string">'a'</span>)] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">        b[(<span class="keyword">int</span>)c - (<span class="keyword">int</span>)(<span class="string">'a'</span>)] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.equals(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Python-代码-2"><a href="#Python-代码-2" class="headerlink" title="Python 代码"></a>Python 代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">    dic1, dic2 = [<span class="number">0</span>] * <span class="number">26</span>, [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> s:</span><br><span class="line">        dic1[ord(item) - ord(<span class="string">'a'</span>)] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> t:</span><br><span class="line">        dic2[ord(item) - ord(<span class="string">'a'</span>)] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dic1 == dic2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;​        给定两个字符串&lt;code&gt;s&lt;/code&gt;和&lt;code&gt;t&lt;/code&gt;，编写一个函数来判断&lt;code&gt;t&lt;/code&gt;是否是&lt;code&gt;s&lt;/code&gt;的字母异位词&lt;/p&gt;
&lt;p&gt;​        示例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: s = &amp;quot;rat&amp;quot;, t = &amp;quot;car&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-141——环形链表</title>
    <link href="http://yoursite.com/2020/02/14/LeetCode-141%E2%80%94%E2%80%94%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%EF%BC%88Java%E3%80%81Python%EF%BC%89/"/>
    <id>http://yoursite.com/2020/02/14/LeetCode-141——环形链表（Java、Python）/</id>
    <published>2020-02-14T14:22:46.000Z</published>
    <updated>2020-02-14T14:40:16.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>​        给定一个链表，判断链表中是否有环</p><p>​        为了表示给定链表中的环，我们使用整数<code>pos</code>来表示链表尾连接到链表中的位置（索引从<code>0</code>开始）。 如果<code>pos</code>是<code>-1</code>，则在该链表中没有环</p><p>​        示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br><span class="line"></span><br><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>​        这里给这道题提供两种解法</p><h2 id="使用-Set"><a href="#使用-Set" class="headerlink" title="使用 Set"></a>使用 Set</h2><p>​        检测一个链表中是否存在环，可以理解为检测链表中存不存在一个节点，这个节点有两个指针同时指向它，这样链表中就产生了环，我们可以使用 Set 来解决这个问题</p><p>​        我们从头至尾遍历这个链表，每到一个节点，就检测实现定义好的 Set 中是否存在一个相同的节点，不存在就将它放入 Set，反之如果存在，就说明这个节点被两个节点同时所指向，使链表形成了环</p><h2 id="Java-代码"><a href="#Java-代码" class="headerlink" title="Java 代码"></a>Java 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(head))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            set.add(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用快慢指针"><a href="#使用快慢指针" class="headerlink" title="使用快慢指针"></a>使用快慢指针</h2><p>​        另一种方法是使用快慢指针，即定义两个指针，都从链表的头部开始遍历，只要保证慢指针每次走的步数小于快指针即可（通常就慢指针一次走一个节点，快指针一次走两个就行），当其中一个指针为空了，就说明链表到头了，没有环，而如果两个指针相遇了，就说明链表是有环的</p><p>​        这个解法的原理就是，如果链表没有环，快慢指针永远都不会相遇</p><h2 id="Java-代码-1"><a href="#Java-代码-1" class="headerlink" title="Java 代码"></a>Java 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode fast = head, slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; slow != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Python-代码"><a href="#Python-代码" class="headerlink" title="Python 代码"></a>Python 代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">    fast = slow = head</span><br><span class="line">    <span class="keyword">while</span> slow <span class="keyword">and</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">        <span class="keyword">if</span> slow <span class="keyword">is</span> fast:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;​        给定一个链表，判断链表中是否有环&lt;/p&gt;
&lt;p&gt;​        为了表示给定链表中的环，我们使用整数&lt;code&gt;pos&lt;/code&gt;来表示链表尾连接到链表中的位置（索引从&lt;code&gt;0&lt;/code&gt;开始）。 如果&lt;code&gt;pos&lt;/code&gt;是&lt;code&gt;-1&lt;/code&gt;，则在该链表中没有环&lt;/p&gt;
&lt;p&gt;​        示例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：head = [3,2,0,-4], pos = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：链表中有一个环，其尾部连接到第二个节点。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：head = [1,2], pos = 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：链表中有一个环，其尾部连接到第一个节点。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-206——反转链表（Java、Python）</title>
    <link href="http://yoursite.com/2020/02/14/LeetCode-206%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88Java%E3%80%81Python%EF%BC%89/"/>
    <id>http://yoursite.com/2020/02/14/LeetCode-206——反转链表（Java、Python）/</id>
    <published>2020-02-14T13:47:48.000Z</published>
    <updated>2020-02-14T14:41:07.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>​        反转一个链表</p><p>​        示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>​        这道题我们需要两个额外的链表节点变量<code>ListNode</code>来协助完成</p><p>​        假设我们有一个<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>的链表，我们定义<code>cur</code>和<code>prev</code>两个节点变量，分别用来表示当前节点和上一个节点，<code>cur</code>初始指向头节点，<code>prev</code>初始为空，然后遍历这个链表</p><p>​        从<code>1</code>这个节点开始，此时<code>cur</code>即为<code>1</code>，我们只需要在遍历过程中不断的改变每个节点指针的方向，让它指向前一个节点即可，需要注意的就是，大部分语言都需要实现存下<code>cur.next</code>的值，否则在指针的变换中可能会使链表断掉</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="Java-版"><a href="#Java-版" class="headerlink" title="Java 版"></a>Java 版</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode temp = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Python-版"><a href="#Python-版" class="headerlink" title="Python 版"></a>Python 版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(head)</span>:</span></span><br><span class="line">    cur, prev = head, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        cur.next, prev, cur = prev, cur, cur.next</span><br><span class="line">    <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><p>​        Python 的代码中<code>cur.next, prev, cur = prev, cur, cur.next</code>使用了多重赋值的语法，关于多重赋值原理的解释，看这里：<a href="https://blog.csdn.net/scfor333/article/details/104316694" target="_blank" rel="noopener">https://blog.csdn.net/scfor333/article/details/104316694</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;​        反转一个链表&lt;/p&gt;
&lt;p&gt;​        示例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python——NumPy安装、NdArray对象的简单使用、NumPy的数据类型</title>
    <link href="http://yoursite.com/2020/02/06/Python%E2%80%94%E2%80%94NumPy%E5%AE%89%E8%A3%85%E3%80%81NdArray%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E3%80%81NumPy%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/02/06/Python——NumPy安装、NdArray对象的简单使用、NumPy的数据类型/</id>
    <published>2020-02-06T15:30:33.000Z</published>
    <updated>2020-02-06T15:31:58.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-NumPy"><a href="#什么是-NumPy" class="headerlink" title="什么是 NumPy"></a>什么是 NumPy</h1><blockquote><p>NumPy 是一个用 python 实现的科学计算，包括：1、一个强大的 N 维数组对象 Array；2、比较成熟的（广播）函数库；3、用于整合 C/C++ 和 Fortran 代码的工具包；4、实用的线性代数、傅里叶变换和随机数生成函数，numpy 和稀疏矩阵运算包scipy配合使用更加方便</p><p>​        NumPy（Numeric Python）提供了许多高级的数值编程工具，如：矩阵数据类型、矢量处理，以及精密的运算库，专为进行严格的数字处理而产生，多为很多大型金融公司使用，以及核心的科学计算组织如：Lawrence Livermore， NASA 用其处理一些本来使用 C++，Fortran 或 MatLab 等所做的任务</p></blockquote><a id="more"></a><h2 id="安装-NumPy"><a href="#安装-NumPy" class="headerlink" title="安装 NumPy"></a>安装 NumPy</h2><p>​        在 windows 下，推荐使用下载 Python 发行版的方式，它会包含很多关键的包，比如<code>NumPy</code>、<code>Pandas</code>等</p><p>​        我选择的是<code>ANACONDA</code>，可以直接百度搜索到官网下载，但是会很慢，可以在清华大学开源镜像站下载，连接是</p><blockquote><p><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a></p></blockquote><p>​        下载安装后，系统就已经拥有 NumPy 包了</p><p>​        也可以使用 PIP 命令直接安装</p><h3 id="导入-NumPy"><a href="#导入-NumPy" class="headerlink" title="导入 NumPy"></a>导入 NumPy</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><p>​        上边的代码是向程序中导入 NumPy 库，如果导入成功，也就说明 NumPy 库安装成功了</p><h2 id="NumPy-中的-NdArray-对象"><a href="#NumPy-中的-NdArray-对象" class="headerlink" title="NumPy 中的 NdArray 对象"></a>NumPy 中的 NdArray 对象</h2><p>​        NumPy 最最最重要的特点就是它所包含的多维数组对象：<code>ndarray</code>，它是用于存放同类元素的多维数组</p><h3 id="NdArray-的使用"><a href="#NdArray-的使用" class="headerlink" title="NdArray 的使用"></a>NdArray 的使用</h3><h4 id="创建一个-NdArray-对象"><a href="#创建一个-NdArray-对象" class="headerlink" title="创建一个 NdArray 对象"></a>创建一个 NdArray 对象</h4><p>​        <code>ndarray</code>数组可以直接通过<code>numpy.array(object, dtype = None, copy = True, order = None, subok = False, nfmin = 0)</code>方法来创建，下面说一下<code>ndarray</code>的重要参数</p><ul><li>object：数组或嵌套数列</li><li>dtype：数组元素的数据类型，可选</li><li>copy：对象是否需要复制，可选</li><li>order：创建数组呃样式，C 为行方向，F 为列方向，A 为任意方向（默认）</li><li>subok：默认返回一个与基类类型一致的数组</li><li>ndmin：指定生成数组的最小维度</li></ul><p>​        下面是一个创建多维数组的简单示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array(</span><br><span class="line">    [</span><br><span class="line">        [</span><br><span class="line">            [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">            [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">            [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">        ],</span><br><span class="line">        [</span><br><span class="line">            [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">            [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">            [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">        ]</span><br><span class="line">    ]，</span><br><span class="line">    dtype=np.int</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="NumPy-中的数据类型"><a href="#NumPy-中的数据类型" class="headerlink" title="NumPy 中的数据类型"></a>NumPy 中的数据类型</h2><p>​        <code>numpy</code>支持的数据类型比<code>Python</code>内置的数据类型多得多，如下表：</p><table><thead><tr><th align="center">数据类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">bool_</td><td align="center">布尔型数据类型（True 或 False）</td></tr><tr><td align="center">int_</td><td align="center">默认的整数类型（类似于 C 语言中的 long）</td></tr><tr><td align="center">intc</td><td align="center">同 C 语言中的 int 类型一样</td></tr><tr><td align="center">intp</td><td align="center">用于索引的整数类型</td></tr><tr><td align="center">int8</td><td align="center">字节（-128 to 127）</td></tr><tr><td align="center">int16</td><td align="center">整数（-32768 to 32767）</td></tr><tr><td align="center">int32</td><td align="center">整数（-2147483648 to 2147483647）</td></tr><tr><td align="center">int64</td><td align="center">整数（-9223372036854775808 to 9223372036854775807）</td></tr><tr><td align="center">uint8</td><td align="center">无符号整数（0 to 255）</td></tr><tr><td align="center">uint16</td><td align="center">无符号整数（0 to 65535）</td></tr><tr><td align="center">uint32</td><td align="center">无符号整数（0 to 4294967295）</td></tr><tr><td align="center">uint64</td><td align="center">无符号整数（0 to 18446744073709551615）</td></tr><tr><td align="center">float_</td><td align="center">float64 类型的简写</td></tr><tr><td align="center">float16</td><td align="center">半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位</td></tr><tr><td align="center">float32</td><td align="center">单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位</td></tr><tr><td align="center">float64</td><td align="center">双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位</td></tr><tr><td align="center">complex_</td><td align="center">complex128 类型的简写，即 128 位复数</td></tr><tr><td align="center">complex64</td><td align="center">复数，表示双 32 位浮点数（实数部分和虚数部分）</td></tr><tr><td align="center">complex128</td><td align="center">复数，表示双 64 位浮点数（实数部分和虚数部分）</td></tr></tbody></table><p>​        并且，在<code>numpy</code>中，每个内建类型都有一个唯一定义的字符代码：</p><table><thead><tr><th align="center">字符</th><th align="center">对应类型</th></tr></thead><tbody><tr><td align="center">b</td><td align="center">布尔型</td></tr><tr><td align="center">i</td><td align="center">(有符号) 整型</td></tr><tr><td align="center">u</td><td align="center">无符号整型 integer</td></tr><tr><td align="center">f</td><td align="center">浮点型</td></tr><tr><td align="center">c</td><td align="center">复数浮点型</td></tr><tr><td align="center">m</td><td align="center">timedelta（时间间隔）</td></tr><tr><td align="center">M</td><td align="center">datetime（日期时间）</td></tr><tr><td align="center">O</td><td align="center">(Python) 对象</td></tr><tr><td align="center">S, a</td><td align="center">(byte-)字符串</td></tr><tr><td align="center">U</td><td align="center">Unicode</td></tr><tr><td align="center">V</td><td align="center">原始数据 (void)</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是-NumPy&quot;&gt;&lt;a href=&quot;#什么是-NumPy&quot; class=&quot;headerlink&quot; title=&quot;什么是 NumPy&quot;&gt;&lt;/a&gt;什么是 NumPy&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;NumPy 是一个用 python 实现的科学计算，包括：1、一个强大的 N 维数组对象 Array；2、比较成熟的（广播）函数库；3、用于整合 C/C++ 和 Fortran 代码的工具包；4、实用的线性代数、傅里叶变换和随机数生成函数，numpy 和稀疏矩阵运算包scipy配合使用更加方便&lt;/p&gt;
&lt;p&gt;​        NumPy（Numeric Python）提供了许多高级的数值编程工具，如：矩阵数据类型、矢量处理，以及精密的运算库，专为进行严格的数字处理而产生，多为很多大型金融公司使用，以及核心的科学计算组织如：Lawrence Livermore， NASA 用其处理一些本来使用 C++，Fortran 或 MatLab 等所做的任务&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="李明徽的Python" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84Python/"/>
    
  </entry>
  
  <entry>
    <title>Python——生产者消费者问题、死锁、同步和异步</title>
    <link href="http://yoursite.com/2020/02/05/Python%E2%80%94%E2%80%94%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E3%80%81%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5/"/>
    <id>http://yoursite.com/2020/02/05/Python——生产者消费者问题、同步和异步/</id>
    <published>2020-02-05T09:07:58.000Z</published>
    <updated>2020-02-05T10:39:17.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程产生的问题"><a href="#多线程产生的问题" class="headerlink" title="多线程产生的问题"></a>多线程产生的问题</h1><p>​        并发编程由于需要很多线程、进程之间的协作，所以很容易出现问题，下面主要介绍生产者与消费者问题、死锁问题、同步和异步问题</p><a id="more"></a><h2 id="生产者与消费者问题"><a href="#生产者与消费者问题" class="headerlink" title="生产者与消费者问题"></a>生产者与消费者问题</h2><p>​        当我们进行一个任务，需要两个线程不断地获取和操作数据时，可能会产生一个问题，如果数据获取很快，而操作很慢，那么获取数据的线程就必须等待操作数据的线程处理完毕，反之如果数据获取的很慢而操作的很快，那么操作数据的线程就必须等待获取数据的线程，这种问题可以看作是一种生产消费能力的不平衡，称之为生产者与消费者问题</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>​        解决这种生产消费能力不平衡的方法就是，在在生产者和消费者中间设立一个缓冲机制，生产者将生产的数据放入缓冲池中，消费者从缓冲池中取出数据进行处理，当缓冲池中的数据量小于一定的值时，生产者就会向缓冲池中添加数据，而当缓冲池中数据大于一个值时，消费者就会从缓冲池中取出数据，使生产者和消费者达到一种动态的平衡</p><p>​        实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> Queue</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> queue.qsize() &lt; <span class="number">1000</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    msg = <span class="string">'Pro '</span> + str(count)</span><br><span class="line">                    queue.put(msg)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> queue</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> queue.qsize() &gt; <span class="number">100</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                    msg = self.name + <span class="string">'Spend '</span> + queue.get()</span><br><span class="line">                    print(msg)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    queue = Queue()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">500</span>):</span><br><span class="line">        queue.put(<span class="string">'Start Pro '</span> + str(i))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        p = Producer()</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        c = Consumer()</span><br><span class="line">        c.start()</span><br></pre></td></tr></table></figure><p>​        运行结果（截取）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread-7Spend Start Pro 494</span><br><span class="line">Thread-3Spend Start Pro 495</span><br><span class="line">Thread-5Spend Start Pro 496</span><br><span class="line">Thread-5Spend Start Pro 498</span><br><span class="line">Thread-5Spend Start Pro 499</span><br><span class="line">Thread-3Spend Start Pro 497</span><br><span class="line">Thread-3Spend Pro 1</span><br><span class="line">Thread-4Spend Pro 2</span><br><span class="line">Thread-4Spend Pro 3</span><br><span class="line">Thread-4Spend Pro 4</span><br><span class="line">Thread-6Spend Pro 5</span><br><span class="line">Thread-6Spend Pro 6</span><br></pre></td></tr></table></figure><h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><p>​        在多线程中，线程可以通过互斥锁来保证对同一资源的唯一占有，但当程序变得复杂后，可能会出现线程 A 对资源 A 上了锁，而线程 A 后边需要用到资源 B，使用完毕后才会对资源 A解锁，而线程 B 对资源 B 上了锁，它后边选要用到资源 A，用过后才会给 B 解锁，如果线程 A 和线程 B 同时运行，就可能会造成一种情况：线程 A 在等待线程 B 解锁，线程 B 也在等待线程 A 解锁，这就是死锁问题</p><h3 id="死锁模拟"><a href="#死锁模拟" class="headerlink" title="死锁模拟"></a>死锁模拟</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThraed1</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> mutexA.acquire():</span><br><span class="line">            print(self.name + <span class="string">'----do 1----up----'</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> mutexB.acquire():</span><br><span class="line">                print(self.name + <span class="string">'----do 1----down----'</span>)</span><br><span class="line">                mutexB.release()</span><br><span class="line">            mutexA.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> mutexB.acquire():</span><br><span class="line">            print(self.name + <span class="string">'----d0 2----up----'</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> mutexA.acquire():</span><br><span class="line">                print(<span class="string">'----do 2----down----'</span>)</span><br><span class="line">                mutexA.release()</span><br><span class="line">            mutexB.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mutexA = threading.Lock()</span><br><span class="line">mutexB = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t1 = MyThraed1()</span><br><span class="line">    t2 = MyThread2()</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure><p>​        以上代码运行后，毫无疑问会产生死锁问题，结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread-1----do 1----up----</span><br><span class="line">Thread-2----d0 2----up----</span><br></pre></td></tr></table></figure><p>​        程序由于三个线程都在等待对方释放资源而卡住了</p><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p>​        死锁问题应该尽量在设计程序时避免，或添加等待超时时间，从而检测程序是否产生了死锁，另一种就是通过银行家算法也可以避免死锁问题</p><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p>​        银行家算法的思想就是，假设银行有 10 元，这个时候有三个人提出贷款，A 要贷款 9 元，B 要贷款 3 元，C 要贷款 8 元，这时，银行肯定不够将所有人都满足，银行家算法就诞生了</p><p>​        这时银行为了留住所有客户并且保证自己的钱不会不足，便分批贷款给客户，先借给 A 2 元、B 2 元、C 4 元，银行还剩 2 元，此时 B 直需要再借 1 元就满足了他自己的需求，银行便借给他 1 元，自己剩 1 元，当 B 用完，将 3 元还给银行后，银行再将这 4 元借给 C，C 也就满足了，等 C 还款后，再将 8 元中的 7 元借给 A，这样便动态的满足了三个客户的需求</p><p>​        银行家算法在程序中实际上也是模拟了银行贷款的过程，操作系统会动态的向各个线程分配资源，在分配前，系统会判断分配后会不会导致系统进入不安全状态，不会就分配资源给线程，会则令线程等待</p><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>​        同步和异步是并发编程下的两种重要的状态</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>​        同步是指当程序 A 调用程序 B 时，程序 A 停下不动，等待程序 B 完成后再继续运行</p><p>​        举个例子就是，假设 A 喊 B 出去吃饭，B 说等我写完代码再去，A 就一直在原地等着 B，这就是同步</p><p>​        归根结底，同步实现的就是一种顺序的运行</p><h4 id="使用互斥锁实现线程同步"><a href="#使用互斥锁实现线程同步" class="headerlink" title="使用互斥锁实现线程同步"></a>使用互斥锁实现线程同步</h4><p>​        代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task1</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> lock1.acquire():</span><br><span class="line">                print(<span class="string">'-----Task 1-----'</span>)</span><br><span class="line">                sleep(<span class="number">0.5</span>)</span><br><span class="line">                lock2.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task2</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> lock2.acquire():</span><br><span class="line">                print(<span class="string">'-----Task 2-----'</span>)</span><br><span class="line">                sleep(<span class="number">0.5</span>)</span><br><span class="line">                lock3.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task3</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> lock3.acquire():</span><br><span class="line">                print(<span class="string">'-----Task 3-----'</span>)</span><br><span class="line">                sleep(<span class="number">0.5</span>)</span><br><span class="line">                lock1.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lock1 = Lock()</span><br><span class="line"></span><br><span class="line">lock2 = Lock()</span><br><span class="line">lock2.acquire()</span><br><span class="line"></span><br><span class="line">lock3 = Lock()</span><br><span class="line">lock3.acquire()</span><br><span class="line"></span><br><span class="line">t1 = Task1()</span><br><span class="line">t2 = Task2()</span><br><span class="line">t3 = Task3()</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t3.start()</span><br></pre></td></tr></table></figure><p>​        运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-----Task 1-----</span><br><span class="line">-----Task 2-----</span><br><span class="line">-----Task 3-----</span><br><span class="line">-----Task 1-----</span><br><span class="line">-----Task 2-----</span><br><span class="line">-----Task 3-----</span><br></pre></td></tr></table></figure><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>​        反之，异步是指当程序 A 调用程序 B 后，A 不会等到 B 执行完再运行，而是继续向下运行自己的程序</p><p>​        举个例子就是，A 还是叫 B 去吃饭，B 依然说敲完代码再去，这时 A 没有等 B，而是去做自己的事情，等 B 敲完代码，两个再一起去吃饭</p><h4 id="使用进程池实现进程异步"><a href="#使用进程池实现进程异步" class="headerlink" title="使用进程池实现进程异步"></a>使用进程池实现进程异步</h4><p>​        代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'-----Process in Pool----- pid = %d, ppid = %d'</span> % (os.getpid(), os.getppid()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        print(<span class="string">'----%d----'</span> % i)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hahah'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">(args)</span>:</span></span><br><span class="line">    print(<span class="string">'---callback func---- pid = %d'</span> % os.getpid())</span><br><span class="line">    print(<span class="string">'---callback func---- args = %s'</span> % args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pool = Pool(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">pool.apply_async(func=test, callback=test2)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'----mainProcess pid = %d----'</span> % os.getpid())</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-----Process in Pool----- pid = 6027, ppid = 6025</span><br><span class="line">----0----</span><br><span class="line">----1----</span><br><span class="line">----2----</span><br><span class="line">---callback func---- pid = 6025</span><br><span class="line">---callback func---- args = hahah</span><br><span class="line">----mainProcess pid = 6025----</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;多线程产生的问题&quot;&gt;&lt;a href=&quot;#多线程产生的问题&quot; class=&quot;headerlink&quot; title=&quot;多线程产生的问题&quot;&gt;&lt;/a&gt;多线程产生的问题&lt;/h1&gt;&lt;p&gt;​        并发编程由于需要很多线程、进程之间的协作，所以很容易出现问题，下面主要介绍生产者与消费者问题、死锁问题、同步和异步问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的Python" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84Python/"/>
    
  </entry>
  
  <entry>
    <title>Python——多线程以及多线程会产生的一些问题</title>
    <link href="http://yoursite.com/2020/02/04/Python%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%9A%E4%BA%A7%E7%94%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/02/04/Python——多线程以及多线程会产生的一些问题/</id>
    <published>2020-02-04T13:35:59.000Z</published>
    <updated>2020-02-04T14:39:45.183Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-中的多线程"><a href="#Python-中的多线程" class="headerlink" title="Python 中的多线程"></a>Python 中的多线程</h1><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>​        一个进程中包括多个线程，线程是 CPU 调度和分派的基本单位，是进程中执行运算的最小单位，真正在 CPU 上运行的是线程，可以与同一个进程中的其他线程共享进程的全部资源</p><a id="more"></a><h2 id="Python-中实现多线程"><a href="#Python-中实现多线程" class="headerlink" title="Python 中实现多线程"></a>Python 中实现多线程</h2><p>​        Python 中有两种方式床架多线程，一种是调用底层的 <code>thread</code>模块（Python3 中已弃用），另一种是使用<code>threading</code>模块，下面我说的也是使用这个模块实现多线程的方法</p><p>​        从形式上将，多线程的实现和多进程的实现十分类似，<code>threading</code>模块提供了<code>Thread</code>类来创建线程，同<code>Process</code>类一样，我们可以通过直接调用或创建子类来继承这两种方式来创建线程</p><h3 id="使用-Thread-实现多线程"><a href="#使用-Thread-实现多线程" class="headerlink" title="使用 Thread 实现多线程"></a>使用 Thread 实现多线程</h3><p>​        直接调用<code>threading</code>，模块的<code>Thread</code>类来创建线程十分简单，使用<code>threading.Thread([target], [(item1, item2, ...)])</code>方法，<code>target</code>为目标函数名称（如果有目标函数的话），后边为参数元组，用来传递函数参数</p><p>​        线程创建好后，调用<code>Thread.start()</code>方法，就可以运行线程，如果没有目标函数，<code>start()</code>会自动执行<code>Thread</code>类中的<code>run()</code>方法，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saySorry</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">'I am sorry'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(<span class="string">'create %i Thread'</span> % i)</span><br><span class="line">        t = threading.Thread(target=saySorry)</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create 0 Thread</span><br><span class="line">create 1 Thread</span><br><span class="line">create 2 Thread</span><br><span class="line">create 3 Thread</span><br><span class="line">create 4 Thread</span><br><span class="line">I am sorry</span><br><span class="line">I am sorry</span><br><span class="line">I am sorry</span><br><span class="line">I am sorry</span><br><span class="line">I am sorry</span><br></pre></td></tr></table></figure><p>​        上边的程序也证明了，程序在创建了子线程后，不会等待线程执行完毕，而是会继续向下执行，而当主程序全部执行完毕后，却会等待所有子线程执行完毕再结束，这点和进程有些区别</p><h3 id="继承-Thread-实现多线程"><a href="#继承-Thread-实现多线程" class="headerlink" title="继承 Thread 实现多线程"></a>继承 Thread 实现多线程</h3><p>​        另外一种方式是通过创建继承<code>Thread</code>类的子类来实现多线程，这样做的好处就是可以将线程要运行的代码全部放入<code>run</code>函数中，用起来更方便，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            msg = <span class="string">'I am '</span> + self.name + <span class="string">' @ '</span> + str(i)</span><br><span class="line">            print(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t = MyThread()</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I am Thread-1 @ 0</span><br><span class="line">I am Thread-1 @ 1</span><br><span class="line">I am Thread-1 @ 2</span><br></pre></td></tr></table></figure><h2 id="Python-多线程中全局变量和非全局变量的使用问题"><a href="#Python-多线程中全局变量和非全局变量的使用问题" class="headerlink" title="Python 多线程中全局变量和非全局变量的使用问题"></a>Python 多线程中全局变量和非全局变量的使用问题</h2><p>​        开始就说过，线程可以和同一个进程中的其他线程共享进程的全部资源，那么在多线程程序中，各线程对全局变量和非全局变量的使用到底是怎样的呢</p><h3 id="非全局变量"><a href="#非全局变量" class="headerlink" title="非全局变量"></a>非全局变量</h3><p>​        非全局变量在多线程中是不会被共享的，这就像是假设有一个存在局部变量<code>a</code>的函数，当程序调用两次这个函数时，每次调用所产生的局部变量<code>a</code>都是一个新的变量，不会受另一个函数执行的干扰，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    str = threading.current_thread().name</span><br><span class="line">    g_num = <span class="number">100</span></span><br><span class="line">    <span class="keyword">if</span> str == <span class="string">'Thread-1'</span>:</span><br><span class="line">        print(str)</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(str)</span><br><span class="line">        g_num -= <span class="number">1</span></span><br><span class="line">    print(<span class="string">'-----test1----- g_num = %d'</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = Thread(target=test1)</span><br><span class="line">p1.start()</span><br><span class="line"></span><br><span class="line">p2 = Thread(target=test1)</span><br><span class="line">p2.start()</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread-1</span><br><span class="line">-----test1----- g_num = 101</span><br><span class="line">Thread-2</span><br><span class="line">-----test1----- g_num = 99</span><br></pre></td></tr></table></figure><p>​        可以看到，局部变量<code>g_num</code>并不会因为另一个线程中的同名函数而收到影响</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>​        在多线程中，全局变量是可以在各线程间共享的，这也就是说，线程间通信不需要通过管道、内存映射等方法，只需要使用一个全局变量（同一个进程中的共享资源）便可以，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">g_flag = <span class="number">0</span></span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"---test1--- g_num = %d"</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"---test2--- g_num = %d "</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = Thread(target=test1)</span><br><span class="line">p1.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p2 = Thread(target=test2)</span><br><span class="line">p2.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"---g_num= %d ---"</span> % g_num)</span><br></pre></td></tr></table></figure><p>​        运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---g_num= 372639 ---</span><br><span class="line">---test1--- g_num = 1456098</span><br><span class="line">---test2--- g_num = 1596586</span><br></pre></td></tr></table></figure><p>​        到这里，我们可以发现一个问题，正常来讲，<code>g_num</code>最后的值不应给是<code>2000000</code>吗，为什么不是呢？这就是多线程使用全局变量时有可能出现的 bug，请继续阅读！</p><h2 id="Python-多线程中如何防止使用全局变量出现-bug（轮询和互斥锁）"><a href="#Python-多线程中如何防止使用全局变量出现-bug（轮询和互斥锁）" class="headerlink" title="Python 多线程中如何防止使用全局变量出现 bug（轮询和互斥锁）"></a>Python 多线程中如何防止使用全局变量出现 bug（轮询和互斥锁）</h2><p>​        通过刚才在多线程中使用全局变量我们发现，当代码逻辑稍微复杂一些时，在两个线程中同时使用一个全局变量会出现问题，是什么导致了这个问题呢？</p><p>​        从代码中我们可以发现<code>g_num += 1</code>这句代码，实际上是<code>g_num + 1</code>和将其结果赋给<code>g_num</code>两步，正是因为这连续的两次对全局变量的操作造成了这个问题</p><p>​        当一个线程执行到<code>g_num + 1</code>这步后，cpu 有可能会转头去处理另一个线程，另一个线程也运行了<code>g_num + 1</code>，当 cpu 再回头执行第一个线程时，<code>g_num</code> 已经不止被运算过一次了</p><p>​        那么怎么避免这样的情况发生呢，只能是如果存在对全局变量变量值的修改时，我们要优先运行一个线程，当它结束修改后，再允许另一个线程去访问这个局部变量，下面提供两种方式，轮询和互斥锁</p><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>​        顾名思义，轮询的意思就是反复询问，抽象起来理解就是，我们可以设置另一个用来作为目标值的全局变量，两个线程执行的条件根据目标值的不同而不同，当目标值满足一个线程执行时，其他线程就会一直处在一个堵塞的过程，它会一直询问目标值是否符合自己，当上一个线程结束时，这个线程会将目标值修改，这样下一个符合目标值的线程就会运行，示例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">g_flag = <span class="number">0</span></span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">global</span> g_flag</span><br><span class="line">    <span class="keyword">if</span> g_flag == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">            g_num += <span class="number">1</span></span><br><span class="line">        g_flag = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"---test1--- g_num = %d"</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">global</span> g_flag</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> g_flag != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">                g_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"---test2--- g_num = %d "</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = Thread(target=test1)</span><br><span class="line">p1.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p2 = Thread(target=test2)</span><br><span class="line">p2.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"---g_num= %d ---"</span> % g_num)</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---g_num= <span class="number">181893</span> ---</span><br><span class="line">---test1--- g_num = <span class="number">1000000</span></span><br><span class="line">---test2--- g_num = <span class="number">2000000</span></span><br></pre></td></tr></table></figure><p>​        如结果所示，线程之间使用全局变量的 bug 已经解决，但是轮询的方法十分消耗资源，堵塞的线程其实一直都处在一个死循环的状态占用系统资源</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>​        相比而言，互斥锁就是一种比较优化的方法，互斥锁会使用<code>threading</code>模块的<code>Lock</code>类</p><p>​        互斥锁的思想是，当一个线程运行时，它会给它需要的这部分资源上锁，这样同样使用这把锁的其他线程全部都会被堵塞，但被互斥锁所堵塞的线程不会占用系统资源，它们会处在睡眠状态，当运行的线程用完被锁的这部分资源后，它会解锁，这时其他线程就会被唤醒来抢占 cpu 资源，得到资源的线程会再次上锁，达到多线程下全局变量的访问安全，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line">mutex = Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    mutex.acquire()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    mutex.release()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"---test1--- g_num = %d"</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    mutex.acquire()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    mutex.release()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"---test2--- g_num = %d "</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = Thread(target=test1)</span><br><span class="line">p1.start()</span><br><span class="line"></span><br><span class="line">p2 = Thread(target=test2)</span><br><span class="line">p2.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"---g_num= %d ---"</span> % g_num)</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---g_num= <span class="number">200009</span> ---</span><br><span class="line">---test1--- g_num = <span class="number">1000000</span></span><br><span class="line">---test2--- g_num = <span class="number">2000000</span></span><br></pre></td></tr></table></figure><p>​        互斥锁的方法说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建锁</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"><span class="comment"># 上锁，blocking 为 True 表示堵塞</span></span><br><span class="line">mutex.acquire([blocking])</span><br><span class="line"><span class="comment"># 解锁，只要开了锁，那么接下来会让所有因为这个锁而被阻塞的线程抢着上锁</span></span><br><span class="line">mutex.release()</span><br></pre></td></tr></table></figure><p>​        使用互斥锁时要注意，为了提高运算效率，上锁的资源越少，运算的效率越高</p><p>​        另外，线程等待解锁的方式不是通过轮询，二十通过通知，线程会睡眠，等待唤醒的通知，所以互斥锁较轮询来讲更为优化</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-中的多线程&quot;&gt;&lt;a href=&quot;#Python-中的多线程&quot; class=&quot;headerlink&quot; title=&quot;Python 中的多线程&quot;&gt;&lt;/a&gt;Python 中的多线程&lt;/h1&gt;&lt;h2 id=&quot;什么是线程&quot;&gt;&lt;a href=&quot;#什么是线程&quot; class=&quot;headerlink&quot; title=&quot;什么是线程&quot;&gt;&lt;/a&gt;什么是线程&lt;/h2&gt;&lt;p&gt;​        一个进程中包括多个线程，线程是 CPU 调度和分派的基本单位，是进程中执行运算的最小单位，真正在 CPU 上运行的是线程，可以与同一个进程中的其他线程共享进程的全部资源&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的Python" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84Python/"/>
    
  </entry>
  
  <entry>
    <title>Python——多进程、进程池、进程间通信（还有一个复制文件的小程序）</title>
    <link href="http://yoursite.com/2020/02/03/Python%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E6%B1%A0%E3%80%81%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88%E8%BF%98%E6%9C%89%E4%B8%80%E4%B8%AA%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%89/"/>
    <id>http://yoursite.com/2020/02/03/Python——进程、进程池、进程间通信（还有一个复制文件的小程序）/</id>
    <published>2020-02-03T12:00:50.000Z</published>
    <updated>2020-02-03T13:06:42.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-中的进程"><a href="#Python-中的进程" class="headerlink" title="Python 中的进程"></a>Python 中的进程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p>​        当一段代码被运行，或者一个应用程序被运行，就会创建一个进程，以下内容来自百度百科：</p><p>​        <code>“进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体”</code></p><a id="more"></a><h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><p>​        每台计算机，cpu 是计算机的运算核心，多核计算机的意思就是，这台计算机上可以同时运行数量等于其核数的进程</p><p>​        并发执行，即 cpu 核数 &lt; 进程数，这个时候这些进程需要操作系统中的调度算法（时间片轮转算法、优先级调度算法等）来协调</p><p>​        并行执行，即 cpu 核数 &gt; 进程数，这个时候所有的进程都能得到执行，就是并行</p><h2 id="Python-中实现多进程的三种方法"><a href="#Python-中实现多进程的三种方法" class="headerlink" title="Python 中实现多进程的三种方法"></a>Python 中实现多进程的三种方法</h2><p>​        在 Python 中，想要实现多进程有三种方式：使用<code>os</code>模块中的<code>fork()</code>函数、使用<code>multiProcessing</code>模块的<code>Process</code>类、使用<code>multiProcessing</code>模块中的<code>Pool</code>（进程池），下面分别介绍这三种方法及他们之间的比较</p><h3 id="使用-os-fork-实现多进程"><a href="#使用-os-fork-实现多进程" class="headerlink" title="使用 os.fork() 实现多进程"></a>使用 os.fork() 实现多进程</h3><p>​        首先，<code>fork()</code>函数只有在 Linux 或者是 类 Linux 系统中才能使用</p><p>​        当程序运行到这个函数时，会新创建一个进程，新的进程会从这个函数的返回值处开始执行，<code>fork()</code>函数很特殊，在父进程里，<code>fork()</code>的返回值为<code>&gt; 0</code>，并且这个返回值就是主进程的<code>pid</code>，而在子进程中<code>fork()</code>的返回值是<code>== 0</code>的</p><p>​        在有<code>fork()</code>函数的程序中，若主程序在子程序结束之前运行完，那么系统不会等待子进程结束，而是会直接结束主进程，但这并不代表子进程也会被结束，子进程此时已经是一个独立的进程，它会自己运行到结束为止</p><p>​        示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">ret = os.fork()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ret == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">'Dad:%d : %d'</span> % (ret, os.getpid()))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">'Son:%d : %d : %d'</span> % (ret, os.getpid(), os.getppid()))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Son:6081 : 6079 : 5917</span><br><span class="line">Dad:0 : 6081</span><br><span class="line">Son:6081 : 6079 : 5917</span><br><span class="line">Dad:0 : 6081</span><br><span class="line">Son:6081 : 6079 : 5917</span><br><span class="line">Dad:0 : 6081</span><br><span class="line">Son:6081 : 6079 : 5917</span><br><span class="line">Dad:0 : 6081</span><br><span class="line">Son:6081 : 6079 : 5917</span><br><span class="line">Dad:0 : 6081</span><br><span class="line">Son:6081 : 6079 : 5917</span><br><span class="line">Dad:0 : 6081</span><br><span class="line">Son:6081 : 6079 : 5917</span><br><span class="line">Dad:0 : 6081</span><br></pre></td></tr></table></figure><p>​        <code>os</code>模块的其他常用方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取当前进程的 pid（进程号）</span></span><br><span class="line">os.getpid()：</span><br><span class="line"><span class="comment"># 获取当前进程父进程的 pid</span></span><br><span class="line">os.getppid()：</span><br></pre></td></tr></table></figure><h3 id="使用-Process-实现多进程"><a href="#使用-Process-实现多进程" class="headerlink" title="使用 Process 实现多进程"></a>使用 Process 实现多进程</h3><p>​        <code>multiProcessing</code>模块是一个在 Windows 中也可以使用的模块，它包含<code>Process</code>，使用 Process 创建的进程，主进程会等待所有的子进程结束后才结束</p><p>​        并且，<code>Process</code>可以被继承，这样也使得<code>Process</code>可以被更灵活的运用，以及封装功能性代码</p><p>​        使用<code>Process</code>创建进程的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">'----test----'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Process(target=test)</span><br><span class="line"></span><br><span class="line">p.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    print(<span class="string">'----main----'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">----main----</span><br><span class="line">----test----</span><br><span class="line">----main----</span><br><span class="line">----test----</span><br><span class="line">----main----</span><br><span class="line">----test----</span><br><span class="line">----main----</span><br><span class="line">----test----</span><br><span class="line">----main----</span><br></pre></td></tr></table></figure><p>​        创建一个类继承<code>Process</code>来实现多进程的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Process_Class</span><span class="params">(Process)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, interval)</span>:</span></span><br><span class="line">        Process.__init__(self)</span><br><span class="line">        self.interval = interval</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'son(%s) start, dad is (%s)'</span> % (os.getpid(), os.getppid()))</span><br><span class="line">        t_start = time.time()</span><br><span class="line">        time.sleep(self.interval)</span><br><span class="line">        t_stop = time.time()</span><br><span class="line">        print(<span class="string">'(%s) is over, Is %0.2f seconds'</span> % (os.getpid(), t_stop - t_start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t_start = time.time()</span><br><span class="line">    print(<span class="string">'now Process is (%s)'</span> % os.getpid())</span><br><span class="line">    p1 = Process_Class(<span class="number">2</span>)</span><br><span class="line">    p1.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    t_stop = time.time()</span><br><span class="line">    print(<span class="string">'(%s) is over, spend %0.2f seconds'</span> % (os.getpid(), t_stop - t_start))</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">now Process is (6155)</span><br><span class="line">son(6157) start, dad is (6155)</span><br><span class="line">(6157) is over, Is 2.00 seconds</span><br><span class="line">(6155) is over, spend 2.01 seconds</span><br></pre></td></tr></table></figure><p>​        <code>os.Process</code>的其他常用方法及属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常用方法：</span></span><br><span class="line"><span class="comment"># 判断进程实例是否还在执行</span></span><br><span class="line">Process.is_alive()</span><br><span class="line"><span class="comment"># 是否等待进程实例执行结束，或等待多少秒</span></span><br><span class="line">Process.join([timeout])</span><br><span class="line"><span class="comment"># 启动进程实例（创建子进程）</span></span><br><span class="line">Process.start()</span><br><span class="line"><span class="comment"># 如果没有给定 target 参数，这个对象调用 start() 方法时，就将执行对象中的 run() 方法</span></span><br><span class="line">Process.run()</span><br><span class="line"><span class="comment"># 不管任务是否完成，立即终止</span></span><br><span class="line">Process.terminate()</span><br><span class="line"><span class="comment"># 属性：</span></span><br><span class="line"><span class="comment"># 当前进程实例别名，默认为 Process-N，N 为从 1 开始递增的整数</span></span><br><span class="line">name</span><br><span class="line"><span class="comment"># 当前进程实例的 PID 值</span></span><br><span class="line">pid</span><br></pre></td></tr></table></figure><h3 id="使用-Pool（进程池）实现多进程"><a href="#使用-Pool（进程池）实现多进程" class="headerlink" title="使用 Pool（进程池）实现多进程"></a>使用 Pool（进程池）实现多进程</h3><p>​        当需要创建的子进程数量不多时，可以直接利用<code>multiprocessing</code>中的<code>Process</code>动态生成多个进程，但如果时上百甚至上千个目标，手动的去创建进程的工作量巨大，此时可以用到<code>multiprocessing</code>模块提供的<code>Pool</code>方法</p><p>​        初始化<code>Pool</code>时，可以指定一个最大进程数，当有新的请求提交到<code>Pool</code>中时，如果池还没有满，那么就会创建一个新的进程来执行请求；如果进程池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中进程结束，才会请求池中的空闲进程来执行</p><p>​        使用<code>Pool</code>实现多进程的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(<span class="string">'===pid=%d===num=%d'</span> % (os.getpid(), num))</span><br><span class="line">        time.sleep()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pool = Pool(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    print(<span class="string">'---%d---'</span> % i)</span><br><span class="line">    pool.apply_async(worker, (i,))</span><br><span class="line"></span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">---0---</span><br><span class="line">---1---</span><br><span class="line">---2---</span><br><span class="line">---3---</span><br><span class="line">---4---</span><br><span class="line">---5---</span><br><span class="line">---6---</span><br><span class="line">---7---</span><br><span class="line">---8---</span><br><span class="line">---9---</span><br><span class="line">===pid=6223===num=0</span><br><span class="line">===pid=6224===num=1</span><br><span class="line">===pid=6225===num=2</span><br><span class="line">===pid=6225===num=3</span><br><span class="line">===pid=6224===num=4</span><br><span class="line">===pid=6224===num=5</span><br><span class="line">===pid=6225===num=6</span><br><span class="line">===pid=6225===num=9</span><br><span class="line">===pid=6223===num=7</span><br><span class="line">===pid=6224===num=8</span><br></pre></td></tr></table></figure><p>​        <code>Pool</code>的其他常用方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非堵塞式添加进程，第一个参数为需要调用的目标，第二个参数为传递给目标参数的元组</span></span><br><span class="line"><span class="comment"># 如果添加的任务数量超过了进程池中进程的个数的话，不会导致添加不进去，它会等待进程池中的进程完成一个任务后，自动的用刚刚那个进程，完成当前的新任务</span></span><br><span class="line">Pool.apply_async(func, (item, item, ...))</span><br><span class="line"><span class="comment"># 堵塞式添加进程，每个请求添加就开始执行，结束后再添加下一个请求</span></span><br><span class="line">Pool.apply(func, (item, item, ...))</span><br><span class="line"><span class="comment"># 关闭进程池，关闭后进程池不会再接收新的请求</span></span><br><span class="line">Pool.close()</span><br><span class="line"><span class="comment"># 主进程在向进程池创建或添加任务后，默认不会等待进程池中的任务执行完，join 函数就是等待 Pool 中所有的子进程执行完成，必须放在 close() 函数后执行</span></span><br><span class="line">Pool.join()</span><br></pre></td></tr></table></figure><h3 id="三种方法的比较："><a href="#三种方法的比较：" class="headerlink" title="三种方法的比较："></a>三种方法的比较：</h3><p>​        <code>fork()</code>：最底层的方法，其余两种方法创建进程实际上最底层也是通过fork()来创建的，<code>fork()</code>不能直接跨平台使用，只支持 Linux 或类 Linux 平台<br>​        <code>Process</code>：父进程和子进程都用来执行，并且父进程会等待所有子进程结束后再结束<br>​        <code>Pool</code>：<code>Pool</code>方法中，父进程一般只用于等待，真正的任务都在子进程中执行</p><h2 id="进程间通信（使用-Queue）"><a href="#进程间通信（使用-Queue）" class="headerlink" title="进程间通信（使用 Queue）"></a>进程间通信（使用 Queue）</h2><p>​        进程之间是没有任何关联的，可以使用队列来进行进程间的通信，这里使用的是<code>multiProcessing</code>模块的<code>Queue</code>和<code>Manage</code>（用于线程池）</p><p>​        队列是一种先进先出（FIFO）的数据结构，下面是通过不断向同一个队列中输入数据和读取数据实现进程间的通信</p><h3 id="使用-Queue（使用-Process-实现的多进程）"><a href="#使用-Queue（使用-Process-实现的多进程）" class="headerlink" title="使用 Queue（使用 Process 实现的多进程）"></a>使用 Queue（使用 Process 实现的多进程）</h3><p>​        直接放代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]:</span><br><span class="line">        print(<span class="string">'Put %s to queue...'</span> % value)</span><br><span class="line">        q.put(value)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            value = q.get(<span class="literal">True</span>)</span><br><span class="line">            print(<span class="string">'Get %s from queue'</span> % value)</span><br><span class="line">            time.sleep(random.random())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    q = Queue()</span><br><span class="line">    pw = Process(target=write, args=(q,))</span><br><span class="line">    pr = Process(target=read, args=(q,))</span><br><span class="line"></span><br><span class="line">    pw.start()</span><br><span class="line">    pw.join()</span><br><span class="line"></span><br><span class="line">    pr.start()</span><br><span class="line">    pr.join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">' '</span>)</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Put A to queue...</span><br><span class="line">Put B to queue...</span><br><span class="line">Put C to queue...</span><br><span class="line">Get A from queue</span><br><span class="line">Get B from queue</span><br><span class="line">Get C from queue</span><br></pre></td></tr></table></figure><h3 id="使用-Manage（使用-Pool-实现的多进程）"><a href="#使用-Manage（使用-Pool-实现的多进程）" class="headerlink" title="使用 Manage（使用 Pool 实现的多进程）"></a>使用 Manage（使用 Pool 实现的多进程）</h3><p>​        直接放代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">'reader start (%s), Dad is (%s)'</span> % (os.getpid(), os.getppid()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(q.qsize()):</span><br><span class="line">        print(<span class="string">'rader get from queue : %s'</span> % q.get(<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">'writer start (%s), Dad is (%s)'</span> % (os.getpid(), os.getppid()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">'LiMingHui love GH'</span>:</span><br><span class="line">        q.put(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'(%s) start'</span> % os.getpid())</span><br><span class="line">    q = Manager().Queue()</span><br><span class="line">    po = Pool()</span><br><span class="line"></span><br><span class="line">    po.apply(writer, (q,))</span><br><span class="line">    po.apply(reader, (q,))</span><br><span class="line"></span><br><span class="line">    po.close()</span><br><span class="line">    po.join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'(%s) is end'</span> % os.getpid())</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(6306) start</span><br><span class="line">writer start (6313), Dad is (6306)</span><br><span class="line">reader start (6313), Dad is (6306)</span><br><span class="line">rader get from queue : L</span><br><span class="line">rader get from queue : i</span><br><span class="line">rader get from queue : M</span><br><span class="line">rader get from queue : i</span><br><span class="line">rader get from queue : n</span><br><span class="line">rader get from queue : g</span><br><span class="line">rader get from queue : H</span><br><span class="line">rader get from queue : u</span><br><span class="line">rader get from queue : i</span><br><span class="line">rader get from queue :  </span><br><span class="line">rader get from queue : l</span><br><span class="line">rader get from queue : o</span><br><span class="line">rader get from queue : v</span><br><span class="line">rader get from queue : e</span><br><span class="line">rader get from queue :  </span><br><span class="line">rader get from queue : G</span><br><span class="line">rader get from queue : H</span><br><span class="line">(6306) is end</span><br></pre></td></tr></table></figure><h2 id="一个使用多进程实现的复制文件夹的小程序"><a href="#一个使用多进程实现的复制文件夹的小程序" class="headerlink" title="一个使用多进程实现的复制文件夹的小程序"></a>一个使用多进程实现的复制文件夹的小程序</h2><p>​        只需要输入文件夹名字，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyFile</span><span class="params">(name, oldFolderName, newFolderName, queue)</span>:</span></span><br><span class="line">    fr = open(oldFolderName + <span class="string">'/'</span> + name)</span><br><span class="line">    fw = open(newFolderName + <span class="string">'/'</span> + name, <span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line">    content = fr.read()</span><br><span class="line">    fw.write(content)</span><br><span class="line"></span><br><span class="line">    fr.close()</span><br><span class="line">    fw.close()</span><br><span class="line"></span><br><span class="line">    queue.put(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    oldFolderName = input(<span class="string">'Floder-name is:'</span>)</span><br><span class="line">    newFolderName = oldFolderName + <span class="string">'_scopy'</span></span><br><span class="line">    os.mkdir(newFolderName)</span><br><span class="line"></span><br><span class="line">    fileNames = os.listdir(oldFolderName)</span><br><span class="line"></span><br><span class="line">    pool = Pool(<span class="number">5</span>)</span><br><span class="line">    queue = Manager().Queue()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> fileNames:</span><br><span class="line">        pool.apply_async(copyFile, args=(name, oldFolderName, newFolderName, queue))</span><br><span class="line"></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    allNum = len(fileNames)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> num &lt; allNum:</span><br><span class="line">        queue.get()</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        copyRate = num / allNum</span><br><span class="line">        print(<span class="string">'\rcopy : %.2f %%'</span> % (copyRate * <span class="number">100</span>), end=<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'copy end...'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-中的进程&quot;&gt;&lt;a href=&quot;#Python-中的进程&quot; class=&quot;headerlink&quot; title=&quot;Python 中的进程&quot;&gt;&lt;/a&gt;Python 中的进程&lt;/h1&gt;&lt;h2 id=&quot;什么是进程&quot;&gt;&lt;a href=&quot;#什么是进程&quot; class=&quot;headerlink&quot; title=&quot;什么是进程&quot;&gt;&lt;/a&gt;什么是进程&lt;/h2&gt;&lt;p&gt;​        当一段代码被运行，或者一个应用程序被运行，就会创建一个进程，以下内容来自百度百科：&lt;/p&gt;
&lt;p&gt;​        &lt;code&gt;“进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体”&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的Python" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84Python/"/>
    
  </entry>
  
  <entry>
    <title>Python——正则表达式</title>
    <link href="http://yoursite.com/2020/02/01/Python%E2%80%94%E2%80%94%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/02/01/Python——正则表达式/</id>
    <published>2020-02-01T10:56:03.000Z</published>
    <updated>2020-02-01T12:00:10.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-中的正则表达式"><a href="#Python-中的正则表达式" class="headerlink" title="Python 中的正则表达式"></a>Python 中的正则表达式</h1><p>​        正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定的字符串、及这些特定字符的组合，组成一个”规则字符串“，这个规则字符串用来表示对字符串的一种过滤逻辑</p><p>​        字符串是编程时涉及到的最多的一种数据结构，使用正则表达式可以完成判断一个字符串是否为合法电话号、是否是 Email 格式等操作</p><p>​        文章最后符一些常用的正则表达式！</p><a id="more"></a><h2 id="正则表达式通用符号及解释"><a href="#正则表达式通用符号及解释" class="headerlink" title="正则表达式通用符号及解释"></a>正则表达式通用符号及解释</h2><table><thead><tr><th align="center">模式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">.</td><td align="center">匹配任意除 <code>\n</code>外的字符</td></tr><tr><td align="center">\</td><td align="center">转义字符，是一个特殊字符原来的意思</td></tr><tr><td align="center">[…]</td><td align="center">对应位置可以是字符集中的任意字符</td></tr><tr><td align="center">\d</td><td align="center">数字（0~9）</td></tr><tr><td align="center">\D</td><td align="center">非数字</td></tr><tr><td align="center">\s</td><td align="center">空白字符（空格、\t、\r、\n、\f、\v）</td></tr><tr><td align="center">\S</td><td align="center">非空白字符</td></tr><tr><td align="center">\w</td><td align="center">单词字符（A<del>Z、a</del>z、0~9）</td></tr><tr><td align="center">\W</td><td align="center">非单词字符</td></tr><tr><td align="center">*</td><td align="center">匹配前一个字符 0 或 无限次</td></tr><tr><td align="center">+</td><td align="center">匹配前一个字符 1 或 无限次</td></tr><tr><td align="center">？</td><td align="center">匹配前一个字符 0 或 1 次</td></tr><tr><td align="center">{m}</td><td align="center">匹配前一个字符串 m 次</td></tr><tr><td align="center">{m, n}</td><td align="center">匹配前一个字符串 m 至 n 次</td></tr><tr><td align="center">^</td><td align="center">匹配字符串开头</td></tr><tr><td align="center">$</td><td align="center">匹配字符串末尾</td></tr><tr><td align="center">\A</td><td align="center">仅匹配字符串开头</td></tr><tr><td align="center">\Z</td><td align="center">仅匹配字符串末尾</td></tr><tr><td align="center">\b</td><td align="center">匹配 \w 和 \W 之间</td></tr><tr><td align="center">\B</td><td align="center">与上一个相反</td></tr></tbody></table><h2 id="re-模块"><a href="#re-模块" class="headerlink" title="re 模块"></a>re 模块</h2><p>​        python 通过导入 re 模块来使用正则表达式功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure><h3 id="re-compile"><a href="#re-compile" class="headerlink" title="re.compile"></a>re.compile</h3><p>​        compile 函数的返回值是一个 <code>pattern</code>（正则表达式对象），是用来自己定义正则表达式的函数，下面的句子是描述一个以 he 开头，后面接任意字符，并且以 o 结尾的字符串的正则表达式，例如 hello</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r'^(he)+.*o$'</span>)</span><br></pre></td></tr></table></figure><h3 id="re-match"><a href="#re-match" class="headerlink" title="re.match"></a>re.match</h3><p>​        match 函数是根据给定的正则表达式，来判定一个字符串是否符合规则的函数，匹配成功返回一个 match 对象，否则返回 None，下面是以上边 compile 函数返回的正则表达式为基础，对字符串检测的语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result = re.match(pattern, <span class="string">'hello'</span>)</span><br><span class="line">result = re.match(pattern, <span class="string">'hello'</span>, re.l)</span><br><span class="line"><span class="comment"># match 函数的第三个参数 flag 为可选参数，表示标志位，用于控制正则表达式的匹配方式，有如下用法：</span></span><br><span class="line"><span class="comment"># re.l 使匹配对大小写不敏感</span></span><br><span class="line"><span class="comment"># re.L 使匹配对大小写不敏感</span></span><br><span class="line"><span class="comment"># re.M 多行匹配</span></span><br><span class="line"><span class="comment"># re.S 使 . 匹配包括换行在内的左右字符</span></span><br><span class="line"><span class="comment"># re.U 根据 Unicode 字符集解析字符</span></span><br><span class="line"><span class="comment"># re.X 使格式更灵活，以便正则表达式更易于理解</span></span><br></pre></td></tr></table></figure><h3 id="match-group"><a href="#match-group" class="headerlink" title="match.group"></a>match.group</h3><p>​        这个函数是用来获取匹配后的字符串的，它的返回值是一个元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号</span></span><br><span class="line">result.group()</span><br><span class="line"><span class="comment"># 返回一个包含 num 指定小组所对应值的元组</span></span><br><span class="line">result.group(num)</span><br></pre></td></tr></table></figure><h3 id="re-search"><a href="#re-search" class="headerlink" title="re.search"></a>re.search</h3><p>​        search 函数的用法和 match 函数很接近，search 函数会扫描整个字符串并返回第一个成功的匹配，也是一个 match 对象，使用的参数也与 match 函数相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = re.search(pattern1, str)</span><br><span class="line">res = re.search(pattern1, str, re.l)</span><br></pre></td></tr></table></figure><p>​        二者的区别在于，match 函数只匹配字符串的开始，如果开始不符合，就会匹配失败，而 search 函数会匹配整个字符串，直到找到一个匹配</p><h3 id="re-findall"><a href="#re-findall" class="headerlink" title="re.findall"></a>re.findall</h3><p>​        findall 函数会找到字符串中所有符合正则表达式规则的字符串，返回值是一个列表，如果没有匹配，就会返回一个空列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res1 = re.findall(pattern1, str)</span><br></pre></td></tr></table></figure><h3 id="re-finditer"><a href="#re-finditer" class="headerlink" title="re.finditer"></a>re.finditer</h3><p>​        finditer 也是查找所有符合正则表达式规则的字符串，不同的是返回值，finditer 返回的是一个迭代器，用法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> re.finditer(pattern1, str):</span><br><span class="line">    print(item.group())</span><br></pre></td></tr></table></figure><h2 id="小样例"><a href="#小样例" class="headerlink" title="小样例"></a>小样例</h2><p>​        常用的正则表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</span><br><span class="line"></span><br><span class="line">2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?</span><br><span class="line"></span><br><span class="line">3. InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 手机号码：^(<span class="number">13</span>[<span class="number">0</span><span class="number">-9</span>]|<span class="number">14</span>[<span class="number">5</span>|<span class="number">7</span>]|<span class="number">15</span>[<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">5</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9</span>]|<span class="number">18</span>[<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">5</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9</span>])\d&#123;<span class="number">8</span>&#125;$</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 电话号码(<span class="string">"XXX-XXXXXXX"</span>、<span class="string">"XXXX-XXXXXXXX"</span>、<span class="string">"XXX-XXXXXXX"</span>、<span class="string">"XXX-XXXXXXXX"</span>、<span class="string">"XXXXXXX"</span>和<span class="string">"XXXXXXXX)：^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">6. 国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">7. 身份证号(15位、18位数字)：^\d&#123;15&#125;|\d&#123;18&#125;$</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-中的正则表达式&quot;&gt;&lt;a href=&quot;#Python-中的正则表达式&quot; class=&quot;headerlink&quot; title=&quot;Python 中的正则表达式&quot;&gt;&lt;/a&gt;Python 中的正则表达式&lt;/h1&gt;&lt;p&gt;​        正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定的字符串、及这些特定字符的组合，组成一个”规则字符串“，这个规则字符串用来表示对字符串的一种过滤逻辑&lt;/p&gt;
&lt;p&gt;​        字符串是编程时涉及到的最多的一种数据结构，使用正则表达式可以完成判断一个字符串是否为合法电话号、是否是 Email 格式等操作&lt;/p&gt;
&lt;p&gt;​        文章最后符一些常用的正则表达式！&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的Python" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84Python/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JAVA中的流</title>
    <link href="http://yoursite.com/2020/01/31/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JAVA%E4%B8%AD%E7%9A%84%E6%B5%81/"/>
    <id>http://yoursite.com/2020/01/31/JAVA基础——JAVA中的流/</id>
    <published>2020-01-31T11:41:20.000Z</published>
    <updated>2020-01-31T13:33:13.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-JAVA-中的“流”"><a href="#什么是-JAVA-中的“流”" class="headerlink" title="什么是 JAVA 中的“流”"></a>什么是 JAVA 中的“流”</h1><p>​        流是一种抽象出来的概念，当数据在介质中传输，就形成了流，所以流就是用来进行数据的传输的</p><a id="more"></a><h2 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h2><p>​        JAVA 中的流根据其在方向上、处理数据单元上、使用方式上可以分为很多种类</p><p>​        流可以分为输入流和输出流两大类， I（input）和 O（output），即我们常说的 I/O 流，这里的输入和输出是对 JAVA 程序来说的，数据流向 JAVA 程序时，是流入，即输入流，数据从 JAVA 程序中输出时，是流出，即输出流</p><p>​        又可以根据数据单元的不同，分为字节流和字符流，字节流可以处理所有类型的数据，因为它是一个字节一个字节的去读取数据的，而字符流则更适合处理文本数据，他们和输入流及输出流的概念并不冲突</p><h2 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h2><p>​        输入流是指将数据读入到 JAVA 程序中，包括 <code>Reader</code>、<code>InputStream</code> 以及它们的子类，一下以实例说明用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">    br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"F://lmh.txt"</span>));</span><br><span class="line">    String str = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((str = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (br != <span class="keyword">null</span>) &#123;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这个样例是以 <code>FileReader</code> 为基础，使用包装流 <code>Buffered</code> 包装，将一个文件中的数据读入程序中，所有的输入流中，都包含 read 方法用来读入数据，与字节流不同的是，字符流中的 <code>Reader</code> 支持 <code>readLine</code> 方法，可以将一行数据一次性读入，这也证明了字符流更适合操作文本数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"F:/lmh.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file.exists())</span><br><span class="line">        file.createNewFile();</span><br><span class="line">    String path = file.getPath();</span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10000</span>];</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">    <span class="keyword">int</span> fisRead = <span class="number">0</span>;</span><br><span class="line">    fisRead = fis.read(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这个样例是一个典型的，使用字节流向 JAVA 程序读入数据的功能，这里的读入使用 read 函数，read 函数有三种使用方法，一种是无参的读入，<code>read()</code> ，它不会存储读入的数据，只是一味的将读入指针在文件中后移，第二种是有参的读入，<code>read(byte[] bt)</code>，它会存储读入的数据，保存在名为 bt 的 byte 数组中，第三种是 <code>read(byte[] bt, int orr, int len)</code>，它是从输入流读取 len 个字节的数据到 bt 数组，off 为 bt 数组的起始偏移量，这也体现了字符流和字节流在读入数据时的区别</p><h2 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h2><p>​        输出流是将数据从 JAVA 程序输出到控制台或者文件中的流，可以理解为流出 JAVA 程序，包括 <code>Writer</code> 和 <code>OutputStream</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">    BufferedWriter bw = <span class="keyword">null</span>;</span><br><span class="line">    br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"F://lmh.txt"</span>));</span><br><span class="line">    bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"F://lmh01.txt"</span>));</span><br><span class="line">    String str = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((str = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bw.write(str, <span class="number">0</span>, str.length());</span><br><span class="line">        bw.newLine();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (br != <span class="keyword">null</span> || bw != <span class="keyword">null</span>) &#123;</span><br><span class="line">        br.close();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这个样例是一个先使用 <code>Reader</code> 读入数据，再将读入到的数据使用 <code>Writer</code> 写入另一个文件的功能，使用包装流 <code>BufferedWriter</code> 对 <code>FileWriter</code> 进行包装，可以提高运行效率，在使用 <code>Writer</code> 中定义的 write 方法，将其写入到文件中，write 方法有三种，一种是<code>write(char c)</code>，将指定的字符写入，第二种是<code>write(CharSequence cs)</code>，将指定的字符序列写入，第三种是<code>write(CharSequence cs, int off, int len)</code>，写入字符序列 cs 中从 off 位置开始，长度为 len 的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DataInputStream dis = <span class="keyword">null</span>;</span><br><span class="line">    DataOutputStream dos = <span class="keyword">null</span>;</span><br><span class="line">    dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"C://Users//StephenCurry//Desktop//chance//IMA//curry.jpg"</span>));</span><br><span class="line">    dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"C://Users//StephenCurry//Desktop//chance//IMA//curry5.jpg"</span>));</span><br><span class="line">    <span class="keyword">byte</span>[] bt = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024000</span>];</span><br><span class="line">    <span class="keyword">int</span> length = dis.read(bt);</span><br><span class="line">    dos.write(bt, <span class="number">0</span>, length);</span><br><span class="line">    <span class="keyword">if</span> (dis != <span class="keyword">null</span> || dos != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dis.close();</span><br><span class="line">        dos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这个样例就比较有趣了，使用字节流读入一张 jpg 的图片，再使用字节流输出到一个空的 jpg 文件中，实现文件的复制，因为是图片，这里必须使用字节流，使用 write 函数，将读入的字节数据，全部写入到另一个文件中，便完成了文件的复制</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        这里说的只不过是流的简单用法，最重要的是，每种流都有它最擅长的地方，学会在什么情景下使用什么流，才是最关键的</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是-JAVA-中的“流”&quot;&gt;&lt;a href=&quot;#什么是-JAVA-中的“流”&quot; class=&quot;headerlink&quot; title=&quot;什么是 JAVA 中的“流”&quot;&gt;&lt;/a&gt;什么是 JAVA 中的“流”&lt;/h1&gt;&lt;p&gt;​        流是一种抽象出来的概念，当数据在介质中传输，就形成了流，所以流就是用来进行数据的传输的&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
