<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Step By Step</title>
  
  <subtitle>耀出千分光</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-05-06T13:41:40.105Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LiMinghui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>面试题——最长上升子串</title>
    <link href="http://yoursite.com/2020/05/06/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%97%E4%B8%B2/"/>
    <id>http://yoursite.com/2020/05/06/面试题——最长上升字串/</id>
    <published>2020-05-06T13:25:47.000Z</published>
    <updated>2020-05-06T13:41:40.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-1490-最长上升子串"><a href="#AcWing-1490-最长上升子串" class="headerlink" title="AcWing 1490 最长上升子串"></a>AcWing 1490 最长上升子串</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>​    给出一个长度为<code>n</code>的由正整数构成的序列，你需要从中删除一个正整数，很显然你有很多种删除方式，你需要对删除这个正整数以后的序列求其最长上升子串，请问在所有删除方案中，最长的上升子串长度是多少。</p><p>​    这里给出最长上升子串的定义：即对于序列中<strong>连续</strong>的若干个正整数，满足<code>ai+1 &gt; ai</code>，则称这连续的若干个整数构成的子串为上升子串，在所有的上升子串中，长度最长的称为最长上升子串。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入第一行仅包含一个正整数<code>n</code>，表示给出的序列的长度。</p><p>接下来一行有<code>n</code>个正整数，即这个序列，中间用空格隔开。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出仅包含一个正整数，即删除一个数字之后的最长上升子串长度。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 ≤ n ≤ 100000</code><br><code>1 ≤ ai ≤ 100000</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">2 1 3 2 5</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​    这道题我们采用枚举的做法进行求解，对于序列中任意位置 <code>i</code> 的数字，我们都求出它之前按顺序递增最远可以到达的距离<code>f[i]</code>，和它之后按顺序递增最远可以到达的距离<code>g[i]</code>，当我们要拿掉一个数字来得到最长上升子串时，我们只需要先判断拿掉了<code>i</code>后第<code>i</code>个元素两边是否可以拼接上，如果可以，拿掉<code>i</code>的连续上升子串的长度即为<code>f[i - 1] + g[i + 1]</code>，不能拼接的话即为<code>max(f[i - 1], g[i + 1])</code>，最后取所有情况的最大值，即为最长上升子串的长度</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nums[N], f[N], g[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;nums[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) f[i] = f[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> f[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; --i)</span><br><span class="line"><span class="keyword">if</span> (nums[i] &lt; nums[i + <span class="number">1</span>]) g[i] = g[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> g[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i - <span class="number">1</span>] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">int</span> a = f[i - <span class="number">1</span>] + g[i + <span class="number">1</span>];</span><br><span class="line">res = a &gt; res ? a : res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> a = f[i - <span class="number">1</span>] &gt; g[i + <span class="number">1</span>] ? f[i - <span class="number">1</span>] : g[i + <span class="number">1</span>];</span><br><span class="line">res = a &gt; res ? a : res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, res);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> AcWingCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">p1490</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nums[] = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">int</span> f[] = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">int</span> g[] = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        Scanner myInput = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = myInput.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            nums[i] = myInput.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) f[i] = f[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> f[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i + <span class="number">1</span>]) g[i] = g[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> g[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> add = f[i - <span class="number">1</span>] + g[i + <span class="number">1</span>];</span><br><span class="line">                res = res &gt; add ? res : add;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> max = f[i - <span class="number">1</span>] &gt; g[i + <span class="number">1</span>] ? f[i - <span class="number">1</span>] : g[i + <span class="number">1</span>];</span><br><span class="line">                res = res &gt; max ? res : max;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AcWing-1490-最长上升子串&quot;&gt;&lt;a href=&quot;#AcWing-1490-最长上升子串&quot; class=&quot;headerlink&quot; title=&quot;AcWing 1490 最长上升子串&quot;&gt;&lt;/a&gt;AcWing 1490 最长上升子串&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;​    给出一个长度为&lt;code&gt;n&lt;/code&gt;的由正整数构成的序列，你需要从中删除一个正整数，很显然你有很多种删除方式，你需要对删除这个正整数以后的序列求其最长上升子串，请问在所有删除方案中，最长的上升子串长度是多少。&lt;/p&gt;
&lt;p&gt;​    这里给出最长上升子串的定义：即对于序列中&lt;strong&gt;连续&lt;/strong&gt;的若干个正整数，满足&lt;code&gt;ai+1 &amp;gt; ai&lt;/code&gt;，则称这连续的若干个整数构成的子串为上升子串，在所有的上升子串中，长度最长的称为最长上升子串。&lt;/p&gt;
&lt;h4 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title=&quot;输入格式&quot;&gt;&lt;/a&gt;输入格式&lt;/h4&gt;&lt;p&gt;输入第一行仅包含一个正整数&lt;code&gt;n&lt;/code&gt;，表示给出的序列的长度。&lt;/p&gt;
&lt;p&gt;接下来一行有&lt;code&gt;n&lt;/code&gt;个正整数，即这个序列，中间用空格隔开。&lt;/p&gt;
&lt;h4 id=&quot;输出格式&quot;&gt;&lt;a href=&quot;#输出格式&quot; class=&quot;headerlink&quot; title=&quot;输出格式&quot;&gt;&lt;/a&gt;输出格式&lt;/h4&gt;&lt;p&gt;输出仅包含一个正整数，即删除一个数字之后的最长上升子串长度。&lt;/p&gt;
&lt;h4 id=&quot;数据范围&quot;&gt;&lt;a href=&quot;#数据范围&quot; class=&quot;headerlink&quot; title=&quot;数据范围&quot;&gt;&lt;/a&gt;数据范围&lt;/h4&gt;&lt;p&gt;&lt;code&gt;1 ≤ n ≤ 100000&lt;/code&gt;&lt;br&gt;&lt;code&gt;1 ≤ ai ≤ 100000&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;输入样例：&quot;&gt;&lt;a href=&quot;#输入样例：&quot; class=&quot;headerlink&quot; title=&quot;输入样例：&quot;&gt;&lt;/a&gt;输入样例：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 1 3 2 5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;输出样例：&quot;&gt;&lt;a href=&quot;#输出样例：&quot; class=&quot;headerlink&quot; title=&quot;输出样例：&quot;&gt;&lt;/a&gt;输出样例：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Docker——CentOS7安装Docker环境</title>
    <link href="http://yoursite.com/2020/04/09/Docker%E2%80%94%E2%80%94CentOS7%E5%AE%89%E8%A3%85Docker%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2020/04/09/Docker——CentOS7安装Docker环境/</id>
    <published>2020-04-09T13:44:57.000Z</published>
    <updated>2020-04-09T13:45:33.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CentOs-7-安装-Docker"><a href="#CentOs-7-安装-Docker" class="headerlink" title="CentOs 7 安装 Docker"></a>CentOs 7 安装 Docker</h1><p>​    Docker 是一个开源的应用容器引擎，是一个轻量级容器技术，Docker 支持将软件编译成一个镜像，然后在镜像中对各种软件做好配置，将镜像发布出去，使用者们都可以直接使用这个镜像、</p><p>​    运行中的这个镜像被称为容器，容器的启动是非常快速的，下面我们就来介绍如何在 CentOS 7 系统中安装 Docker</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>​    首先，Docker 官方要求 Linux 内核版本必须在<code>3.8</code>以上，建议<code>3.10</code>以上，我们可以使用<code>uname -a</code>指令来查看内核版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[stephen@localhost ~]$ uname -a</span><br><span class="line">Linux localhost.localdomain 3.10.0-693.el7.x86_64 #1 SMP Tue Aug 22 21:09:27 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><p>​    我这里已经是<code>3.10</code>以上的版本了，如果不是的话，我们需要使用<code>sudo yum update</code>指令来更新软件包及内核</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">[stephen@localhost ~]$ sudo yum update</span><br><span class="line"></span><br><span class="line">我们信任您已经从系统管理员那里了解了日常注意事项。</span><br><span class="line">总结起来无外乎这三点：</span><br><span class="line"></span><br><span class="line">    #1) 尊重别人的隐私。</span><br><span class="line">    #2) 输入前要先考虑(后果和风险)。</span><br><span class="line">    #3) 权力越大，责任越大。</span><br><span class="line"></span><br><span class="line">[sudo] stephen 的密码：</span><br><span class="line">已加载插件：fastestmirror, langpacks</span><br><span class="line">base                                                     | 3.6 kB     00:00     </span><br><span class="line">extras                                                   | 2.9 kB     00:00     </span><br><span class="line">updates                                                  | 2.9 kB     00:00     </span><br><span class="line">(1/4): extras/7/x86_64/primary_db                          | 165 kB   00:00     </span><br><span class="line">(2/4): base/7/x86_64/group_gz                              | 165 kB   00:00     </span><br><span class="line">(3/4): base/7/x86_64/primary_db                            | 6.0 MB   00:04     </span><br><span class="line">(4/4): updates/7/x86_64/primary_db                         | 7.6 MB   00:07     </span><br><span class="line">Determining fastest mirrors</span><br><span class="line"> * base: mirrors.tuna.tsinghua.edu.cn</span><br><span class="line"> * extras: mirrors.tuna.tsinghua.edu.cn</span><br><span class="line"> * updates: mirrors.tuna.tsinghua.edu.cn</span><br><span class="line">正在解决依赖关系</span><br><span class="line">--&gt; 正在检查事务</span><br><span class="line">---&gt; 软件包 GeoIP.x86_64.0.1.5.0-11.el7 将被 升级</span><br><span class="line">---&gt; 软件包 GeoIP.x86_64.0.1.5.0-14.el7 将被 更新</span><br><span class="line">--&gt; 正在处理依赖关系 geoipupdate，它被软件包 GeoIP-1.5.0-14.el7.x86_64 需要</span><br><span class="line">---&gt; 软件包 ModemManager.x86_64.0.1.6.0-2.el7 将被 升级</span><br><span class="line">---&gt; 软件包 ModemManager.x86_64.0.1.6.10-3.el7_6 将被 更新</span><br><span class="line">---&gt; 软件包 ModemManager-glib.x86_64.0.1.6.0-2.el7 将被 升级</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">  zenity.x86_64 0:3.28.1-1.el7                                                  </span><br><span class="line">  zlib.x86_64 0:1.2.7-18.el7                                                    </span><br><span class="line"></span><br><span class="line">替代:</span><br><span class="line">  caribou.x86_64 0:0.4.21-1.el7                                                 </span><br><span class="line">  caribou-gtk2-module.x86_64 0:0.4.21-1.el7                                     </span><br><span class="line">  caribou-gtk3-module.x86_64 0:0.4.21-1.el7                                     </span><br><span class="line">  gnome-dictionary-libs.x86_64 0:3.20.0-1.el7                                   </span><br><span class="line">  gnome-tweak-tool.noarch 0:3.22.0-1.el7                                        </span><br><span class="line">  grub2.x86_64 1:2.02-0.64.el7.centos                                           </span><br><span class="line">  grub2-tools.x86_64 1:2.02-0.64.el7.centos                                     </span><br><span class="line">  pyatspi.noarch 0:2.20.3-1.el7                                                 </span><br><span class="line">  python2-caribou.noarch 0:0.4.21-1.el7                                         </span><br><span class="line">  urw-fonts.noarch 0:2.4-16.el7                                                 </span><br><span class="line"></span><br><span class="line">完毕!</span><br></pre></td></tr></table></figure><p>​    接下来我们就可以安装 Docker 了</p><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><p>​    检测过内核版本后，我们就可以使用<code>yum install docker</code>命令安装 Docker，我们需要使用 root 权限来操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[stephen@localhost ~]$ su root</span><br><span class="line">密码：</span><br><span class="line">[root@localhost stephen]# yum install docker</span><br><span class="line">已加载插件：fastestmirror, langpacks</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.tuna.tsinghua.edu.cn</span><br><span class="line"> * extras: mirrors.tuna.tsinghua.edu.cn</span><br><span class="line"> * updates: mirrors.tuna.tsinghua.edu.cn</span><br><span class="line">正在解决依赖关系</span><br><span class="line">--&gt; 正在检查事务</span><br><span class="line">---&gt; 软件包 docker.x86_64.2.1.13.1-109.gitcccb291.el7.centos 将被 安装</span><br><span class="line">--&gt; 正在处理依赖关系 docker-common = 2:1.13.1-109.gitcccb291.el7.centos，它被软件包 2:docker-1.13.1-109.gitcccb291.el7.centos.x86_64 需要</span><br><span class="line">--&gt; 正在处理依赖关系 docker-client = 2:1.13.1-109.gitcccb291.el7.centos，它被软件包 2:docker-1.13.1-109.gitcccb291.el7.centos.x86_64 需要</span><br><span class="line">--&gt; 正在处理依赖关系 subscription-manager-rhsm-certificates，它被软件包 2:docker-1.13.1-109.gitcccb291.el7.centos.x86_64 需要</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">  container-selinux.noarch 2:2.107-3.el7                                        </span><br><span class="line">  container-storage-setup.noarch 0:0.11.0-2.git5eaf76c.el7                      </span><br><span class="line">  containers-common.x86_64 1:0.1.37-3.el7.centos                                </span><br><span class="line">  docker-client.x86_64 2:1.13.1-109.gitcccb291.el7.centos                       </span><br><span class="line">  docker-common.x86_64 2:1.13.1-109.gitcccb291.el7.centos                       </span><br><span class="line">  libyaml.x86_64 0:0.1.4-11.el7_0                                               </span><br><span class="line">  oci-register-machine.x86_64 1:0-6.git2b44233.el7                              </span><br><span class="line">  oci-systemd-hook.x86_64 1:0.2.0-1.git05e6923.el7_6                            </span><br><span class="line">  oci-umount.x86_64 2:2.5-3.el7                                                 </span><br><span class="line">  python-pytoml.noarch 0:0.1.14-1.git7dea353.el7                                </span><br><span class="line">  subscription-manager-rhsm-certificates.x86_64 0:1.24.13-4.el7.centos          </span><br><span class="line"></span><br><span class="line">完毕！</span><br></pre></td></tr></table></figure><h2 id="启动-Docker"><a href="#启动-Docker" class="headerlink" title="启动 Docker"></a>启动 Docker</h2><p>​    上述步骤执行结束并出现<strong>完毕!</strong>字样，说明我们已经在 CentOS 系统上成功安装了 Docker，我们通过执行<code>systemctl start docker</code>启动 Docker 并使用<code>docker -v</code>查看我们 Docker 的版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost stephen]# systemctl start docker</span><br><span class="line">[root@localhost stephen]# docker -v</span><br><span class="line">Docker version 1.13.1, build cccb291/1.13.1</span><br></pre></td></tr></table></figure><p>​    到这里，我们的 Docker 就已经成功的安装在 CentOS 操作系统中了，但是我们没此重启操作系统都要重启 Docker</p><h2 id="设置-Docker-的自启动"><a href="#设置-Docker-的自启动" class="headerlink" title="设置 Docker 的自启动"></a>设置 Docker 的自启动</h2><p>​    通过使用<code>systemctl enable docker</code>可以设置 Docker 的开机自启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost stephen]# systemctl enable docker</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.</span><br></pre></td></tr></table></figure><h2 id="关闭-Docker"><a href="#关闭-Docker" class="headerlink" title="关闭 Docker"></a>关闭 Docker</h2><p>​    使用<code>systemctl stop docker</code>命令可以关闭 Docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost stephen]# systemctl stop docker</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CentOs-7-安装-Docker&quot;&gt;&lt;a href=&quot;#CentOs-7-安装-Docker&quot; class=&quot;headerlink&quot; title=&quot;CentOs 7 安装 Docker&quot;&gt;&lt;/a&gt;CentOs 7 安装 Docker&lt;/h1&gt;&lt;p&gt;​    Docker 是一个开源的应用容器引擎，是一个轻量级容器技术，Docker 支持将软件编译成一个镜像，然后在镜像中对各种软件做好配置，将镜像发布出去，使用者们都可以直接使用这个镜像、&lt;/p&gt;
&lt;p&gt;​    运行中的这个镜像被称为容器，容器的启动是非常快速的，下面我们就来介绍如何在 CentOS 7 系统中安装 Docker&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（面试题9-1）——用两个栈实现队列</title>
    <link href="http://yoursite.com/2020/04/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E9%9D%A2%E8%AF%95%E9%A2%989-1%EF%BC%89%E2%80%94%E2%80%94%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/04/01/剑指Offer（面试题9-1）——用两个栈实现队列/</id>
    <published>2020-04-01T03:16:43.000Z</published>
    <updated>2020-04-01T03:27:43.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指Offer（面试题9-1）"><a href="#剑指Offer（面试题9-1）" class="headerlink" title="剑指Offer（面试题9-1）"></a>剑指Offer（面试题9-1）</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请用栈实现一个队列，支持如下四种操作：</p><ul><li>push(x) – 将元素x插到队尾；</li><li>pop() – 将队首的元素弹出，并返回该元素；</li><li>peek() – 返回队首元素；</li><li>empty() – 返回队列是否为空；</li></ul><p><strong>注意：</strong></p><ul><li>你只能使用栈的标准操作：<code>push to top</code>，<code>peek/pop from top</code>, <code>size</code> 和 <code>is empty</code>；</li><li>如果你选择的编程语言没有栈的标准库，你可以使用<code>list</code>或者<code>deque</code>等模拟栈的操作；</li><li>输入数据保证合法，例如，在队列为空时，不会进行<code>pop</code>或者<code>peek</code>等操作；</li></ul><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyQueue queue = new MyQueue();</span><br><span class="line"></span><br><span class="line">queue.push(1);</span><br><span class="line">queue.push(2);</span><br><span class="line">queue.peek();  // returns 1</span><br><span class="line">queue.pop();   // returns 1</span><br><span class="line">queue.empty(); // returns false</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​        在做这道题之前，我们应该先搞清楚栈和队列的特点：栈是一种后入先出的数据结构，而队列是一种先入先出的数据结构</p><p>​        我们可以通过两个栈来实现一个队列，<code>st1</code>作为接收入队元素的栈，<code>st2</code>作为控制出队元素的栈，当我们要入队时，就将入队元素压入<code>st1</code>中，这时我们发现，如果需要出队，根据队列先入先出的特性，<code>st1</code>的栈底元素需要最先被弹出，这时就要用到第二个栈<code>st2</code>了，我们将<code>st1</code>中所有的元素全部出栈，并依次压入<code>st2</code>，可以发现，因为栈是后入先出的数据结构，<code>st1</code>的栈顶元素会被压入<code>st2</code>的栈底， 而我们要得到的最先入队的元素，也就是原<code>st1</code>的栈底元素，此时在<code>st2</code>的栈顶，我们直接对<code>st2</code>进行出栈操作，就可以得到需要出队的元素了</p><p>​        这里我们需要注意，每次出栈时，我们应该先检测<code>st2</code>中是否还有值，如果有值我们就不需要将<code>st1</code>的元素压入<code>st2</code>中，直接从<code>st2</code>出栈即可，下面是代码，这里我是用 Java 中自带的栈，使用数组模拟栈也是完全可以的</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; st1;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; st2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        st1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        st2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        st1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (st2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st1.empty())</span><br><span class="line">                st2.push(st1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (st2.empty())</span><br><span class="line">            <span class="keyword">while</span> (!st1.empty())</span><br><span class="line">                st2.push(st1.pop());</span><br><span class="line">        <span class="keyword">return</span> st2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (st1.empty() &amp;&amp; st2.empty()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指Offer（面试题9-1）&quot;&gt;&lt;a href=&quot;#剑指Offer（面试题9-1）&quot; class=&quot;headerlink&quot; title=&quot;剑指Offer（面试题9-1）&quot;&gt;&lt;/a&gt;剑指Offer（面试题9-1）&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;请用栈实现一个队列，支持如下四种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;push(x) – 将元素x插到队尾；&lt;/li&gt;
&lt;li&gt;pop() – 将队首的元素弹出，并返回该元素；&lt;/li&gt;
&lt;li&gt;peek() – 返回队首元素；&lt;/li&gt;
&lt;li&gt;empty() – 返回队列是否为空；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你只能使用栈的标准操作：&lt;code&gt;push to top&lt;/code&gt;，&lt;code&gt;peek/pop from top&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt; 和 &lt;code&gt;is empty&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;如果你选择的编程语言没有栈的标准库，你可以使用&lt;code&gt;list&lt;/code&gt;或者&lt;code&gt;deque&lt;/code&gt;等模拟栈的操作；&lt;/li&gt;
&lt;li&gt;输入数据保证合法，例如，在队列为空时，不会进行&lt;code&gt;pop&lt;/code&gt;或者&lt;code&gt;peek&lt;/code&gt;等操作；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;样例&quot;&gt;&lt;a href=&quot;#样例&quot; class=&quot;headerlink&quot; title=&quot;样例&quot;&gt;&lt;/a&gt;样例&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;MyQueue queue = new MyQueue();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue.push(1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue.push(2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue.peek();  // returns 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue.pop();   // returns 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue.empty(); // returns false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（面试题8-1）——二叉树的下一个节点</title>
    <link href="http://yoursite.com/2020/04/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E9%9D%A2%E8%AF%95%E9%A2%988-1%EF%BC%89%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2020/04/01/剑指Offer（面试题8-1）——二叉树的下一个节点/</id>
    <published>2020-04-01T02:59:34.000Z</published>
    <updated>2020-04-01T03:14:35.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指Offer（面试题8-1）"><a href="#剑指Offer（面试题8-1）" class="headerlink" title="剑指Offer（面试题8-1）"></a>剑指Offer（面试题8-1）</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一棵二叉树的其中一个节点，请找出中序遍历序列的下一个节点。</p><p><strong>注意：</strong></p><ul><li>如果给定的节点是中序遍历序列的最后一个，则返回空节点;</li><li>二叉树一定不为空，且给定的节点一定不是空节点；</li></ul><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">假定二叉树是：[2, 1, 3, null, null, null, null]， 给出的是值等于2的节点。</span><br><span class="line"></span><br><span class="line">则应返回值等于3的节点。</span><br><span class="line"></span><br><span class="line">解释：该二叉树的结构如下，2的后继节点是3。</span><br><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​        拿到这道题，我们要先了解什么是二叉树的<strong>中序遍历</strong>，中序遍历指的是以<strong>左、根、右</strong>的顺序对二叉树进行遍历，例如中序遍历为<code>[4, 2, 5, 1, 6, 7, 3]</code>的二叉树，它的形状是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   /   \</span><br><span class="line">  2     3</span><br><span class="line"> / \   / </span><br><span class="line">4   5 6</span><br><span class="line">       \</span><br><span class="line">        7</span><br></pre></td></tr></table></figure><p>​        如果我们想得到某个节点在中序遍历中的下一个节点，我们就需要留意存在多少种情况，以上面的二叉树为例，有一下情况：</p><ul><li>2：节点<code>2</code>是一个存在右子树的节点，如果一个节点存在右子树，那么它在中序遍历中的下一个节点就是<code>node.right.left.left......left</code>，就是它右子树的最深的左子树</li><li>3：节点<code>3</code>不存在右子树，这时我们要关注它是它父亲节点的哪一个孩子，显然<code>3</code>是右孩子，那就说明它的下一节点要么是它父亲的父亲，例如<code>5</code>，要么为<code>null</code></li><li>4：与上一种情况相反，<code>4</code>虽然没有右孩子，但是它是它父亲节点的左孩子，那它的下一节点就是它的父亲节点</li></ul><p>​    到这里，我们可以根据这几种情况，通过代码来找到下一节点</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode father;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">inorderSuccessor</span><span class="params">(TreeNode p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">            <span class="keyword">while</span> (p.left != <span class="keyword">null</span>) p = p.left;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.father != <span class="keyword">null</span> &amp;&amp; p.father.right == p) <span class="keyword">return</span> p.right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.father != <span class="keyword">null</span> &amp;&amp; p.father.left == p) <span class="keyword">return</span> p.father;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p.father;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指Offer（面试题8-1）&quot;&gt;&lt;a href=&quot;#剑指Offer（面试题8-1）&quot; class=&quot;headerlink&quot; title=&quot;剑指Offer（面试题8-1）&quot;&gt;&lt;/a&gt;剑指Offer（面试题8-1）&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一棵二叉树的其中一个节点，请找出中序遍历序列的下一个节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果给定的节点是中序遍历序列的最后一个，则返回空节点;&lt;/li&gt;
&lt;li&gt;二叉树一定不为空，且给定的节点一定不是空节点；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;样例&quot;&gt;&lt;a href=&quot;#样例&quot; class=&quot;headerlink&quot; title=&quot;样例&quot;&gt;&lt;/a&gt;样例&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;假定二叉树是：[2, 1, 3, null, null, null, null]， 给出的是值等于2的节点。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;则应返回值等于3的节点。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：该二叉树的结构如下，2的后继节点是3。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1   3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（面试题6-1）——从尾到头打印链表</title>
    <link href="http://yoursite.com/2020/04/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E9%9D%A2%E8%AF%95%E9%A2%986-1%EF%BC%89%E2%80%94%E2%80%94%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/04/01/剑指Offer（面试题6-1）——从尾到头打印链表/</id>
    <published>2020-04-01T02:45:12.000Z</published>
    <updated>2020-04-01T02:54:23.902Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-面试题（6-1）"><a href="#剑指-Offer-面试题（6-1）" class="headerlink" title="剑指 Offer 面试题（6-1）"></a>剑指 Offer 面试题（6-1）</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>输入一个链表的头结点，按照 <strong>从尾到头</strong> 的顺序返回节点的值。</p><p>返回的结果用数组存储。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[2, 3, 5]</span><br><span class="line">返回：[5, 3, 2]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​        在这里我们不再解释与反转链表思路相同的做法（用三个指针，改变链表结构，想了解可以看这里——<code>https://blog.csdn.net/scfor333/article/details/104968798</code></p><p>​        这里我们提供另一种不改变链表结构的方式，首先我们审读题意，将链表从尾到头输出，也就是类似于后进先出，这可以让我们联想到一种数据结构——栈，我们可以定义一个栈，然后遍历这个链表，从头到尾将每个值入栈，随后再将栈中数据依次出栈，即可达到从头到尾打印链表的目的，我使用了一个数组来模拟栈，下面是代码</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] printListReversingly(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] stack = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100010</span>];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack[idx++] = head.val;</span><br><span class="line">            length++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) res[i] = stack[--idx];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指-Offer-面试题（6-1）&quot;&gt;&lt;a href=&quot;#剑指-Offer-面试题（6-1）&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 面试题（6-1）&quot;&gt;&lt;/a&gt;剑指 Offer 面试题（6-1）&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;输入一个链表的头结点，按照 &lt;strong&gt;从尾到头&lt;/strong&gt; 的顺序返回节点的值。&lt;/p&gt;
&lt;p&gt;返回的结果用数组存储。&lt;/p&gt;
&lt;h4 id=&quot;样例&quot;&gt;&lt;a href=&quot;#样例&quot; class=&quot;headerlink&quot; title=&quot;样例&quot;&gt;&lt;/a&gt;样例&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：[2, 3, 5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;返回：[5, 3, 2]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot——SpringBoot自动配置原理（2.2.5版本）</title>
    <link href="http://yoursite.com/2020/03/29/SpringBoot%E2%80%94%E2%80%94SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%EF%BC%882-2-5%E7%89%88%E6%9C%AC%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/29/SpringBoot——SpringBoot自动配置原理（2-2-5版本）/</id>
    <published>2020-03-29T14:56:59.000Z</published>
    <updated>2020-03-29T15:55:59.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-自动配置原理"><a href="#SpringBoot-自动配置原理" class="headerlink" title="SpringBoot 自动配置原理"></a>SpringBoot 自动配置原理</h1><p>​        作为 SpringBoot 的精髓，自动配置是“习惯优于配置”理念的体现，了解 SpringBoot 自动配置的原理也是学习 SpringBoot 过程中不可绕开的重要内容</p><a id="more"></a><h1 id="从启动类开始说起"><a href="#从启动类开始说起" class="headerlink" title="从启动类开始说起"></a>从启动类开始说起</h1><p>​        要了解自动配置原理，我们首先要找到自动配置的入口，或者说是开关，学习过 SpringBoot 的同学都知道，当我们新建一个 SpringBoot 项目时，而这个空项目一定会包含一个<code>xxxxxxxxAutoconfigApplication.java</code>的类，这是 SpringBoot 的启动类，而这个类一定存在<code>@SpringBootApplication</code>这个注解，那似乎就说明了这个注解和自动配置一定存在某些关系</p><p><img src="https://img-blog.csdnimg.cn/20200329234802441.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>​        我们<code>ctrl + 左键</code>进入这个注解，会发现这是一个复合注解，一个很明显的名字<code>@EnableAutoConfiguration</code>启用自动配置就在其中，那很明显了，这个注解就是我们自动配置的开关所在，我们再进入这个注解</p><p><img src="https://img-blog.csdnimg.cn/20200329234834722.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>​        随后我们会发现，<code>@EnableAutoConfiguration</code>是一个很简单的配置类，我们可以看到它存在一个<code>@Import(AutoConfigurationImportSelector.class)</code>注解，在使用注解配置 Spring 时，我们知道<code>@Import</code>注解是用来定义子配置文件的，并且从它导入的子配置类的名称（自动配置导入选择器）我们可以确定，有关自动配置的核心代码就在这个子配置类中</p><p>​        通过查看这个类我们可以发现，SpringBoot 在<code>selectImports</code>方法中，通过调用同类下的<code>getAutoConfigurationEntry</code>方法来获取所谓的自动配置条目，那我们就继续来看一下这个方法</p><p>​        <img src="https://img-blog.csdnimg.cn/20200329234859267.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>​        这个方法中，我们可以注意到有一个<code>configurations</code>的变量，很明显，这是一个包含了配置的集合，这样我们就又找到了一个<code>getCandidateConfigurations</code>（得到候选的配置）方法，而在这个方法中，SpringBoot 又调用了<code>SpringFactoriesLoader.loadFactoryNames</code>，看起来我们离最最核心的代码越来越近了！点它！</p><p><img src="https://img-blog.csdnimg.cn/20200329234926292.jpg#pic_center" alt></p><p>​        这时我们来到了<code>SpringFactoriesLoader.java</code>，在这个类中我们找到了<code>loadFactoryNames</code>方法，发现它关联了<code>loadSpringFactories</code>方法，这个方法中又一大坨代码</p><p>​        <img src="https://img-blog.csdnimg.cn/20200329234955614.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>​        我们可以看到，在<code>loadSpringFactories</code>这个方法中，SpringBoot 从<code>FACTORIES_RESOURCE_LOCATION</code>中获取值，通过获取到的值，将其中所有的条目都放入配置中，我们看一下这个值是个什么东西</p><p>​        <img src="https://img-blog.csdnimg.cn/20200329235012950.jpg#pic_center" alt></p><p>​        终于一坨一坨的代码变成了一个字符串，原来，SpringBoot 是从具有<code>&quot;META-INF/spring.factories&quot;</code>目录的 jar 包下获取自动配置资源的，我们找到<code>spring-boot-auto-configure</code>这个 jar 包，就会在它的目录下找到一个上述的路径，并找到<code>spring.factories</code>文件</p><p><img src="https://img-blog.csdnimg.cn/20200329235037968.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>​        从上边的图片可以看到，这个文件中包含了很多什么什么自动配置类，原来，SpringBoot 把很多常用配置都已经编写成自动配置类，在启动项目时，SpringBoot 会通过扫描这个配置文件，获取到所有的自动配置类并加载到 Spring 容器中供我们使用</p><p>​        那么自动配置类是如何被使用的呢？今天有点困了，下一篇再更！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SpringBoot-自动配置原理&quot;&gt;&lt;a href=&quot;#SpringBoot-自动配置原理&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot 自动配置原理&quot;&gt;&lt;/a&gt;SpringBoot 自动配置原理&lt;/h1&gt;&lt;p&gt;​        作为 SpringBoot 的精髓，自动配置是“习惯优于配置”理念的体现，了解 SpringBoot 自动配置的原理也是学习 SpringBoot 过程中不可绕开的重要内容&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>算法——简单理解并查集</title>
    <link href="http://yoursite.com/2020/03/27/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2020/03/27/算法——简单理解并查集/</id>
    <published>2020-03-27T02:46:34.000Z</published>
    <updated>2020-03-27T03:13:58.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是并查集"><a href="#什么是并查集" class="headerlink" title="什么是并查集"></a>什么是并查集</h1><p>​        并查集是一种树形的数据结构，，用于处理一些不想交集合的合并即查询问题，我们可以通过并查集以接近<code>O(1)</code>的时间完成两个不相交集合的合并，并且以<code>O(1)</code>的时间判断一个元素属于哪个集合</p><a id="more"></a><h1 id="理解并查集"><a href="#理解并查集" class="headerlink" title="理解并查集"></a>理解并查集</h1><p>​        假设我们有<code>[1, 2, 3, 4, 5]</code>和<code>[6, 7, 8, 9]</code>两个集合，以并查集的思想，我们要以如下方式存储它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1    6</span><br><span class="line">|    |</span><br><span class="line">2    7</span><br><span class="line">|    |</span><br><span class="line">3    8</span><br><span class="line">|    |</span><br><span class="line">4    9</span><br><span class="line">|</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>​        这实际上是两个每个节点只包含一个子节点的树状结构，这样树的根节点即表示集合的名称，而树种所有的叶子节点都存在唯一的一个根节点，我们可以根据这个性质来判断某个元素是否属于一个集合</p><p>​        那么我们如何实现两个集合的合并呢，如果是普通的使用数组存储的集合的话，我们一定需要将其中一个数组整个复制进另一个数组中，这需要很大的时间，并且我们还需要考虑数组的容量问题，如果使用并查集，我们只需要将一个集合的根节点接在另一个集合中，集合完成两个集合的合并，如下图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1————6</span><br><span class="line">|    |</span><br><span class="line">2    7</span><br><span class="line">|    |</span><br><span class="line">3    8</span><br><span class="line">|    |</span><br><span class="line">4    9</span><br><span class="line">|</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>​        这就是使用并查集存储不想交集合以及实现集合合并和查询元素是否属于某集合的方法</p><h1 id="并查集的优化"><a href="#并查集的优化" class="headerlink" title="并查集的优化"></a>并查集的优化</h1><p>​        通过上述的过程，我们发现合并两个集合的操作十分简单，但是判断一个元素是否属于某个集合的过程显得十分复杂，我们需要从一个叶子节点一直回溯到根节点来判断它是否属于一个集合，针对这个问题有一种非常巧妙的优化方式——路径压缩</p><p>​        我们发现，并查集实际上是一颗并不规则的树，它的结构不是固定的，每个节点原则上可以拥有无数个节点，所以如果我们将一个集合中的所有元素都直接和根节点连接，那么通过叶子节点找到根节点的回溯过程就会减少很多时间，如下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   2</span><br><span class="line">   |</span><br><span class="line">5——1——3</span><br><span class="line">   |</span><br><span class="line">   4</span><br></pre></td></tr></table></figure><p>​        这样我们找到一个节点的时间就近乎可以压缩到<code>O(1)</code>了</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>​        在代码中，我们使用<code>find</code>函数来实现找到元素所在的集合及路径压缩，我们使用<code>p[x]</code>来表示<code>x</code>属于哪个集合</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回集合名称并实现路径压缩</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = find(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>, op, &amp;a, &amp;b);</span><br><span class="line">        <span class="comment">// 合并操作</span></span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'M'</span>) p[find(a)] = find(b);</span><br><span class="line">        <span class="comment">// 查询操作</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (find(a) == find(b)) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是并查集&quot;&gt;&lt;a href=&quot;#什么是并查集&quot; class=&quot;headerlink&quot; title=&quot;什么是并查集&quot;&gt;&lt;/a&gt;什么是并查集&lt;/h1&gt;&lt;p&gt;​        并查集是一种树形的数据结构，，用于处理一些不想交集合的合并即查询问题，我们可以通过并查集以接近&lt;code&gt;O(1)&lt;/code&gt;的时间完成两个不相交集合的合并，并且以&lt;code&gt;O(1)&lt;/code&gt;的时间判断一个元素属于哪个集合&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（面试题4-1）——二维数组中的查找</title>
    <link href="http://yoursite.com/2020/03/26/%E5%89%91%E6%8C%87Offer%EF%BC%88%E9%9D%A2%E8%AF%95%E9%A2%984-1%EF%BC%89%E2%80%94%E2%80%94%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2020/03/26/剑指Offer（面试题4-1）——二维数组中的查找/</id>
    <published>2020-03-26T14:12:24.000Z</published>
    <updated>2020-03-26T14:30:23.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer——面试题-4-1"><a href="#剑指-Offer——面试题-4-1" class="headerlink" title="剑指 Offer——面试题 4-1"></a>剑指 Offer——面试题 4-1</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。</p><p>请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入数组：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [1,2,8,9]，</span><br><span class="line">  [2,4,9,12]，</span><br><span class="line">  [4,7,10,13]，</span><br><span class="line">  [6,8,11,15]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">如果输入查找数值为7，则返回true，</span><br><span class="line"></span><br><span class="line">如果输入查找数值为5，则返回false。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​        首先这道题如果使用暴力做法，遍历数组的每个元素来进行查找的话，时间复杂度为<code>O(n²)</code>，这显然不是一个精妙的解法，我们要通过一些特殊的性质，来减少我们需要访问的元素个数</p><p>​        怎么做呢，我们可以看到，整个二维数组是<strong>每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序</strong>，这是一条很重要的性质，也就是说，每一列的第一个元素是整列中最小的，每一行的第一个元素也是整行中最小的，我们可以从这个数组的右上角开始检测，如果右上角的元素大于<code>target</code>，我们就可以直接排除掉最右边的一列，因为<code>target &lt; 右上角元素 &lt; 最右边的一列中其他元素</code>，而如果右上角元素大于<code>target</code>，那么我们就可以删除最上边的一行，因为有<code>target &gt; 右上角元素 &gt; 第一行中的其他元素</code>，根据这个性质，我们可以每次去除二维数组的一行或者是一列，这样可以大大缩减我们查找所消耗的时间，下面看代码</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">array</span>, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="built_in">array</span>[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="built_in">array</span>.size() &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[i][j] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[i][j] &gt; target) --j;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[i][j] &lt; target) ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchArray</span><span class="params">(<span class="keyword">int</span>[][] array, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = array[<span class="number">0</span>].length - <span class="number">1</span>; i &lt; array.length &amp;&amp; j &gt;= <span class="number">0</span>;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i][j] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (array[i][j] &gt; target) --j;</span><br><span class="line">            <span class="keyword">else</span> ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指-Offer——面试题-4-1&quot;&gt;&lt;a href=&quot;#剑指-Offer——面试题-4-1&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer——面试题 4-1&quot;&gt;&lt;/a&gt;剑指 Offer——面试题 4-1&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。&lt;/p&gt;
&lt;p&gt;请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;
&lt;h4 id=&quot;样例&quot;&gt;&lt;a href=&quot;#样例&quot; class=&quot;headerlink&quot; title=&quot;样例&quot;&gt;&lt;/a&gt;样例&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入数组：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [1,2,8,9]，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [2,4,9,12]，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [4,7,10,13]，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [6,8,11,15]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果输入查找数值为7，则返回true，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果输入查找数值为5，则返回false。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>算法——使用单调队列解决滑动窗口问题</title>
    <link href="http://yoursite.com/2020/03/25/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E8%A7%A3%E5%86%B3%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/03/25/算法——使用单调队列解决滑动窗口问题/</id>
    <published>2020-03-25T14:05:31.000Z</published>
    <updated>2020-03-25T14:26:33.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>给定一个大小为<code>n≤106</code>的数组。</p><p>有一个大小为k的滑动窗口，它从数组的最左边移动到最右边。</p><p>您只能在窗口中看到<code>k</code>个数字。</p><p>每次滑动窗口向右移动一个位置。</p><p>以下是一个例子：</p><p>该数组为<code>[1 3 -1 -3 5 3 6 7]</code>，<code>k</code>为<code>3</code>。</p><table><thead><tr><th align="left">窗口位置</th><th align="left">最小值</th><th align="left">最大值</th></tr></thead><tbody><tr><td align="left">[1 3 -1] -3 5 3 6 7</td><td align="left">-1</td><td align="left">3</td></tr><tr><td align="left">1 [3 -1 -3] 5 3 6 7</td><td align="left">-3</td><td align="left">3</td></tr><tr><td align="left">1 3 [-1 -3 5] 3 6 7</td><td align="left">-3</td><td align="left">5</td></tr><tr><td align="left">1 3 -1 [-3 5 3] 6 7</td><td align="left">-3</td><td align="left">5</td></tr><tr><td align="left">1 3 -1 -3 [5 3 6] 7</td><td align="left">3</td><td align="left">6</td></tr><tr><td align="left">1 3 -1 -3 5 [3 6 7]</td><td align="left">3</td><td align="left">7</td></tr></tbody></table><p>您的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包含两行。</p><p>第一行包含两个整数<code>n</code>和<code>k</code>，分别代表数组长度和滑动窗口的长度。</p><p>第二行有<code>n</code>个整数，代表数组的具体数值。</p><p>同行数据之间用空格隔开。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出包含两个。</p><p>第一行输出，从左至右，每个位置滑动窗口中的最小值。</p><p>第二行输出，从左至右，每个位置滑动窗口中的最大值。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1 -3 -3 -3 3 3</span><br><span class="line">3 3 5 5 6 7</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="使用单调队列解决滑动窗口问题"><a href="#使用单调队列解决滑动窗口问题" class="headerlink" title="使用单调队列解决滑动窗口问题"></a>使用单调队列解决滑动窗口问题</h1><p>​        通过读题，我们可以简单描述为有一个长度为<code>n</code>的数组<code>a[n]</code>，给定一个长度为<code>k</code>的“窗口”，<code>a[n]</code>会从头开始依次经过这个窗口，我们需要求的是数组从第<code>k - 1</code>个元素开始，也就是窗口第一次被填满时开始一直到数组结尾，每一次窗口中的值被更新后的最大值和最小值</p><p>​        不难发现，这个窗口是一个从尾部进入，头部出去的模型，那很容易联想到先入先出的数据结构——队列，我们可以假设这个窗口就是一个队列，每次数组元素会从队尾入队，当窗口被填满后，当前的队头元素要出队，我们维护这样一个长度为<code>k</code>的队列，每次求出它的最大值和最小值即可</p><h2 id="使用单调队列优化"><a href="#使用单调队列优化" class="headerlink" title="使用单调队列优化"></a>使用单调队列优化</h2><p>​        然后即便我们想到使用队列进行求解，这个问题还是显得十分复杂，我们怎样简化它呢？答案就是使用单调队列</p><p>​        单调队列即队列中的元素满足单调递增或递减的性质，保证队头队尾元素是队列的最大值或最小值，因为从模拟这道题的过程我们可以得出，假设在求窗口中的最小值时，数组存在<code>[..., 3, -1, 0, ...]</code>这样一段序列，当<code>3</code>入队时，它可能是当前队中最小的元素，但当窗口再一次向后移动时，<code>-1</code>进入队列，此时无论如何<code>3</code>都不会再被当成最小值输出，因为<code>-1</code>一定会在<code>3</code>之后出队，所以这时<code>3</code>就没有必要再存在于队中，我们将它排除，如此循环，使得每次入队的元素一定大于前面的元素，我们就可以得到一个单调递增的队列，此时求最小值，我们直需要返回队头元素即可</p><p>​        以上是最小值，求最大值时我们只需要改变元素入队时的判断条件，即可改变单调队列的单调性，使队头元素变成最大值，下面是代码</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[N], a[N];</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 最小值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) ++hh;</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) --tt;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) ++hh;</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) --tt;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这里我们使用 <code>q[N]</code>来表示滑动窗口中数组元素的下标，这样更方便我们对队列进行操作</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;滑动窗口&quot;&gt;&lt;a href=&quot;#滑动窗口&quot; class=&quot;headerlink&quot; title=&quot;滑动窗口&quot;&gt;&lt;/a&gt;滑动窗口&lt;/h1&gt;&lt;p&gt;给定一个大小为&lt;code&gt;n≤106&lt;/code&gt;的数组。&lt;/p&gt;
&lt;p&gt;有一个大小为k的滑动窗口，它从数组的最左边移动到最右边。&lt;/p&gt;
&lt;p&gt;您只能在窗口中看到&lt;code&gt;k&lt;/code&gt;个数字。&lt;/p&gt;
&lt;p&gt;每次滑动窗口向右移动一个位置。&lt;/p&gt;
&lt;p&gt;以下是一个例子：&lt;/p&gt;
&lt;p&gt;该数组为&lt;code&gt;[1 3 -1 -3 5 3 6 7]&lt;/code&gt;，&lt;code&gt;k&lt;/code&gt;为&lt;code&gt;3&lt;/code&gt;。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;窗口位置&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;最小值&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;最大值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;[1 3 -1] -3 5 3 6 7&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;-1&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;1 [3 -1 -3] 5 3 6 7&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;-3&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;1 3 [-1 -3 5] 3 6 7&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;-3&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;1 3 -1 [-3 5 3] 6 7&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;-3&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;1 3 -1 -3 [5 3 6] 7&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;1 3 -1 -3 5 [3 6 7]&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;您的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。&lt;/p&gt;
&lt;h4 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title=&quot;输入格式&quot;&gt;&lt;/a&gt;输入格式&lt;/h4&gt;&lt;p&gt;输入包含两行。&lt;/p&gt;
&lt;p&gt;第一行包含两个整数&lt;code&gt;n&lt;/code&gt;和&lt;code&gt;k&lt;/code&gt;，分别代表数组长度和滑动窗口的长度。&lt;/p&gt;
&lt;p&gt;第二行有&lt;code&gt;n&lt;/code&gt;个整数，代表数组的具体数值。&lt;/p&gt;
&lt;p&gt;同行数据之间用空格隔开。&lt;/p&gt;
&lt;h4 id=&quot;输出格式&quot;&gt;&lt;a href=&quot;#输出格式&quot; class=&quot;headerlink&quot; title=&quot;输出格式&quot;&gt;&lt;/a&gt;输出格式&lt;/h4&gt;&lt;p&gt;输出包含两个。&lt;/p&gt;
&lt;p&gt;第一行输出，从左至右，每个位置滑动窗口中的最小值。&lt;/p&gt;
&lt;p&gt;第二行输出，从左至右，每个位置滑动窗口中的最大值。&lt;/p&gt;
&lt;h4 id=&quot;输入样例：&quot;&gt;&lt;a href=&quot;#输入样例：&quot; class=&quot;headerlink&quot; title=&quot;输入样例：&quot;&gt;&lt;/a&gt;输入样例：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;8 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 3 -1 -3 5 3 6 7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;输出样例：&quot;&gt;&lt;a href=&quot;#输出样例：&quot; class=&quot;headerlink&quot; title=&quot;输出样例：&quot;&gt;&lt;/a&gt;输出样例：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-1 -3 -3 -3 3 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3 3 5 5 6 7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划（一）——从爬楼梯问题简单理解dp</title>
    <link href="http://yoursite.com/2020/03/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E4%BB%8E%E7%88%AC%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3dp/"/>
    <id>http://yoursite.com/2020/03/24/动态规划（一）——从爬楼梯问题简单理解dp/</id>
    <published>2020-03-24T14:25:29.000Z</published>
    <updated>2020-03-24T15:12:39.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>​        今天来谈一谈我对动态规划的理解，我也是初学者，这里只是通过爬楼梯这道简单的问题，介绍一下动态规划的核心思想和基于这道题的 DP 分析</p><a id="more"></a><h1 id="dp-思想"><a href="#dp-思想" class="headerlink" title="dp 思想"></a>dp 思想</h1><p>​        动态规划（一下简称 dp）是一种将多个阶段的问题分解成一系列单阶段问题，通过总结各阶段之间的关系得到所谓的状态转换方程，从而解决问题</p><p>​        dp 算法不同于二分、快排、双指针等算法，存在一个大致的模板，dp 问题因为问题要求不尽相同，推导 dp 方程的过程也不尽相同，但是我们还是可以总结一个答题流程，这里借鉴<code>AcWing</code>闫学灿老师的<code>闫氏 DP 分析法</code></p><h1 id="通过爬楼梯问题来理解-dp"><a href="#通过爬楼梯问题来理解-dp" class="headerlink" title="通过爬楼梯问题来理解 dp"></a>通过爬楼梯问题来理解 dp</h1><p>​        先看题目</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>​        假设你正在爬楼梯，需要<code>n</code>阶才能到达楼顶，每次你可以爬<code>1</code>或<code>2</code>个台阶，我们有多少种方法可以到达楼顶呢？（<code>n</code>是一个整数）</p><h2 id="dp-思路"><a href="#dp-思路" class="headerlink" title="dp 思路"></a>dp 思路</h2><p>​        dp 问题虽然没有固定的模板，但是我们可以根据经验总结出一个解题的思路，经过总结，我们认为 dp 问题分为<strong>状态表示</strong>和<strong>状态计算</strong>两步，我们依次说明</p><p>​        我们需要根据一个问题，抽象出一个结果的集合，假设为<code>dp[i]</code>，它用来表示<code>到达第 i 个台阶的方法数</code>，这是一个化整为零的过程，我们称为状态表示，<code>dp[i]</code>所表示的含义我们称之为它的属性</p><p>​        随后，我们要通过总结<code>dp[i]</code>的特点或者性质，给<code>dp[i]</code>进行划分，这里划分的依据通常是<strong>寻找最后一个不同点</strong>，那么这个问题的划分点是哪里呢，很明显是<strong>还有<code>1</code>步到第<code>i</code>阶</strong>和<strong>还有<code>2</code>步到第<code>i</code>阶</strong>，这里划分时我们需要注意，我们划分的区间应该包含所有可能存在的情况，并且每个区间都会重复，划分后，我们要通过<code>dp[i]</code>去表示两个区间，很简单，前者是<code>dp[i - 1]</code>，后者是<code>dp[i - 2]</code>，到这里，这道题的思路就很明确了，因为我们已经得到了它的 dp 方程：<code>dp[i] = dp[i - 1] + dp[i - 2]</code>，我们只需要用代码来实现即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> stairs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stairs == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[stairs + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= stairs; ++i) dp[i] = dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[stairs];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h1&gt;&lt;p&gt;​        今天来谈一谈我对动态规划的理解，我也是初学者，这里只是通过爬楼梯这道简单的问题，介绍一下动态规划的核心思想和基于这道题的 DP 分析&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法——前缀和及差分</title>
    <link href="http://yoursite.com/2020/03/23/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%89%8D%E7%BC%80%E5%92%8C%E5%8F%8A%E5%B7%AE%E5%88%86/"/>
    <id>http://yoursite.com/2020/03/23/算法——前缀和及差分/</id>
    <published>2020-03-23T08:11:59.000Z</published>
    <updated>2020-03-23T08:35:01.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前缀和及差分"><a href="#前缀和及差分" class="headerlink" title="前缀和及差分"></a>前缀和及差分</h1><p>​        前缀和与差分是互为逆运算的两种计算方式，前缀和指的是一个数组是另一个数组中前<code>n</code>项元素之和，而差分指的是一个数组的前<code>n</code>项的和是另一个数组</p><p>​        实际上就是，如果数组<code>a</code>是数组<code>b</code>的前缀和，那<code>b</code>就是<code>a</code>的差分</p><a id="more"></a><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><p>​        根据如上的的解释，我们可以理解为，假设有数组<code>a</code>为<code>[1, 2, 3, 4, 5]</code>那么代表它的前缀和数组的数组<code>b</code>就是<code>1, 3, 6, 10, 15</code>，也就是说，<code>a[n] = b[1] + b[2] + ... + b[n - 1] + b[n]</code>，这里我们假设数组是从下标<code>1</code>开始的，这样我们可以减去一步繁琐的判断</p><p>​        通过前缀和，我们可以快速的求出原数组从<code>l</code>到<code>r</code>的区间中元素的和，等于<code>S[l ~ r] = b[r] - b[l - 1]</code>，有如下代码:</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) s[i]= s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><p>​        作为前缀和的逆运算，差分可以理解为有算数组<code>a</code>，它的差分数组<code>b</code>有如下关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a[1] = b[1]</span><br><span class="line">a[2] = b[1] + b[2]</span><br><span class="line">a[3] = b[1] + b[2] + b[3]</span><br><span class="line">...</span><br><span class="line">a[n - 1] = b[1] + b[2] + b[3] + ... + b[n - 2] + b[n - 1]</span><br><span class="line">a[n] = b[1] + b[2] + b[3] + ... + b[n - 2] + b[n - 1] + b[n]</span><br></pre></td></tr></table></figure><p>​        由此可见，如果<code>b</code>是<code>a</code>的差分数组，那<code>a</code>就是<code>b</code>的前缀和数组，通过差分，我们可以快速的实现对一个区间内的所有元素的同增同减操作</p><p>​        假设我们要让<code>a[2]</code>到<code>a[6]</code>的元素全部<code>+1</code>，我们只需要让<code>b[2] += 1</code>，<code>b[7] -= 1</code>即可，代码如下</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) b[i] = a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;c);</span><br><span class="line">        b[l] += c;</span><br><span class="line">        b[r + <span class="number">1</span>] -= c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = a[i - <span class="number">1</span>] + b[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前缀和及差分&quot;&gt;&lt;a href=&quot;#前缀和及差分&quot; class=&quot;headerlink&quot; title=&quot;前缀和及差分&quot;&gt;&lt;/a&gt;前缀和及差分&lt;/h1&gt;&lt;p&gt;​        前缀和与差分是互为逆运算的两种计算方式，前缀和指的是一个数组是另一个数组中前&lt;code&gt;n&lt;/code&gt;项元素之和，而差分指的是一个数组的前&lt;code&gt;n&lt;/code&gt;项的和是另一个数组&lt;/p&gt;
&lt;p&gt;​        实际上就是，如果数组&lt;code&gt;a&lt;/code&gt;是数组&lt;code&gt;b&lt;/code&gt;的前缀和，那&lt;code&gt;b&lt;/code&gt;就是&lt;code&gt;a&lt;/code&gt;的差分&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring框架——@Autowired注解用法详解</title>
    <link href="http://yoursite.com/2020/03/22/Spring%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94Autowired%E6%B3%A8%E8%A7%A3%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/03/22/Spring框架——Autowired注解用法详解/</id>
    <published>2020-03-22T00:38:03.000Z</published>
    <updated>2020-03-22T03:02:35.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-框架中的-Autowired-注解"><a href="#Spring-框架中的-Autowired-注解" class="headerlink" title="Spring 框架中的 @Autowired 注解"></a>Spring 框架中的 @Autowired 注解</h1><p>​        在使用注解进行 Spring 项目的开发时，我们经常会用到<code>Autowired</code>注解，它可以对类成员变量、方法及构造函数进行标注，完成<code>IOC</code>容器自动装配的工作</p><a id="more"></a><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>​        首先我们根据<code>service</code>调取<code>dao</code>层方法的概念，构建<code>dao</code>层和<code>service</code>层</p><p>​        <code>dao</code>层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDaoImpl</span> <span class="keyword">implements</span> <span class="title">PersonDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"select"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        <code>service</code>层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PersonDao personDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        personDao.select();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PersonService personService = ioc.getBean(<span class="string">"personService"</span>, PersonService.class);</span><br><span class="line">    personService.select();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        以上代码运行结果就是控制台输出了 select 字符串，下面我们看看<code>@Autowired</code>注解是如何工作的</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>​        我们在<code>private PersonDao personDao</code>上添加<code>@Autowired</code>相当于在<code>&lt;bean id=&quot;personService&quot;&gt;</code>内配置了<code>&lt;property name=&quot;personDao&quot; ref=&quot;personDaoImpl&quot;/&gt;</code>，这个我们可以通过在<code>@Autowired</code>注解下添加一个<code>@Qualifier(&quot;personDaoImpl&quot;)</code>注解来证明</p><p>​        添加后，两种方式运行的代码结果是一样的，这就说明<code>PersonDaoImpl</code>被注入到 <code>IOC</code>容器中时的<code>bean id</code>是<code>personDaoImpl</code>，那为什么我们我们不使用<code>@Qualifier</code>注解同样能实现注入呢？</p><p>​        原因是<code>@Autowired</code>注解的匹配机制是<code>ByType</code>，它会首先匹配类型，并且会匹配子类型的父类或者接口，这是为什么每加<code>@Qualifier</code>注解时可以注入成功，而加上<code>@Qualifier</code>注解后，<code>@Autowired</code>的匹配模式变成了<code>ByName</code>，所以这时必须匹配<code>bean id</code>也就是<code>personDaoImpl</code>才可以注入成功！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring-框架中的-Autowired-注解&quot;&gt;&lt;a href=&quot;#Spring-框架中的-Autowired-注解&quot; class=&quot;headerlink&quot; title=&quot;Spring 框架中的 @Autowired 注解&quot;&gt;&lt;/a&gt;Spring 框架中的 @Autowired 注解&lt;/h1&gt;&lt;p&gt;​        在使用注解进行 Spring 项目的开发时，我们经常会用到&lt;code&gt;Autowired&lt;/code&gt;注解，它可以对类成员变量、方法及构造函数进行标注，完成&lt;code&gt;IOC&lt;/code&gt;容器自动装配的工作&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring 框架" scheme="http://yoursite.com/tags/Spring-%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（面试题3-2）——不修改数组找出重复的数字</title>
    <link href="http://yoursite.com/2020/03/20/%E5%89%91%E6%8C%87Offer%EF%BC%88%E9%9D%A2%E8%AF%95%E9%A2%983-2%EF%BC%89%E2%80%94%E2%80%94%E4%B8%8D%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84%E6%89%BE%E5%87%BA%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/03/20/剑指Offer（面试题3-2）——不修改数组找出重复的数字/</id>
    <published>2020-03-20T14:43:56.000Z</published>
    <updated>2020-03-20T15:07:03.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer——面试题-3-2"><a href="#剑指-Offer——面试题-3-2" class="headerlink" title="剑指 Offer——面试题 3-2"></a>剑指 Offer——面试题 3-2</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>不修改数组找出重复的数字</p><p>在一个长度位<code>n + 1</code>的数组里的所有数字都在<code>1 ~ n</code>的范围内，所以数组中至少有一个数字是重复的，请找出数组中任意一个重复的数字，但不能修改输入的数组</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2, 3, 5, 4, 3, 2, 6, 7]</span><br></pre></td></tr></table></figure><h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 或 3</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​        这道题比较特殊的点就是不允许改变输入数组，如果不改变输入数组的话，我们就不能对数组进行排序，也不能交换数组元素，所以面试题 3-2 中的方法就不能用了</p><p>​        那我们如何找到数组中的重复元素呢？可以考虑二分的思想</p><p>​        因为数组是从<code>1 ~ n</code>的长度为<code>n + 1</code>的数组，所以数组中一定存在重复元素，我们先取数组的值的中点<code>mind = 1 + n &gt;&gt; 1</code>，随后我们统计数组中<code>&lt;= mid</code>的元素个数，如果数量大于<code>mid - l（左边界）</code>，说明重复元素在左边，否则说明重复元素在右边，不断的二分，我们最后就会找到这个重复出现的元素！代码如下：</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">duplicateInArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= mid &amp;&amp; num &gt;= l) ++s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s &gt; (mid - l + <span class="number">1</span>)) r = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指-Offer——面试题-3-2&quot;&gt;&lt;a href=&quot;#剑指-Offer——面试题-3-2&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer——面试题 3-2&quot;&gt;&lt;/a&gt;剑指 Offer——面试题 3-2&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;不修改数组找出重复的数字&lt;/p&gt;
&lt;p&gt;在一个长度位&lt;code&gt;n + 1&lt;/code&gt;的数组里的所有数字都在&lt;code&gt;1 ~ n&lt;/code&gt;的范围内，所以数组中至少有一个数字是重复的，请找出数组中任意一个重复的数字，但不能修改输入的数组&lt;/p&gt;
&lt;h4 id=&quot;输入样例&quot;&gt;&lt;a href=&quot;#输入样例&quot; class=&quot;headerlink&quot; title=&quot;输入样例&quot;&gt;&lt;/a&gt;输入样例&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[2, 3, 5, 4, 3, 2, 6, 7]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;输出样例&quot;&gt;&lt;a href=&quot;#输出样例&quot; class=&quot;headerlink&quot; title=&quot;输出样例&quot;&gt;&lt;/a&gt;输出样例&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;2 或 3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试题——移掉k位数字</title>
    <link href="http://yoursite.com/2020/03/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E2%80%94%E7%A7%BB%E6%8E%89k%E4%BD%8D%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/03/19/面试题——移掉k位数字/</id>
    <published>2020-03-19T07:31:46.000Z</published>
    <updated>2020-03-19T08:27:48.109Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-1453-移掉-k-位数字"><a href="#AcWing-1453-移掉-k-位数字" class="headerlink" title="AcWing 1453 移掉 k 位数字"></a>AcWing 1453 移掉 k 位数字</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个以字符串表示的非负整数<code>num</code>，移除这个数中的<code>k</code>位数字，使得剩下的数字最小</p><p><strong>注意：</strong></p><ul><li>空字符串被视为<code>0</code></li><li>如果结果中包含前导零，则需要将前导零删除，最后删除的前导零不用包含在移除的<code>k</code>个数字中</li></ul><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入一个字符串，用来表示非负整数<code>num</code></p><p>第二行输入一个整数，表示<code>k</code></p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个字符串，表示移除<code>k</code>位数字后所能得到的最小数字</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>0≤k≤</code>字符串长度<code>≤100000</code><br><code>num</code>中不包含任何前导<code>0</code></p><h4 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1432219</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1219</span><br></pre></td></tr></table></figure><h4 id="样例1解释"><a href="#样例1解释" class="headerlink" title="样例1解释"></a>样例1解释</h4><p>移除掉三个数字<code>4,3,2</code>可形成一个新的最小的数字<code>1219</code></p><h4 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10200</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">200</span><br></pre></td></tr></table></figure><h4 id="样例2解释："><a href="#样例2解释：" class="headerlink" title="样例2解释："></a>样例2解释：</h4><p>移掉首位的<code>1</code>剩下的数字为<code>200</code>，注意<code>输出不能有任何前导零</code></p><h4 id="输入样例3："><a href="#输入样例3：" class="headerlink" title="输入样例3："></a>输入样例3：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="输出样例3："><a href="#输出样例3：" class="headerlink" title="输出样例3："></a>输出样例3：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h4 id="样例3解释"><a href="#样例3解释" class="headerlink" title="样例3解释"></a>样例3解释</h4><p>从原数字移除所有的数字，剩余为空就是<code>0</code></p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​        这道题怎么解呢，首先我们考虑一种特殊情况，当原字符串中的每一位都是按字典序排列时，越小的数字排的越靠前，所以要是想移除<code>k</code>位得到最小数字，只需要移除最后<code>k</code>位即可</p><p>​        由此我们可以得到一个思路：将原字符串排序，移除后<code>k</code>位来获得最小数字，但是这里我们不考虑这种方法，接下来介绍另一种方法</p><p>​        有序的情况我们分析了，那无序的呢？假设字符串是<code>1, 5, 3, 2, 1</code>，我们要想移除<code>2</code>位来获得最小数字呢？</p><p>​        我们先正常遍历字符串，当遇到<code>nums[i] &gt; nums[i + 1]</code>的情况时，为了能使最后得到的数字最小，我们一定要移除排名更前且值更大的数字，因为从数字的角度看，越大且排名越前的数字对整个数字的大小影响越大，比如<code>190</code>一定大于<code>109</code></p><p>​        还有一个问题就是前导零的问题，我们当得到了最后的结果之后，从头遍历一下数组，用<code>i</code>记住前面有几个<code>0</code>最后返回时从<code>i</code>开始输出就好啦，下面是代码：</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> nums;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; nums &gt;&gt; k;</span><br><span class="line"><span class="built_in">string</span> res = <span class="string">"0"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (k &amp;&amp; nums[i] &lt; res.back()) &#123;</span><br><span class="line">res.pop_back();</span><br><span class="line">k--;</span><br><span class="line">&#125;</span><br><span class="line">res += nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (k) &#123;</span><br><span class="line">res.pop_back();</span><br><span class="line">k--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span> (res[i] == <span class="string">'0'</span>)</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (i == res.size())</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res.substr(i) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AcWing-1453-移掉-k-位数字&quot;&gt;&lt;a href=&quot;#AcWing-1453-移掉-k-位数字&quot; class=&quot;headerlink&quot; title=&quot;AcWing 1453 移掉 k 位数字&quot;&gt;&lt;/a&gt;AcWing 1453 移掉 k 位数字&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个以字符串表示的非负整数&lt;code&gt;num&lt;/code&gt;，移除这个数中的&lt;code&gt;k&lt;/code&gt;位数字，使得剩下的数字最小&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空字符串被视为&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果结果中包含前导零，则需要将前导零删除，最后删除的前导零不用包含在移除的&lt;code&gt;k&lt;/code&gt;个数字中&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title=&quot;输入格式&quot;&gt;&lt;/a&gt;输入格式&lt;/h4&gt;&lt;p&gt;第一行输入一个字符串，用来表示非负整数&lt;code&gt;num&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第二行输入一个整数，表示&lt;code&gt;k&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;输出格式&quot;&gt;&lt;a href=&quot;#输出格式&quot; class=&quot;headerlink&quot; title=&quot;输出格式&quot;&gt;&lt;/a&gt;输出格式&lt;/h4&gt;&lt;p&gt;输出一个字符串，表示移除&lt;code&gt;k&lt;/code&gt;位数字后所能得到的最小数字&lt;/p&gt;
&lt;h4 id=&quot;数据范围&quot;&gt;&lt;a href=&quot;#数据范围&quot; class=&quot;headerlink&quot; title=&quot;数据范围&quot;&gt;&lt;/a&gt;数据范围&lt;/h4&gt;&lt;p&gt;&lt;code&gt;0≤k≤&lt;/code&gt;字符串长度&lt;code&gt;≤100000&lt;/code&gt;&lt;br&gt;&lt;code&gt;num&lt;/code&gt;中不包含任何前导&lt;code&gt;0&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;输入样例1：&quot;&gt;&lt;a href=&quot;#输入样例1：&quot; class=&quot;headerlink&quot; title=&quot;输入样例1：&quot;&gt;&lt;/a&gt;输入样例1：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1432219&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;输出样例1：&quot;&gt;&lt;a href=&quot;#输出样例1：&quot; class=&quot;headerlink&quot; title=&quot;输出样例1：&quot;&gt;&lt;/a&gt;输出样例1：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1219&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;样例1解释&quot;&gt;&lt;a href=&quot;#样例1解释&quot; class=&quot;headerlink&quot; title=&quot;样例1解释&quot;&gt;&lt;/a&gt;样例1解释&lt;/h4&gt;&lt;p&gt;移除掉三个数字&lt;code&gt;4,3,2&lt;/code&gt;可形成一个新的最小的数字&lt;code&gt;1219&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;输入样例2：&quot;&gt;&lt;a href=&quot;#输入样例2：&quot; class=&quot;headerlink&quot; title=&quot;输入样例2：&quot;&gt;&lt;/a&gt;输入样例2：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;10200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;输出样例2：&quot;&gt;&lt;a href=&quot;#输出样例2：&quot; class=&quot;headerlink&quot; title=&quot;输出样例2：&quot;&gt;&lt;/a&gt;输出样例2：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;200&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;样例2解释：&quot;&gt;&lt;a href=&quot;#样例2解释：&quot; class=&quot;headerlink&quot; title=&quot;样例2解释：&quot;&gt;&lt;/a&gt;样例2解释：&lt;/h4&gt;&lt;p&gt;移掉首位的&lt;code&gt;1&lt;/code&gt;剩下的数字为&lt;code&gt;200&lt;/code&gt;，注意&lt;code&gt;输出不能有任何前导零&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;输入样例3：&quot;&gt;&lt;a href=&quot;#输入样例3：&quot; class=&quot;headerlink&quot; title=&quot;输入样例3：&quot;&gt;&lt;/a&gt;输入样例3：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;输出样例3：&quot;&gt;&lt;a href=&quot;#输出样例3：&quot; class=&quot;headerlink&quot; title=&quot;输出样例3：&quot;&gt;&lt;/a&gt;输出样例3：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;样例3解释&quot;&gt;&lt;a href=&quot;#样例3解释&quot; class=&quot;headerlink&quot; title=&quot;样例3解释&quot;&gt;&lt;/a&gt;样例3解释&lt;/h4&gt;&lt;p&gt;从原数字移除所有的数字，剩余为空就是&lt;code&gt;0&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试题——反转链表</title>
    <link href="http://yoursite.com/2020/03/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/03/19/面试题——反转链表/</id>
    <published>2020-03-19T07:11:19.000Z</published>
    <updated>2020-03-19T08:29:06.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-35-反转链表"><a href="#AcWing-35-反转链表" class="headerlink" title="AcWing 35 反转链表"></a>AcWing 35 反转链表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点</p><p><strong>思考题：</strong></p><ul><li>请同时实现迭代版本和递归版本</li></ul><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line"></span><br><span class="line">输出:5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="迭代版本"><a href="#迭代版本" class="headerlink" title="迭代版本"></a>迭代版本</h3><p>​        这道题使用迭代的思想很容易思考，我们只需要准备三个指针，分别是上一个节点<code>prev</code>、当前节点<code>curr</code>和<code>curr</code>的下一个节点<code>node</code></p><p>​        通过遍历整个链表，没到一个节点，我们先保存<code>curr.next</code>给<code>node</code>，再将<code>curr.next</code>赋给<code>prev</code>，也就改变了<code>curr</code>的指向，随后我们把<code>curr</code>和<code>prev</code>都后移一位即可（在原来的顺序上，因为我们已经保留了<code>node</code>），当<code>curr == null</code>时，说明链表已经到结尾了，我们返回<code>prev</code>即可</p><h3 id="递归版本"><a href="#递归版本" class="headerlink" title="递归版本"></a>递归版本</h3><p>​        递归版本如何思考呢，我们只需要思考一种情况，由于是递归实现，当递归到<code>head</code>节点时，我们需要递归函数返回的结果是一个从<code>head.next</code>开始已经被反转的链表，所以我们只需要将<code>head</code>接到链表的结尾，并将<code>head.next</code>指空即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c-迭代"><a href="#c-迭代" class="headerlink" title="c++ 迭代"></a>c++ 迭代</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">ListNode *prev = <span class="literal">NULL</span>, *cur = head;</span><br><span class="line"><span class="keyword">while</span> (cur) &#123;</span><br><span class="line"><span class="keyword">auto</span> node = cur-&gt;next;</span><br><span class="line">cur-&gt;next = prev;</span><br><span class="line">prev = cur;</span><br><span class="line">cur = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="c-递归"><a href="#c-递归" class="headerlink" title="c++ 递归"></a>c++ 递归</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"><span class="keyword">auto</span> tail = reverseList(head-&gt;next);</span><br><span class="line">head-&gt;next-&gt;next = head;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="java-迭代"><a href="#java-迭代" class="headerlink" title="java 迭代"></a>java 迭代</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode node = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java-递归"><a href="#java-递归" class="headerlink" title="java 递归"></a>java 递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode tail = head.next;</span><br><span class="line">        ListNode node = reverseList(head.next);</span><br><span class="line">        tail.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AcWing-35-反转链表&quot;&gt;&lt;a href=&quot;#AcWing-35-反转链表&quot; class=&quot;headerlink&quot; title=&quot;AcWing 35 反转链表&quot;&gt;&lt;/a&gt;AcWing 35 反转链表&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思考题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请同时实现迭代版本和递归版本&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;样例&quot;&gt;&lt;a href=&quot;#样例&quot; class=&quot;headerlink&quot; title=&quot;样例&quot;&gt;&lt;/a&gt;样例&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试题——链表中环的入口节点</title>
    <link href="http://yoursite.com/2020/03/18/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E2%80%94%E9%93%BE%E8%A1%A8%E4%B8%AD%E7%8E%AF%E7%9A%84%E5%85%A5%E5%8F%A3%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2020/03/18/面试题——链表中环的入口节点/</id>
    <published>2020-03-18T10:51:02.000Z</published>
    <updated>2020-03-19T08:29:01.928Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-34-链表中环的入口节点"><a href="#AcWing-34-链表中环的入口节点" class="headerlink" title="AcWing 34 链表中环的入口节点"></a>AcWing 34 链表中环的入口节点</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个链表，若其中包含环，则输出环的入口节点</p><p>若其中不包含环，则输出<code>null</code></p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><p><img src="https://img-blog.csdnimg.cn/2020031819140188.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">给定如上所示的链表：</span><br><span class="line">[1, 2, 3, 4, 5, 6]</span><br><span class="line">2</span><br><span class="line">注意，这里的2表示编号是2的节点，节点编号从0开始。所以编号是2的节点就是val等于3的节点。</span><br><span class="line"></span><br><span class="line">则输出环的入口节点3.</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​        这道题解法很巧妙，有一股数学的气息，首先我们回忆一下怎么确定一个链表中是否存在环</p><p>​        我们是使用快慢指针的方式来确定链表中是否存在环的，两个指针<code>one</code>和<code>two</code>都从链表的<code>head</code>出发，<code>one</code>每次走一个节点，<code>two</code>每次走两个节点，如果链表存在环的情况下，两个指针一定会在环中的某个位置相遇，否则如果<code>two</code>走到了链表结尾，说明链表没有环</p><p>​        那我们如何确定链表中环的入口节点呢？请看这张图</p><p><img src="https://img-blog.csdnimg.cn/20200318191445974.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70" alt></p><p>​        首先，我们假设入口节点<code>b</code>距离<code>head</code>节点<code>a</code>的距离为<code>x</code>，两个指针相遇的点<code>c</code>距离<code>b</code>点的长度是<code>y</code>，那么，<code>one</code>指针走到<code>b</code>需要<code>x</code>步，而此时<code>two</code>指针已经走了<code>2x</code>步，正在环中某处（假设链表存在环），而当<code>one</code>再走<code>y</code>步就会到达两个指针相遇的<code>c</code>点，再次期间，<code>two</code>同样会走<code>2y</code>步，所以，在<code>one</code>到达<code>b</code>点时，<code>two</code>实际距离<code>b</code>点<code>y</code>步，也就是说，这个环的长度为<code>x + y</code>，所以我们可以得到，当<code>two</code>在<code>c</code>点时，它距离<code>b</code>点差<code>x</code>步</p><p>​        通过这个结论，我们可以在两个指针相遇时，让<code>one</code>指回头节点，此时<code>one</code>距离<code>b</code>点差<code>x</code>步，<code>two</code>距离<code>b</code>点也为<code>x</code>步，从这个时候开始，我们让两个指针每次走一个单位，当两个指针再次相遇时，这个点就是<code>b</code>点，代码如下：</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">entryNodeOfLoop</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">auto</span> i = head, j = head;</span><br><span class="line"><span class="keyword">while</span> (i &amp;&amp; j) &#123;</span><br><span class="line">i = i-&gt;next;</span><br><span class="line">j = j-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (j) &#123;</span><br><span class="line">j = j-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (!j) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">i = head;</span><br><span class="line"><span class="keyword">while</span> (i != j) &#123;</span><br><span class="line">i = i-&gt;next;</span><br><span class="line">j = j-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AcWing-34-链表中环的入口节点&quot;&gt;&lt;a href=&quot;#AcWing-34-链表中环的入口节点&quot; class=&quot;headerlink&quot; title=&quot;AcWing 34 链表中环的入口节点&quot;&gt;&lt;/a&gt;AcWing 34 链表中环的入口节点&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个链表，若其中包含环，则输出环的入口节点&lt;/p&gt;
&lt;p&gt;若其中不包含环，则输出&lt;code&gt;null&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;样例&quot;&gt;&lt;a href=&quot;#样例&quot; class=&quot;headerlink&quot; title=&quot;样例&quot;&gt;&lt;/a&gt;样例&lt;/h4&gt;&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/2020031819140188.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70&quot; alt&gt;&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;给定如上所示的链表：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[1, 2, 3, 4, 5, 6]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;注意，这里的2表示编号是2的节点，节点编号从0开始。所以编号是2的节点就是val等于3的节点。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;则输出环的入口节点3.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试题——包含min函数得栈</title>
    <link href="http://yoursite.com/2020/03/18/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E2%80%94%E5%8C%85%E5%90%ABmin%E5%87%BD%E6%95%B0%E5%BE%97%E6%A0%88/"/>
    <id>http://yoursite.com/2020/03/18/面试题——包含min函数得栈/</id>
    <published>2020-03-18T10:31:42.000Z</published>
    <updated>2020-03-19T08:29:19.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-41-包含-min-函数得栈"><a href="#AcWing-41-包含-min-函数得栈" class="headerlink" title="AcWing 41 包含 min 函数得栈"></a>AcWing 41 包含 min 函数得栈</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>设计一个支持push，pop，top等操作并且可以在O(1)时间内检索出最小元素的堆栈</p><ul><li>push(x)–将元素x插入栈中</li><li>pop()–移除栈顶元素</li><li>top()–得到栈顶元素</li><li>getMin()–得到栈中最小元素</li></ul><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">MinStack minStack = new MinStack();</span><br><span class="line">minStack.push(-1);</span><br><span class="line">minStack.push(3);</span><br><span class="line">minStack.push(-4);</span><br><span class="line">minStack.getMin();   --&gt; Returns -4.</span><br><span class="line">minStack.pop();</span><br><span class="line">minStack.top();      --&gt; Returns 3.</span><br><span class="line">minStack.getMin();   --&gt; Returns -1.</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​        首先我们要了解栈是一个什么样得数据结构，栈是一种先入后出得数据结构，它类似于一个一端封闭得容器，我们只能从一个入口向容器中放入元素，也只能从这个入口取出元素，且取出得元素一定是上一次放入操作放入的元素</p><p>​        回归这个问题，我们怎么实现一个包含压栈（push）、出栈（pop）、获取栈顶元素（top）、和获取当前栈中最小元素（getMin）这四种方法呢？</p><p>​        我们这里采用数组模拟栈，用数组模拟栈的好处是便捷，并且在不很复杂的问题中对数组模拟栈进行操作可以节省运算时间和运算成本，我们定义一个长度足够的数组<code>stk</code>用来表示栈，用一个<code>int</code>类型的变量<code>tt</code>表示栈顶的索引位置，当我们创建一个空栈时，这个指针应该指向<code>0</code>这个位置，每次我们进行压栈操作，<code>++tt</code>，每次我们出栈，<code>--tt</code>，获取栈顶元素时，我们只需要然会<code>stk[tt - 1]</code>即可</p><p>​        最关键的问题时如何找到当前栈中的最小值，如果没有时间限制的话，我们可以通过遍历栈的方式找到最小值，但是这道题的时间限制是<code>O(1)</code>，我们可以考虑，另外开辟一个数组<code>stkmin</code>，用这个数组来存储当前栈的最小值，每当我们在栈中压入一个数，我们就检测压入的元素是否比<code>stkmin</code>的栈顶元素小，如果是，那么新压入的元素便是最小值，否则原栈顶元素是最小值，而当<code>stk</code>中有元素出栈时，我们也同样只需要让<code>stkmin</code>的栈顶元素出栈即可，所以<code>stkmin</code>的栈顶元素就是<code>stk</code>中的最小值，下面是代码：</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MinStack</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> stk[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> stkmin[<span class="number">100010</span>];</span><br><span class="line"><span class="keyword">int</span> tt;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** initialize your data structure here. */</span></span><br><span class="line">MinStack() &#123;</span><br><span class="line">tt = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (tt == <span class="number">0</span>)</span><br><span class="line">stkmin[tt] = x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">if</span> (stkmin[tt - <span class="number">1</span>] &gt;= x)</span><br><span class="line">stkmin[tt] = x;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">stkmin[tt] = stkmin[tt - <span class="number">1</span>];</span><br><span class="line">stk[tt++] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">--tt;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">top</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> stk[tt - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">getMin</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> stkmin[tt - <span class="number">1</span>];</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AcWing-41-包含-min-函数得栈&quot;&gt;&lt;a href=&quot;#AcWing-41-包含-min-函数得栈&quot; class=&quot;headerlink&quot; title=&quot;AcWing 41 包含 min 函数得栈&quot;&gt;&lt;/a&gt;AcWing 41 包含 min 函数得栈&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;设计一个支持push，pop，top等操作并且可以在O(1)时间内检索出最小元素的堆栈&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;push(x)–将元素x插入栈中&lt;/li&gt;
&lt;li&gt;pop()–移除栈顶元素&lt;/li&gt;
&lt;li&gt;top()–得到栈顶元素&lt;/li&gt;
&lt;li&gt;getMin()–得到栈中最小元素&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;样例&quot;&gt;&lt;a href=&quot;#样例&quot; class=&quot;headerlink&quot; title=&quot;样例&quot;&gt;&lt;/a&gt;样例&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;MinStack minStack = new MinStack();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;minStack.push(-1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;minStack.push(3);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;minStack.push(-4);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;minStack.getMin();   --&amp;gt; Returns -4.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;minStack.pop();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;minStack.top();      --&amp;gt; Returns 3.&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;minStack.getMin();   --&amp;gt; Returns -1.&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（面试题3-1）——找出数组中重复的数字</title>
    <link href="http://yoursite.com/2020/03/17/%E5%89%91%E6%8C%87Offer%EF%BC%88%E9%9D%A2%E8%AF%95%E9%A2%983-1%EF%BC%89%E2%80%94%E2%80%94%E6%89%BE%E5%87%BA%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/03/17/剑指Offer（面试题3-1）——找出数组中重复的数字/</id>
    <published>2020-03-17T03:05:05.000Z</published>
    <updated>2020-03-20T14:44:46.275Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer——面试题-3-1"><a href="#剑指-Offer——面试题-3-1" class="headerlink" title="剑指 Offer——面试题 3-1"></a>剑指 Offer——面试题 3-1</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>找出数组中的重复数字</p><p>在一个长度为<code>n</code>的数组里的所有数字都在<code>0 ~ n - 1</code>的范围内，数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次，请找出数组中任意一个重复的数字</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2, 3, 1, 0, 2, 5, 3]</span><br></pre></td></tr></table></figure><h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 或 3</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​        这道题是一个很常见的数组问题，解法也有很多种，</p><p>​        首先想到的我们可以通过暴力方法（手动狗头），我们排序这个数组，然后遍历一遍数组看看有没有连续的两个相同的数字；另外，我们可以通过哈希表的特性，在遍历数组的过程中，每次检测哈希表中是否存在这个数字，不存在就放入哈希表中，存在就直接返回这个重复元素</p><p>​        那有没有什么比较巧妙的方法呢嘿嘿</p><p>​        这里提供一种方法，首先，如果这个数组没有重复元素，那么它一定会包含<code>0 ~ n - 1</code>中的所有数字，那么我们从头开始遍历这个数组，每遇到一个数，就检测它是不是在自己的位置上，即数组为<code>nums</code>，循环变量是<code>i</code>，当我们遍历到<code>nums[i]</code>时，我们检测<code>nums[i] == i</code>，如果不相等，我们就把<code>nums[i]</code>放到<code>nums[i]</code>的位置上，这样，在继续遍历的过程中，如果第二次遇到一个相同的数字，就会出现<code>nums[i] == nums[nums[i]]</code>这种情况，此时就是重复的数字了！代码如下：</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">dublicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (numbers == <span class="literal">nullptr</span> || length &lt;= <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) &#123;</span><br><span class="line"><span class="keyword">while</span> (numbers[i] != i) &#123;</span><br><span class="line"><span class="keyword">if</span> (numbers[i] == numbers[numbers[i]])</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">int</span> item = numbers[numbers[i]];</span><br><span class="line">numbers[numbers[i]] = numbers[i];</span><br><span class="line">numbers[i] = item;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">5</span>] = &#123; <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">3</span>, <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">if</span> (dublicate(a, <span class="number">5</span>))</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"yes"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"no"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指-Offer——面试题-3-1&quot;&gt;&lt;a href=&quot;#剑指-Offer——面试题-3-1&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer——面试题 3-1&quot;&gt;&lt;/a&gt;剑指 Offer——面试题 3-1&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;找出数组中的重复数字&lt;/p&gt;
&lt;p&gt;在一个长度为&lt;code&gt;n&lt;/code&gt;的数组里的所有数字都在&lt;code&gt;0 ~ n - 1&lt;/code&gt;的范围内，数组中某些数字是重复的，但不知道有几个数字重复了，也不知道每个数字重复了几次，请找出数组中任意一个重复的数字&lt;/p&gt;
&lt;h4 id=&quot;输入样例&quot;&gt;&lt;a href=&quot;#输入样例&quot; class=&quot;headerlink&quot; title=&quot;输入样例&quot;&gt;&lt;/a&gt;输入样例&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[2, 3, 1, 0, 2, 5, 3]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;输出样例&quot;&gt;&lt;a href=&quot;#输出样例&quot; class=&quot;headerlink&quot; title=&quot;输出样例&quot;&gt;&lt;/a&gt;输出样例&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;2 或 3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试题——寻找矩阵中的极小值</title>
    <link href="http://yoursite.com/2020/03/17/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E2%80%94%E5%AF%BB%E6%89%BE%E7%9F%A9%E9%98%B5%E4%B8%AD%E7%9A%84%E6%9E%81%E5%B0%8F%E5%80%BC/"/>
    <id>http://yoursite.com/2020/03/17/面试题——寻找矩阵中的极小值/</id>
    <published>2020-03-17T02:39:52.000Z</published>
    <updated>2020-03-19T08:28:54.477Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-1452-寻找矩阵的极小值"><a href="#AcWing-1452-寻找矩阵的极小值" class="headerlink" title="AcWing 1452 寻找矩阵的极小值"></a>AcWing 1452 寻找矩阵的极小值</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个<code>n × n</code>的矩阵，矩阵中包含<code>n × n</code>个_互不相同_的整数</p><p>定义极小值：如果一个数的值比与它相邻的所有数字的值都小，则这个数值就被称为极小值</p><p>一个数的相邻数字是指其上下左右四个方向相邻的四个数字，另外注意，处于边界或角落的数的相邻数字可能少于四个</p><p>要求在<code>O(nlogn)</code>的时间复杂度之内找出任意一个极小值的位置，并输出它在第几行第几列</p><p>本题中矩阵是隐藏的，你可以通过我们预设的<code>int</code>函数<code>query</code>来获得矩阵中某个位置的数值是多少</p><p>例如，<code>query(a,b)</code>即可获得矩阵中第<code>a</code>行第<code>b</code>列的位置的数值</p><p><strong>注意：</strong></p><ol><li>矩阵的行和列均从<code>0</code>开始编号</li><li><code>query()</code>函数的调用次数不能超过<code>(n + 2) × ⌈log2n⌉ + n</code></li><li>答案不唯一，输出任意一个极小值的位置即可</li></ol><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 ≤ n ≤ 300</code>，矩阵中的整数在<code>int</code>范围内</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[[1, 2, 3], [4, 5, 6], [7, 8, 9]]</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[0, 0]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​        这道题我们通过二分的思想解决，我们假设一个如下<code>5 * 5</code>的矩阵</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1  2  3  4  5</span><br><span class="line">6  7  8  9  10</span><br><span class="line">11 12 13 14 15</span><br><span class="line">16 17 18 19 20</span><br><span class="line">21 22 23 24 25</span><br></pre></td></tr></table></figure><p>​        肉眼可见，我们直接就可以看出本矩阵的极小值是<code>1</code>，但是我们怎么实现合格问题呢？</p><p>​        我们先从中间列也就是第<code>2</code>列将矩阵分为两部分，左和右，之后我们从中间列从上到下第一个元素开始遍历中间列，找到中间列的最小值，可以看到，最小值是<code>3</code>，随后我们对比<code>3</code>的左右元素，如果这时<code>3</code>的左右元素都<code>&gt; 3</code>，那很幸运，<code>3</code>就是矩阵的极小值，如果<code>3</code>的左右元素有<code>&lt; 3</code>的，那么我们只需要再次二分这半部分矩阵即可，因为这半部分矩阵中，一定存在极小值</p><p>​        系统给我们提供了<code>query(x, y)</code>函数来获取矩阵中<code>(x, y)</code>位置的元素，但是有使用次数限制，这里的限制证明过程过于繁琐，我们只需要尽量降低<code>query(x, y)</code>函数的使用次数即可</p><p>​        最后经过不断二分操作，矩阵一定只剩下一列，这时我们只需要取这一列的最小值即可，这个值便是整个矩阵的极小值！代码如下：</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; getMinimumValue(<span class="keyword">int</span> n) &#123;</span><br><span class="line"><span class="keyword">long</span> INF = <span class="number">1e15</span>;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = n - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">long</span> min = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">    <span class="keyword">int</span> val = query(i, mid);</span><br><span class="line"><span class="keyword">if</span> (min &gt;= val) &#123;</span><br><span class="line">min = val;</span><br><span class="line">k = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> left = mid ? query(k, mid - <span class="number">1</span>) : INF;</span><br><span class="line"><span class="keyword">long</span> right = (mid + <span class="number">1</span>) &lt; n ? query(k, mid + <span class="number">1</span>) : INF;</span><br><span class="line"><span class="keyword">if</span> (left &gt; min &amp;&amp; right &gt; min)</span><br><span class="line"><span class="keyword">return</span>&#123; k, mid &#125;;</span><br><span class="line"><span class="keyword">if</span> (left &lt; min)</span><br><span class="line">r = mid - <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">l = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">long</span> min = INF;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">    <span class="keyword">int</span> val = query(i, r);</span><br><span class="line"><span class="keyword">if</span> (min &gt; val) &#123;</span><br><span class="line">min = val;</span><br><span class="line">k = i;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> &#123; k, r &#125;;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AcWing-1452-寻找矩阵的极小值&quot;&gt;&lt;a href=&quot;#AcWing-1452-寻找矩阵的极小值&quot; class=&quot;headerlink&quot; title=&quot;AcWing 1452 寻找矩阵的极小值&quot;&gt;&lt;/a&gt;AcWing 1452 寻找矩阵的极小值&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个&lt;code&gt;n × n&lt;/code&gt;的矩阵，矩阵中包含&lt;code&gt;n × n&lt;/code&gt;个_互不相同_的整数&lt;/p&gt;
&lt;p&gt;定义极小值：如果一个数的值比与它相邻的所有数字的值都小，则这个数值就被称为极小值&lt;/p&gt;
&lt;p&gt;一个数的相邻数字是指其上下左右四个方向相邻的四个数字，另外注意，处于边界或角落的数的相邻数字可能少于四个&lt;/p&gt;
&lt;p&gt;要求在&lt;code&gt;O(nlogn)&lt;/code&gt;的时间复杂度之内找出任意一个极小值的位置，并输出它在第几行第几列&lt;/p&gt;
&lt;p&gt;本题中矩阵是隐藏的，你可以通过我们预设的&lt;code&gt;int&lt;/code&gt;函数&lt;code&gt;query&lt;/code&gt;来获得矩阵中某个位置的数值是多少&lt;/p&gt;
&lt;p&gt;例如，&lt;code&gt;query(a,b)&lt;/code&gt;即可获得矩阵中第&lt;code&gt;a&lt;/code&gt;行第&lt;code&gt;b&lt;/code&gt;列的位置的数值&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;矩阵的行和列均从&lt;code&gt;0&lt;/code&gt;开始编号&lt;/li&gt;
&lt;li&gt;&lt;code&gt;query()&lt;/code&gt;函数的调用次数不能超过&lt;code&gt;(n + 2) × ⌈log2n⌉ + n&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;答案不唯一，输出任意一个极小值的位置即可&lt;/li&gt;
&lt;/ol&gt;
&lt;h4 id=&quot;数据范围&quot;&gt;&lt;a href=&quot;#数据范围&quot; class=&quot;headerlink&quot; title=&quot;数据范围&quot;&gt;&lt;/a&gt;数据范围&lt;/h4&gt;&lt;p&gt;&lt;code&gt;1 ≤ n ≤ 300&lt;/code&gt;，矩阵中的整数在&lt;code&gt;int&lt;/code&gt;范围内&lt;/p&gt;
&lt;h4 id=&quot;输入样例：&quot;&gt;&lt;a href=&quot;#输入样例：&quot; class=&quot;headerlink&quot; title=&quot;输入样例：&quot;&gt;&lt;/a&gt;输入样例：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[[1, 2, 3], [4, 5, 6], [7, 8, 9]]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;输出样例：&quot;&gt;&lt;a href=&quot;#输出样例：&quot; class=&quot;headerlink&quot; title=&quot;输出样例：&quot;&gt;&lt;/a&gt;输出样例：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[0, 0]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试题——单链表快速排序</title>
    <link href="http://yoursite.com/2020/03/16/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E2%80%94%E5%8D%95%E9%93%BE%E8%A1%A8%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/03/16/面试题——单链表快速排序/</id>
    <published>2020-03-16T14:49:48.000Z</published>
    <updated>2020-03-16T15:02:22.386Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-1451-单链表快速排序"><a href="#AcWing-1451-单链表快速排序" class="headerlink" title="AcWing 1451 单链表快速排序"></a>AcWing 1451 单链表快速排序</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个单链表，请使用快速排序算法对其排序</p><p>要求：期望平均时间复杂度为<code>O(nlogn)</code>，期望额外空间复杂度为<code>O(logn)</code></p><p><strong>思考题：</strong> 如果只能改变链表结构，不能修改每个节点的<code>val</code>值该如何做呢</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p>链表中的所有数大小均在<code>int</code>范围内，链表长度在<code>[0, 10000]</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[5, 3, 2]</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2, 3, 5]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​        首先我们要思考快排的思想</p><p>​        快排就是选定一个目标值，将比目标值小的都放在左边，比目标值大的都放在右边，然后递归处理左边和右边，最后将三者（还有等于目标值的可能）合并，那在链表中如何实现快排呢</p><p>​        很简单，我们要定义三个链表，分别代表<code>left、mid、right</code>，我们设定一个目标值，假设为<code>int val = head-&gt;val</code>，通过遍历原链表，我们将比<code>val</code>小的放在<code>left</code>后，将比<code>val</code>大的放在<code>right</code>后，相等的放在<code>mid</code>后，然后递归处理<code>left</code>和<code>right</code>，最后将三者连接即可</p><p>​        这里需要注意几个细节，因为三个链表的表头指针我们后面会用到，所以我们需要一个变量来记录每个链表尾节点的指针：<code>ltail、mtail、rtail</code>，通过这三个指针，我们可以实现向链表尾插入数据；在遍历链表结束后，要将三个尾指针指空，否则系统无法判断链表是否结束了，下面是代码</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">quickSortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!head || !head-&gt;next) <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">auto</span> left = <span class="keyword">new</span> ListNode(<span class="number">-1</span>), mid = <span class="keyword">new</span> ListNode(<span class="number">-1</span>), right = <span class="keyword">new</span> ListNode(<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">auto</span> ltail = left, mtail = mid, rtail = right;</span><br><span class="line">        <span class="keyword">int</span> val = head-&gt;val;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p = head; p; p = p-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span> (p-&gt;val &lt; val) ltail = ltail-&gt;next = p;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (p-&gt;val == val) mtail = mtail-&gt;next = p;</span><br><span class="line">            <span class="keyword">else</span> rtail = rtail-&gt;next = p;</span><br><span class="line">        &#125;</span><br><span class="line">        ltail-&gt;next = rtail-&gt;next = mtail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">        left-&gt;next = quickSortList(left-&gt;next);</span><br><span class="line">        right-&gt;next = quickSortList(right-&gt;next);</span><br><span class="line">        <span class="keyword">auto</span> lh = left;</span><br><span class="line">        <span class="keyword">while</span> (lh-&gt;next) lh = lh-&gt;next;</span><br><span class="line">        lh-&gt;next = mid-&gt;next;</span><br><span class="line">        <span class="keyword">while</span> (lh-&gt;next) lh = lh-&gt;next;</span><br><span class="line">        lh-&gt;next = right-&gt;next;</span><br><span class="line">        <span class="keyword">return</span> left-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AcWing-1451-单链表快速排序&quot;&gt;&lt;a href=&quot;#AcWing-1451-单链表快速排序&quot; class=&quot;headerlink&quot; title=&quot;AcWing 1451 单链表快速排序&quot;&gt;&lt;/a&gt;AcWing 1451 单链表快速排序&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个单链表，请使用快速排序算法对其排序&lt;/p&gt;
&lt;p&gt;要求：期望平均时间复杂度为&lt;code&gt;O(nlogn)&lt;/code&gt;，期望额外空间复杂度为&lt;code&gt;O(logn)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思考题：&lt;/strong&gt; 如果只能改变链表结构，不能修改每个节点的&lt;code&gt;val&lt;/code&gt;值该如何做呢&lt;/p&gt;
&lt;h4 id=&quot;数据范围&quot;&gt;&lt;a href=&quot;#数据范围&quot; class=&quot;headerlink&quot; title=&quot;数据范围&quot;&gt;&lt;/a&gt;数据范围&lt;/h4&gt;&lt;p&gt;链表中的所有数大小均在&lt;code&gt;int&lt;/code&gt;范围内，链表长度在&lt;code&gt;[0, 10000]&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;输入样例：&quot;&gt;&lt;a href=&quot;#输入样例：&quot; class=&quot;headerlink&quot; title=&quot;输入样例：&quot;&gt;&lt;/a&gt;输入样例：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[5, 3, 2]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;输出样例：&quot;&gt;&lt;a href=&quot;#输出样例：&quot; class=&quot;headerlink&quot; title=&quot;输出样例：&quot;&gt;&lt;/a&gt;输出样例：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[2, 3, 5]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
</feed>
