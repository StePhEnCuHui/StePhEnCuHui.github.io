<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Step By Step</title>
  
  <subtitle>耀出千分光</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-11-11T05:09:01.056Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LiMinghui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>12</title>
    <link href="http://yoursite.com/2020/11/11/12/"/>
    <id>http://yoursite.com/2020/11/11/12/</id>
    <published>2020-11-11T05:09:01.000Z</published>
    <updated>2020-11-11T05:09:01.056Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>使用alibaba-nacos实现分布式系统中的服务中心</title>
    <link href="http://yoursite.com/2020/06/03/%E4%BD%BF%E7%94%A8alibaba-nacos%E5%AE%9E%E7%8E%B0%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F%E4%B8%AD%E7%9A%84%E6%9C%8D%E5%8A%A1%E4%B8%AD%E5%BF%83/"/>
    <id>http://yoursite.com/2020/06/03/使用alibaba-nacos实现分布式系统中的服务中心/</id>
    <published>2020-06-03T08:04:33.000Z</published>
    <updated>2020-06-03T09:43:33.991Z</updated>
    
    <content type="html"><![CDATA[<h1 id="使用-alibaba-nacos-实现分布式系统中的服务中心"><a href="#使用-alibaba-nacos-实现分布式系统中的服务中心" class="headerlink" title="使用 alibaba-nacos 实现分布式系统中的服务中心"></a>使用 alibaba-nacos 实现分布式系统中的服务中心</h1><p>​        最近在做一个分布式电商系统，使用<strong>spring-cloud-alibaba</strong>中的<code>nacos</code>作为项目的服务中心，下面简单介绍一下分布式系统、服务中心、以及<code>nacos</code>的使用</p><h2 id="什么是分布式"><a href="#什么是分布式" class="headerlink" title="什么是分布式"></a>什么是分布式</h2><p>​        首先我们要清楚分布式的概念：</p><blockquote><p> 分布式系统（<em>distributed system</em>）是建立在网络之上的软件系统。正是因为软件的特性，所以分布式系统具有高度的内聚性和透明性。因此，网络和分布式系统之间的区别更多的在于高层软件（特别是操作系统），而不是硬件。                          ——百度百科</p></blockquote><p>​        百度百科的解释看起来十分晦涩，我们可以理解为分布式系统是一种由多个节点构成的系统，节点之间互相连通，可以进行通信，它的优点是具有更高的效率和可靠性，庞大的任务可以被拆分成若干子任务，整个系统也不会因为一个节点的故障而崩溃，当一个节点崩溃时，其他节点仍然可以正常运行</p><p>​        举个简单的例子，假设我们现在有两种服务，一个是用户服务，一个是商品服务，当我们要实现用户买商品时，按照传统思路，所有的用户都需要访问这一个用户服务程序，再访问同一个商品服务程序，当访问量巨大时，会出现效率极低的情况，并且，一旦唯一的用户服务或商品服务掉线，整个系统都会崩溃</p><p>​        如果我们采用分布式系统的设计，将若干个用户服务和若干和商品服务同时部署，再发生上述情况时，服务器的压力会大大减小，并且，若出现服务故障，当前任务进程可以去申请其他节点的服务继续执行，系统崩溃的几率会大大降低</p><h2 id="集群"><a href="#集群" class="headerlink" title="集群"></a>集群</h2><p>​        分布式是一种工作方式，集群是一种物理形态</p><p>​        例如京东是一个分布式系统，众多业务运行在不同的机器，所有业务构成一个大型的业务集群，每一个小业务在访问压力大的时候使用一台服务器是不够的，我们就应该将相同的业务部署在多个服务器上，也就是每一个业务都可以做成集群化，而集群中的一个服务器，就称为节点</p><h2 id="远程调用"><a href="#远程调用" class="headerlink" title="远程调用"></a>远程调用</h2><p>​        在分布式系统中，各个服务处于不同主机，但是服务之间不可避免的需要相互作用，我们称为远程调用</p><p>​        <strong>Spring-Cloud</strong>中使用<strong>HTTP + JSON</strong>的方式完成这种远程调用</p><h2 id="服务的注册和发现——注册中心"><a href="#服务的注册和发现——注册中心" class="headerlink" title="服务的注册和发现——注册中心"></a>服务的注册和发现——注册中心</h2><p>​        当<code>A</code>服务嗲用<code>B</code>服务时，<code>A</code>服务并不知道系统中当前哪几台服务器在运行<code>B</code>服务，哪些<code>B</code>服务是正常的，哪些是下线的，为了解决这个问题，引入了注册中心</p><p>​        当某些服务上线或者下线，会在在注册中心注册或注销，注册中心会实时感知到这些服务的状态，从而避免调用不可用的服务</p><p><img src="C:%5CUsers%5CStePhEnCuHui%5CDesktop%5Cchance%5C%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83.png" alt></p><p>​        </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;使用-alibaba-nacos-实现分布式系统中的服务中心&quot;&gt;&lt;a href=&quot;#使用-alibaba-nacos-实现分布式系统中的服务中心&quot; class=&quot;headerlink&quot; title=&quot;使用 alibaba-nacos 实现分布式系统中的服务中心&quot;&gt;
      
    
    </summary>
    
    
      <category term="dstore-项目笔记" scheme="http://yoursite.com/tags/dstore-%E9%A1%B9%E7%9B%AE%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>asd</title>
    <link href="http://yoursite.com/2020/06/03/asd/"/>
    <id>http://yoursite.com/2020/06/03/asd/</id>
    <published>2020-06-03T08:04:00.000Z</published>
    <updated>2020-06-03T08:04:00.148Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>HashMap——HashMap中如何确定元素的位置</title>
    <link href="http://yoursite.com/2020/05/20/HashMap%E2%80%94%E2%80%94HashMap%E4%B8%AD%E7%9A%84indexFor%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2020/05/20/HashMap——HashMap中的indexFor方法/</id>
    <published>2020-05-20T02:51:05.000Z</published>
    <updated>2020-05-20T03:46:03.823Z</updated>
    
    <content type="html"><![CDATA[<h1 id="HashMap-中如何确定元素的位置"><a href="#HashMap-中如何确定元素的位置" class="headerlink" title="HashMap 中如何确定元素的位置"></a>HashMap 中如何确定元素的位置</h1><p>​    众所周知，在 jdk 1.7 中，HashMap 底层是由<strong>数组 + 链表</strong>的方式实现的，那我们在使用 HashMap 的时候，是如何将我们的 key-value put 到 HashMap 中的呢</p><a id="more"></a><h2 id="HashMap-存放原理"><a href="#HashMap-存放原理" class="headerlink" title="HashMap 存放原理"></a>HashMap 存放原理</h2><p>​        在理解 HashMap 的存放原理前，我们先来回想一下数组，当我们想给数组中的一个元素进行赋值时，我们至少需要知道两个条件，一是数组的引用名称，二是想要被赋值的数组元素的索引，即<code>array[i]</code>中的<code>array</code>和<code>i</code></p><p>​        我们再来看看，在 jdk 1.7 中 HashMap 的结构：</p><p><img src="https://img-blog.csdnimg.cn/20200520114436201.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>​        从上图我们可以看到，HashMap 的主体是一个数组，这个数组中存储的元素是一个<code>Entry&lt;k, v&gt;</code>类型的变量，这个变量有四个属性：<code>Object key</code>、<code>Object value</code>、<code>int hash</code>、<code>Entry next</code>，当两个元素经过计算后的数组下标相同时，就是所谓的发生了 Hash 碰撞，这时，就需要在数组发生 Hash 碰撞的位置构造一个链表，将发生碰撞的元素以链表的形式，存放在数组中</p><p>​        了解了 HashMap 的 构成，我们知道 HashMap 的本质也是数组，既然我们想向数组里 put 元素，那我们必然需要知道数组的引用名称和要被 put 的位置的下标，可是 HashMap 的 put 方法只有 key 和 value 两个参数，没有 int 类型的 index，那 HashMap 是如何确定每个元素会被存放到数组的哪个位置呢？</p><p>​        这里我们看一下 HashMap 源码中的 put 部分：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> V <span class="title">put</span><span class="params">(K key, V value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (table == EMPTY_TABLE) &#123;</span><br><span class="line">        inflateTable(threshold);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (key == <span class="keyword">null</span>)  </span><br><span class="line">        <span class="keyword">return</span> putForNullKey(value);</span><br><span class="line">    <span class="keyword">int</span> hash = hash(key);</span><br><span class="line">    <span class="keyword">int</span> i = indexFor(hash, table.length); </span><br><span class="line">    <span class="keyword">for</span> (Entry&lt;K,V&gt; e = table[i]; e != <span class="keyword">null</span>; e = e.next) &#123;  </span><br><span class="line">        Object k;  </span><br><span class="line">        <span class="keyword">if</span> (e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))) &#123;  </span><br><span class="line">            V oldValue = e.value;  </span><br><span class="line">            e.value = value;  </span><br><span class="line">            e.recordAccess(<span class="keyword">this</span>);  </span><br><span class="line">            <span class="keyword">return</span> oldValue;  </span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;  </span><br><span class="line">    addEntry(hash, key, value, i);  </span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">null</span>;  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这里我们暂且不讨论其他部分，直接看第 8 行代码，结合下面的<code>table[i]</code>等变量可以看到，这行代码通过<code>indexFor</code>函数返回的值，正是经过计算的数组下标，也就是说，HashMap 会在 put 元素时，通过元素的 hash 值以及当前数组的长度，来确定一个下标来存放元素</p><p>​        这时我们不妨想一想，hash 值一般都是一个十分巨大的整数，例如<code>12345643</code>、<code>327864322</code>等等（都是我瞎打的），而数组的长度一定是一个十分有限的数，假设是<code>8</code>，我们正常想通过这两个数来获取一个<code>0~7</code>的正数下标要怎么做？毫无以为，用<code>hash % table.length</code>，这样不管 hash 是一个多大的数，我们都可以得到一个在数组索引范围内的整数，那 HashMap 的 indexFor 函数中是如何做的呢？</p><h2 id="HashMap-的-indexFor-函数"><a href="#HashMap-的-indexFor-函数" class="headerlink" title="HashMap 的 indexFor 函数"></a>HashMap 的 indexFor 函数</h2><p>​        这里我们直接看 indexFor 函数的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">     * Returns index for hash code h.</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">indexFor</span><span class="params">(<span class="keyword">int</span> h, <span class="keyword">int</span> length)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2";</span></span><br><span class="line">        <span class="keyword">return</span> h &amp; (length-<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>​        代码很短，只有一行，我们可以看到，HashMap 中是通过 hash 和数组长度减一得到的结果进行一次<code>&amp;</code>运算，这里我们要先清楚<code>&amp;</code>运算的概念：将两个二进制数进行按位<code>&amp;</code>操作时，只有两个数对应的位上都为 1，结果为 1，否则都为 0</p><p>​        我们不妨带进来一个数算一遍，这样结果比较直接，假设我们的 h 的二进制表示是<code>1101 0110</code>（我瞎编的），数组的长度是<code>8</code>，二进制就是<code>0000 1000</code>，这时我们先进行<code>length - 1</code>的操作，得到<code>0000 0111</code>，这时再与 hash 进行<code>&amp;</code>操作时，可以得到<code>0000 0110</code>，即十进制的<code>6</code>，而 HashMap 的容量，即<strong>数组的长度永远都是<code>2</code>的次方</strong>，也就是说，<code>table.length</code>的二进制表示永远都是一个<code>1</code>，其余都是<code>0</code>的状态，例如<code>2</code>的<code>4</code>次方<code>16</code>是<code>0001 0000</code>，<code>5</code>次方<code>32</code>是<code>0010 0000</code>，那也就是说明，<code>table.length - 1</code>得到的值永远都是前一半都是<code>0</code>，后一半都是<code>1</code>，这种结构再与 hash 进行<code>&amp;</code>操作时，得到的结果就和<code>hash % table.length</code>一样了！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;HashMap-中如何确定元素的位置&quot;&gt;&lt;a href=&quot;#HashMap-中如何确定元素的位置&quot; class=&quot;headerlink&quot; title=&quot;HashMap 中如何确定元素的位置&quot;&gt;&lt;/a&gt;HashMap 中如何确定元素的位置&lt;/h1&gt;&lt;p&gt;​    众所周知，在 jdk 1.7 中，HashMap 底层是由&lt;strong&gt;数组 + 链表&lt;/strong&gt;的方式实现的，那我们在使用 HashMap 的时候，是如何将我们的 key-value put 到 HashMap 中的呢&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA 深入" scheme="http://yoursite.com/tags/JAVA-%E6%B7%B1%E5%85%A5/"/>
    
  </entry>
  
  <entry>
    <title>Java并发编程——管程（Monitor）</title>
    <link href="http://yoursite.com/2020/05/12/Java%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B%E2%80%94%E2%80%94%E7%AE%A1%E7%A8%8B%EF%BC%88Monitor%EF%BC%89/"/>
    <id>http://yoursite.com/2020/05/12/Java并发编程——管程（Monitor）/</id>
    <published>2020-05-12T07:51:08.000Z</published>
    <updated>2020-05-12T09:01:54.969Z</updated>
    
    <content type="html"><![CDATA[<h1 id="管程（Monitor）"><a href="#管程（Monitor）" class="headerlink" title="管程（Monitor）"></a>管程（Monitor）</h1><p>​    管程（Monitor），Java 中被翻译为监视器，管程是它在操作系统层面的名称，所谓管程，即<strong>管理共享变量及对其操作过程，让它支持并发访问</strong>，在 Java 中可以理解为管理类的成员变量和方法，从而达到线程安全的目的</p><h2 id="共享带来的问题"><a href="#共享带来的问题" class="headerlink" title="共享带来的问题"></a>共享带来的问题</h2><p>​        假设此时有两个线程同时对初始值为<code>0</code>的静态变量做相同次数的自增和自减：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">    Thread t1 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; ++i) counter++;</span><br><span class="line">    &#125;, <span class="string">"t1"</span>);</span><br><span class="line"></span><br><span class="line">    Thread t2 = <span class="keyword">new</span> Thread(() -&gt; &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">5000</span>; ++i) counter--;</span><br><span class="line">    &#125;, <span class="string">"t2"</span>);</span><br><span class="line"></span><br><span class="line">    t1.start();</span><br><span class="line">    t2.start();</span><br><span class="line">    t1.join();</span><br><span class="line">    t2.join();</span><br><span class="line"></span><br><span class="line">    log.debug(<span class="string">"is &#123;&#125;"</span>, counter);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        按常理，这个加一次减一次，最后的结果应该是<code>0</code>吧，让我们来看看运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">16:01:50 [main] c.Test1 - is -1768</span><br><span class="line"></span><br><span class="line">Process finished with exit code 0</span><br></pre></td></tr></table></figure><p>​        显然，这个程序的运行结果不是<code>0</code>，为什么会出现这个问题呢？我们需要从字节码来进行分析</p><p>​        对于<code>i++</code>操作来说，实际上会产生四行字节码指令<code>getstatic i</code>、<code>iconst_1</code>、<code>iadd</code>、<code>putstatic</code>，而在 Java 内存模型中，完成静态变量的自增自减，需要在主存和工作内存中进行数据交换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> 《---》 线程 1 i++</span><br><span class="line">    主内存</span><br><span class="line">static int i = 0</span><br><span class="line"> 《---》 线程 2 i--</span><br></pre></td></tr></table></figure><p>​        由于线程占用 cpu 资源的顺序是随机的，所以<code>i++</code>和<code>i--</code>这两行代码所对应的<code>8</code>行字节码指令，可能会出现交错运行的情况：线程 1 从主存中获取了 <code>i</code>的值为<code>0</code>，还没进行<code>++</code>操作时，线程 2 也取到了<code>i = 0</code>，这时线程 1 和线程 2 分别进行<code>++</code>和<code>--</code>操作后，线程 1 先将<code>i = 1</code>返回给主存，随后线程 2 又将<code>i = -1</code>返回给主存，这时主存中的<code>i</code>值即为<code>-1</code>，在这种情况多次重复运行后，<code>i</code>的值根本无法预测</p><p>​        如何解决在并发情况下的这种问题呢？这时要引入临界区（Critical Section）的概念</p><h2 id="临界区（Critical-Section）"><a href="#临界区（Critical-Section）" class="headerlink" title="临界区（Critical Section）"></a>临界区（Critical Section）</h2><p>​        上述程序中，一个程序运行多个线程本身是没有问题的，问题出现在多个线程同时访问共享资源，而多个线程访问共享资源本身也是没有问题的，问题的根本在于：在多个线程对共享资源进行读写操作时发生了指令交错，而当一段代码块内如果存在对共享资源的多线程读写操作，我们就称这段代码块为<strong>临界区</strong></p><p>​        很明显，上一个例子中的临界区即为<code>counter++</code>和<code>counter--</code>这两行代码，多个线程在临界区内执行，由于代码的执行序列不同而导致结果无法预测，称之为发生了<strong>竞态条件</strong>，为了避免临界区的竞态条件发生，可以使用：</p><ul><li>阻塞时解决方案：synchronized、Lock</li><li>非阻塞式解决方案：原子变量</li></ul><p>##　synchronized　解决方案</p><p>​        <code>synchronized</code>，即俗称的【对象锁】，它采用互斥的方式让同一时刻至多只有一个线程持有【对象锁】，其他线程再想获取【对象锁】时就会阻塞住，这样就能保证拥有锁的线程可以安全的执行临界区内的代码，不用担心上下文切换</p><h3 id="synchronized-用法"><a href="#synchronized-用法" class="headerlink" title="synchronized 用法"></a>synchronized 用法</h3><p>​        【对象锁】在使用时，只需要将临界区代码放在<code>synchronized</code>代码块内即可，即：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> Object room = <span class="keyword">new</span> Object();</span><br><span class="line">...</span><br><span class="line"><span class="keyword">synchronized</span>(room) &#123;</span><br><span class="line">conuter++;</span><br><span class="line">&#125;</span><br><span class="line">...</span><br><span class="line"><span class="keyword">synchronized</span>(room) &#123;</span><br><span class="line">conuter--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这种写法就保证了</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;管程（Monitor）&quot;&gt;&lt;a href=&quot;#管程（Monitor）&quot; class=&quot;headerlink&quot; title=&quot;管程（Monitor）&quot;&gt;&lt;/a&gt;管程（Monitor）&lt;/h1&gt;&lt;p&gt;​    管程（Monitor），Java 中被翻译为监视器，管程是
      
    
    </summary>
    
    
      <category term="并发编程" scheme="http://yoursite.com/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>面试题——最长上升子串</title>
    <link href="http://yoursite.com/2020/05/06/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E2%80%94%E6%9C%80%E9%95%BF%E4%B8%8A%E5%8D%87%E5%AD%97%E4%B8%B2/"/>
    <id>http://yoursite.com/2020/05/06/面试题——最长上升字串/</id>
    <published>2020-05-06T13:25:47.000Z</published>
    <updated>2020-05-06T13:41:40.105Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-1490-最长上升子串"><a href="#AcWing-1490-最长上升子串" class="headerlink" title="AcWing 1490 最长上升子串"></a>AcWing 1490 最长上升子串</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>​    给出一个长度为<code>n</code>的由正整数构成的序列，你需要从中删除一个正整数，很显然你有很多种删除方式，你需要对删除这个正整数以后的序列求其最长上升子串，请问在所有删除方案中，最长的上升子串长度是多少。</p><p>​    这里给出最长上升子串的定义：即对于序列中<strong>连续</strong>的若干个正整数，满足<code>ai+1 &gt; ai</code>，则称这连续的若干个整数构成的子串为上升子串，在所有的上升子串中，长度最长的称为最长上升子串。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入第一行仅包含一个正整数<code>n</code>，表示给出的序列的长度。</p><p>接下来一行有<code>n</code>个正整数，即这个序列，中间用空格隔开。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出仅包含一个正整数，即删除一个数字之后的最长上升子串长度。</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>1 ≤ n ≤ 100000</code><br><code>1 ≤ ai ≤ 100000</code></p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">5</span><br><span class="line">2 1 3 2 5</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">3</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​    这道题我们采用枚举的做法进行求解，对于序列中任意位置 <code>i</code> 的数字，我们都求出它之前按顺序递增最远可以到达的距离<code>f[i]</code>，和它之后按顺序递增最远可以到达的距离<code>g[i]</code>，当我们要拿掉一个数字来得到最长上升子串时，我们只需要先判断拿掉了<code>i</code>后第<code>i</code>个元素两边是否可以拼接上，如果可以，拿掉<code>i</code>的连续上升子串的长度即为<code>f[i - 1] + g[i + 1]</code>，不能拼接的话即为<code>max(f[i - 1], g[i + 1])</code>，最后取所有情况的最大值，即为最长上升子串的长度</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c"><a href="#c" class="headerlink" title="c++"></a>c++</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> nums[N], f[N], g[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;n);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;nums[i]);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line"><span class="keyword">if</span> (nums[i] &gt; nums[i - <span class="number">1</span>]) f[i] = f[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> f[i] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt; <span class="number">0</span>; --i)</span><br><span class="line"><span class="keyword">if</span> (nums[i] &lt; nums[i + <span class="number">1</span>]) g[i] = g[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span> g[i] = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line"><span class="keyword">if</span> (nums[i - <span class="number">1</span>] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line"><span class="keyword">int</span> a = f[i - <span class="number">1</span>] + g[i + <span class="number">1</span>];</span><br><span class="line">res = a &gt; res ? a : res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">int</span> a = f[i - <span class="number">1</span>] &gt; g[i + <span class="number">1</span>] ? f[i - <span class="number">1</span>] : g[i + <span class="number">1</span>];</span><br><span class="line">res = a &gt; res ? a : res;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">"%d"</span>, res);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="java"><a href="#java" class="headerlink" title="java"></a>java</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> AcWingCode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.util.Scanner;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">p1490</span> </span>&#123;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> n, res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> nums[] = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">int</span> f[] = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        <span class="keyword">int</span> g[] = <span class="keyword">new</span> <span class="keyword">int</span>[N];</span><br><span class="line">        Scanner myInput = <span class="keyword">new</span> Scanner(System.in);</span><br><span class="line">        n = myInput.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i)</span><br><span class="line">            nums[i] = myInput.nextInt();</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[i - <span class="number">1</span>]) f[i] = f[i - <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> f[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = n; i &gt;= <span class="number">1</span>; --i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &gt; nums[i + <span class="number">1</span>]) g[i] = g[i + <span class="number">1</span>] + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> g[i] = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i - <span class="number">1</span>] &lt; nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">int</span> add = f[i - <span class="number">1</span>] + g[i + <span class="number">1</span>];</span><br><span class="line">                res = res &gt; add ? res : add;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> max = f[i - <span class="number">1</span>] &gt; g[i + <span class="number">1</span>] ? f[i - <span class="number">1</span>] : g[i + <span class="number">1</span>];</span><br><span class="line">                res = res &gt; max ? res : max;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(res);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AcWing-1490-最长上升子串&quot;&gt;&lt;a href=&quot;#AcWing-1490-最长上升子串&quot; class=&quot;headerlink&quot; title=&quot;AcWing 1490 最长上升子串&quot;&gt;&lt;/a&gt;AcWing 1490 最长上升子串&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;​    给出一个长度为&lt;code&gt;n&lt;/code&gt;的由正整数构成的序列，你需要从中删除一个正整数，很显然你有很多种删除方式，你需要对删除这个正整数以后的序列求其最长上升子串，请问在所有删除方案中，最长的上升子串长度是多少。&lt;/p&gt;
&lt;p&gt;​    这里给出最长上升子串的定义：即对于序列中&lt;strong&gt;连续&lt;/strong&gt;的若干个正整数，满足&lt;code&gt;ai+1 &amp;gt; ai&lt;/code&gt;，则称这连续的若干个整数构成的子串为上升子串，在所有的上升子串中，长度最长的称为最长上升子串。&lt;/p&gt;
&lt;h4 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title=&quot;输入格式&quot;&gt;&lt;/a&gt;输入格式&lt;/h4&gt;&lt;p&gt;输入第一行仅包含一个正整数&lt;code&gt;n&lt;/code&gt;，表示给出的序列的长度。&lt;/p&gt;
&lt;p&gt;接下来一行有&lt;code&gt;n&lt;/code&gt;个正整数，即这个序列，中间用空格隔开。&lt;/p&gt;
&lt;h4 id=&quot;输出格式&quot;&gt;&lt;a href=&quot;#输出格式&quot; class=&quot;headerlink&quot; title=&quot;输出格式&quot;&gt;&lt;/a&gt;输出格式&lt;/h4&gt;&lt;p&gt;输出仅包含一个正整数，即删除一个数字之后的最长上升子串长度。&lt;/p&gt;
&lt;h4 id=&quot;数据范围&quot;&gt;&lt;a href=&quot;#数据范围&quot; class=&quot;headerlink&quot; title=&quot;数据范围&quot;&gt;&lt;/a&gt;数据范围&lt;/h4&gt;&lt;p&gt;&lt;code&gt;1 ≤ n ≤ 100000&lt;/code&gt;&lt;br&gt;&lt;code&gt;1 ≤ ai ≤ 100000&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;输入样例：&quot;&gt;&lt;a href=&quot;#输入样例：&quot; class=&quot;headerlink&quot; title=&quot;输入样例：&quot;&gt;&lt;/a&gt;输入样例：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2 1 3 2 5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;输出样例：&quot;&gt;&lt;a href=&quot;#输出样例：&quot; class=&quot;headerlink&quot; title=&quot;输出样例：&quot;&gt;&lt;/a&gt;输出样例：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>Docker——CentOS7安装Docker环境</title>
    <link href="http://yoursite.com/2020/04/09/Docker%E2%80%94%E2%80%94CentOS7%E5%AE%89%E8%A3%85Docker%E7%8E%AF%E5%A2%83/"/>
    <id>http://yoursite.com/2020/04/09/Docker——CentOS7安装Docker环境/</id>
    <published>2020-04-09T13:44:57.000Z</published>
    <updated>2020-04-09T13:45:33.136Z</updated>
    
    <content type="html"><![CDATA[<h1 id="CentOs-7-安装-Docker"><a href="#CentOs-7-安装-Docker" class="headerlink" title="CentOs 7 安装 Docker"></a>CentOs 7 安装 Docker</h1><p>​    Docker 是一个开源的应用容器引擎，是一个轻量级容器技术，Docker 支持将软件编译成一个镜像，然后在镜像中对各种软件做好配置，将镜像发布出去，使用者们都可以直接使用这个镜像、</p><p>​    运行中的这个镜像被称为容器，容器的启动是非常快速的，下面我们就来介绍如何在 CentOS 7 系统中安装 Docker</p><a id="more"></a><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><p>​    首先，Docker 官方要求 Linux 内核版本必须在<code>3.8</code>以上，建议<code>3.10</code>以上，我们可以使用<code>uname -a</code>指令来查看内核版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[stephen@localhost ~]$ uname -a</span><br><span class="line">Linux localhost.localdomain 3.10.0-693.el7.x86_64 #1 SMP Tue Aug 22 21:09:27 UTC 2017 x86_64 x86_64 x86_64 GNU/Linux</span><br></pre></td></tr></table></figure><p>​    我这里已经是<code>3.10</code>以上的版本了，如果不是的话，我们需要使用<code>sudo yum update</code>指令来更新软件包及内核</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">[stephen@localhost ~]$ sudo yum update</span><br><span class="line"></span><br><span class="line">我们信任您已经从系统管理员那里了解了日常注意事项。</span><br><span class="line">总结起来无外乎这三点：</span><br><span class="line"></span><br><span class="line">    #1) 尊重别人的隐私。</span><br><span class="line">    #2) 输入前要先考虑(后果和风险)。</span><br><span class="line">    #3) 权力越大，责任越大。</span><br><span class="line"></span><br><span class="line">[sudo] stephen 的密码：</span><br><span class="line">已加载插件：fastestmirror, langpacks</span><br><span class="line">base                                                     | 3.6 kB     00:00     </span><br><span class="line">extras                                                   | 2.9 kB     00:00     </span><br><span class="line">updates                                                  | 2.9 kB     00:00     </span><br><span class="line">(1/4): extras/7/x86_64/primary_db                          | 165 kB   00:00     </span><br><span class="line">(2/4): base/7/x86_64/group_gz                              | 165 kB   00:00     </span><br><span class="line">(3/4): base/7/x86_64/primary_db                            | 6.0 MB   00:04     </span><br><span class="line">(4/4): updates/7/x86_64/primary_db                         | 7.6 MB   00:07     </span><br><span class="line">Determining fastest mirrors</span><br><span class="line"> * base: mirrors.tuna.tsinghua.edu.cn</span><br><span class="line"> * extras: mirrors.tuna.tsinghua.edu.cn</span><br><span class="line"> * updates: mirrors.tuna.tsinghua.edu.cn</span><br><span class="line">正在解决依赖关系</span><br><span class="line">--&gt; 正在检查事务</span><br><span class="line">---&gt; 软件包 GeoIP.x86_64.0.1.5.0-11.el7 将被 升级</span><br><span class="line">---&gt; 软件包 GeoIP.x86_64.0.1.5.0-14.el7 将被 更新</span><br><span class="line">--&gt; 正在处理依赖关系 geoipupdate，它被软件包 GeoIP-1.5.0-14.el7.x86_64 需要</span><br><span class="line">---&gt; 软件包 ModemManager.x86_64.0.1.6.0-2.el7 将被 升级</span><br><span class="line">---&gt; 软件包 ModemManager.x86_64.0.1.6.10-3.el7_6 将被 更新</span><br><span class="line">---&gt; 软件包 ModemManager-glib.x86_64.0.1.6.0-2.el7 将被 升级</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">  zenity.x86_64 0:3.28.1-1.el7                                                  </span><br><span class="line">  zlib.x86_64 0:1.2.7-18.el7                                                    </span><br><span class="line"></span><br><span class="line">替代:</span><br><span class="line">  caribou.x86_64 0:0.4.21-1.el7                                                 </span><br><span class="line">  caribou-gtk2-module.x86_64 0:0.4.21-1.el7                                     </span><br><span class="line">  caribou-gtk3-module.x86_64 0:0.4.21-1.el7                                     </span><br><span class="line">  gnome-dictionary-libs.x86_64 0:3.20.0-1.el7                                   </span><br><span class="line">  gnome-tweak-tool.noarch 0:3.22.0-1.el7                                        </span><br><span class="line">  grub2.x86_64 1:2.02-0.64.el7.centos                                           </span><br><span class="line">  grub2-tools.x86_64 1:2.02-0.64.el7.centos                                     </span><br><span class="line">  pyatspi.noarch 0:2.20.3-1.el7                                                 </span><br><span class="line">  python2-caribou.noarch 0:0.4.21-1.el7                                         </span><br><span class="line">  urw-fonts.noarch 0:2.4-16.el7                                                 </span><br><span class="line"></span><br><span class="line">完毕!</span><br></pre></td></tr></table></figure><p>​    接下来我们就可以安装 Docker 了</p><h2 id="安装-Docker"><a href="#安装-Docker" class="headerlink" title="安装 Docker"></a>安装 Docker</h2><p>​    检测过内核版本后，我们就可以使用<code>yum install docker</code>命令安装 Docker，我们需要使用 root 权限来操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">[stephen@localhost ~]$ su root</span><br><span class="line">密码：</span><br><span class="line">[root@localhost stephen]# yum install docker</span><br><span class="line">已加载插件：fastestmirror, langpacks</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line"> * base: mirrors.tuna.tsinghua.edu.cn</span><br><span class="line"> * extras: mirrors.tuna.tsinghua.edu.cn</span><br><span class="line"> * updates: mirrors.tuna.tsinghua.edu.cn</span><br><span class="line">正在解决依赖关系</span><br><span class="line">--&gt; 正在检查事务</span><br><span class="line">---&gt; 软件包 docker.x86_64.2.1.13.1-109.gitcccb291.el7.centos 将被 安装</span><br><span class="line">--&gt; 正在处理依赖关系 docker-common = 2:1.13.1-109.gitcccb291.el7.centos，它被软件包 2:docker-1.13.1-109.gitcccb291.el7.centos.x86_64 需要</span><br><span class="line">--&gt; 正在处理依赖关系 docker-client = 2:1.13.1-109.gitcccb291.el7.centos，它被软件包 2:docker-1.13.1-109.gitcccb291.el7.centos.x86_64 需要</span><br><span class="line">--&gt; 正在处理依赖关系 subscription-manager-rhsm-certificates，它被软件包 2:docker-1.13.1-109.gitcccb291.el7.centos.x86_64 需要</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">  container-selinux.noarch 2:2.107-3.el7                                        </span><br><span class="line">  container-storage-setup.noarch 0:0.11.0-2.git5eaf76c.el7                      </span><br><span class="line">  containers-common.x86_64 1:0.1.37-3.el7.centos                                </span><br><span class="line">  docker-client.x86_64 2:1.13.1-109.gitcccb291.el7.centos                       </span><br><span class="line">  docker-common.x86_64 2:1.13.1-109.gitcccb291.el7.centos                       </span><br><span class="line">  libyaml.x86_64 0:0.1.4-11.el7_0                                               </span><br><span class="line">  oci-register-machine.x86_64 1:0-6.git2b44233.el7                              </span><br><span class="line">  oci-systemd-hook.x86_64 1:0.2.0-1.git05e6923.el7_6                            </span><br><span class="line">  oci-umount.x86_64 2:2.5-3.el7                                                 </span><br><span class="line">  python-pytoml.noarch 0:0.1.14-1.git7dea353.el7                                </span><br><span class="line">  subscription-manager-rhsm-certificates.x86_64 0:1.24.13-4.el7.centos          </span><br><span class="line"></span><br><span class="line">完毕！</span><br></pre></td></tr></table></figure><h2 id="启动-Docker"><a href="#启动-Docker" class="headerlink" title="启动 Docker"></a>启动 Docker</h2><p>​    上述步骤执行结束并出现<strong>完毕!</strong>字样，说明我们已经在 CentOS 系统上成功安装了 Docker，我们通过执行<code>systemctl start docker</code>启动 Docker 并使用<code>docker -v</code>查看我们 Docker 的版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost stephen]# systemctl start docker</span><br><span class="line">[root@localhost stephen]# docker -v</span><br><span class="line">Docker version 1.13.1, build cccb291/1.13.1</span><br></pre></td></tr></table></figure><p>​    到这里，我们的 Docker 就已经成功的安装在 CentOS 操作系统中了，但是我们没此重启操作系统都要重启 Docker</p><h2 id="设置-Docker-的自启动"><a href="#设置-Docker-的自启动" class="headerlink" title="设置 Docker 的自启动"></a>设置 Docker 的自启动</h2><p>​    通过使用<code>systemctl enable docker</code>可以设置 Docker 的开机自启动</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost stephen]# systemctl enable docker</span><br><span class="line">Created symlink from /etc/systemd/system/multi-user.target.wants/docker.service to /usr/lib/systemd/system/docker.service.</span><br></pre></td></tr></table></figure><h2 id="关闭-Docker"><a href="#关闭-Docker" class="headerlink" title="关闭 Docker"></a>关闭 Docker</h2><p>​    使用<code>systemctl stop docker</code>命令可以关闭 Docker</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[root@localhost stephen]# systemctl stop docker</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;CentOs-7-安装-Docker&quot;&gt;&lt;a href=&quot;#CentOs-7-安装-Docker&quot; class=&quot;headerlink&quot; title=&quot;CentOs 7 安装 Docker&quot;&gt;&lt;/a&gt;CentOs 7 安装 Docker&lt;/h1&gt;&lt;p&gt;​    Docker 是一个开源的应用容器引擎，是一个轻量级容器技术，Docker 支持将软件编译成一个镜像，然后在镜像中对各种软件做好配置，将镜像发布出去，使用者们都可以直接使用这个镜像、&lt;/p&gt;
&lt;p&gt;​    运行中的这个镜像被称为容器，容器的启动是非常快速的，下面我们就来介绍如何在 CentOS 7 系统中安装 Docker&lt;/p&gt;
    
    </summary>
    
    
      <category term="Docker" scheme="http://yoursite.com/tags/Docker/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（面试题9-1）——用两个栈实现队列</title>
    <link href="http://yoursite.com/2020/04/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E9%9D%A2%E8%AF%95%E9%A2%989-1%EF%BC%89%E2%80%94%E2%80%94%E7%94%A8%E4%B8%A4%E4%B8%AA%E6%A0%88%E5%AE%9E%E7%8E%B0%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2020/04/01/剑指Offer（面试题9-1）——用两个栈实现队列/</id>
    <published>2020-04-01T03:16:43.000Z</published>
    <updated>2020-04-01T03:27:43.214Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指Offer（面试题9-1）"><a href="#剑指Offer（面试题9-1）" class="headerlink" title="剑指Offer（面试题9-1）"></a>剑指Offer（面试题9-1）</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>请用栈实现一个队列，支持如下四种操作：</p><ul><li>push(x) – 将元素x插到队尾；</li><li>pop() – 将队首的元素弹出，并返回该元素；</li><li>peek() – 返回队首元素；</li><li>empty() – 返回队列是否为空；</li></ul><p><strong>注意：</strong></p><ul><li>你只能使用栈的标准操作：<code>push to top</code>，<code>peek/pop from top</code>, <code>size</code> 和 <code>is empty</code>；</li><li>如果你选择的编程语言没有栈的标准库，你可以使用<code>list</code>或者<code>deque</code>等模拟栈的操作；</li><li>输入数据保证合法，例如，在队列为空时，不会进行<code>pop</code>或者<code>peek</code>等操作；</li></ul><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">MyQueue queue = new MyQueue();</span><br><span class="line"></span><br><span class="line">queue.push(1);</span><br><span class="line">queue.push(2);</span><br><span class="line">queue.peek();  // returns 1</span><br><span class="line">queue.pop();   // returns 1</span><br><span class="line">queue.empty(); // returns false</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​        在做这道题之前，我们应该先搞清楚栈和队列的特点：栈是一种后入先出的数据结构，而队列是一种先入先出的数据结构</p><p>​        我们可以通过两个栈来实现一个队列，<code>st1</code>作为接收入队元素的栈，<code>st2</code>作为控制出队元素的栈，当我们要入队时，就将入队元素压入<code>st1</code>中，这时我们发现，如果需要出队，根据队列先入先出的特性，<code>st1</code>的栈底元素需要最先被弹出，这时就要用到第二个栈<code>st2</code>了，我们将<code>st1</code>中所有的元素全部出栈，并依次压入<code>st2</code>，可以发现，因为栈是后入先出的数据结构，<code>st1</code>的栈顶元素会被压入<code>st2</code>的栈底， 而我们要得到的最先入队的元素，也就是原<code>st1</code>的栈底元素，此时在<code>st2</code>的栈顶，我们直接对<code>st2</code>进行出栈操作，就可以得到需要出队的元素了</p><p>​        这里我们需要注意，每次出栈时，我们应该先检测<code>st2</code>中是否还有值，如果有值我们就不需要将<code>st1</code>的元素压入<code>st2</code>中，直接从<code>st2</code>出栈即可，下面是代码，这里我是用 Java 中自带的栈，使用数组模拟栈也是完全可以的</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyQueue</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; st1;</span><br><span class="line">    <span class="keyword">private</span> Stack&lt;Integer&gt; st2;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/** Initialize your data structure here. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">MyQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        st1 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">        st2 = <span class="keyword">new</span> Stack&lt;Integer&gt;();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Push element x to the back of queue. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">push</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">        st1.push(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Removes the element from in front of queue and returns that element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (st2.empty()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (!st1.empty())</span><br><span class="line">                st2.push(st1.pop());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> st2.pop();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Get the front element. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (st2.empty())</span><br><span class="line">            <span class="keyword">while</span> (!st1.empty())</span><br><span class="line">                st2.push(st1.pop());</span><br><span class="line">        <span class="keyword">return</span> st2.peek();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">/** Returns whether the queue is empty. */</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (st1.empty() &amp;&amp; st2.empty()) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Your MyQueue object will be instantiated and called as such:</span></span><br><span class="line"><span class="comment"> * MyQueue obj = new MyQueue();</span></span><br><span class="line"><span class="comment"> * obj.push(x);</span></span><br><span class="line"><span class="comment"> * int param_2 = obj.pop();</span></span><br><span class="line"><span class="comment"> * int param_3 = obj.peek();</span></span><br><span class="line"><span class="comment"> * boolean param_4 = obj.empty();</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指Offer（面试题9-1）&quot;&gt;&lt;a href=&quot;#剑指Offer（面试题9-1）&quot; class=&quot;headerlink&quot; title=&quot;剑指Offer（面试题9-1）&quot;&gt;&lt;/a&gt;剑指Offer（面试题9-1）&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;请用栈实现一个队列，支持如下四种操作：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;push(x) – 将元素x插到队尾；&lt;/li&gt;
&lt;li&gt;pop() – 将队首的元素弹出，并返回该元素；&lt;/li&gt;
&lt;li&gt;peek() – 返回队首元素；&lt;/li&gt;
&lt;li&gt;empty() – 返回队列是否为空；&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;你只能使用栈的标准操作：&lt;code&gt;push to top&lt;/code&gt;，&lt;code&gt;peek/pop from top&lt;/code&gt;, &lt;code&gt;size&lt;/code&gt; 和 &lt;code&gt;is empty&lt;/code&gt;；&lt;/li&gt;
&lt;li&gt;如果你选择的编程语言没有栈的标准库，你可以使用&lt;code&gt;list&lt;/code&gt;或者&lt;code&gt;deque&lt;/code&gt;等模拟栈的操作；&lt;/li&gt;
&lt;li&gt;输入数据保证合法，例如，在队列为空时，不会进行&lt;code&gt;pop&lt;/code&gt;或者&lt;code&gt;peek&lt;/code&gt;等操作；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;样例&quot;&gt;&lt;a href=&quot;#样例&quot; class=&quot;headerlink&quot; title=&quot;样例&quot;&gt;&lt;/a&gt;样例&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;MyQueue queue = new MyQueue();&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue.push(1);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue.push(2);&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue.peek();  // returns 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue.pop();   // returns 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;queue.empty(); // returns false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（面试题8-1）——二叉树的下一个节点</title>
    <link href="http://yoursite.com/2020/04/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E9%9D%A2%E8%AF%95%E9%A2%988-1%EF%BC%89%E2%80%94%E2%80%94%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9/"/>
    <id>http://yoursite.com/2020/04/01/剑指Offer（面试题8-1）——二叉树的下一个节点/</id>
    <published>2020-04-01T02:59:34.000Z</published>
    <updated>2020-04-01T03:14:35.209Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指Offer（面试题8-1）"><a href="#剑指Offer（面试题8-1）" class="headerlink" title="剑指Offer（面试题8-1）"></a>剑指Offer（面试题8-1）</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一棵二叉树的其中一个节点，请找出中序遍历序列的下一个节点。</p><p><strong>注意：</strong></p><ul><li>如果给定的节点是中序遍历序列的最后一个，则返回空节点;</li><li>二叉树一定不为空，且给定的节点一定不是空节点；</li></ul><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">假定二叉树是：[2, 1, 3, null, null, null, null]， 给出的是值等于2的节点。</span><br><span class="line"></span><br><span class="line">则应返回值等于3的节点。</span><br><span class="line"></span><br><span class="line">解释：该二叉树的结构如下，2的后继节点是3。</span><br><span class="line">  2</span><br><span class="line"> / \</span><br><span class="line">1   3</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​        拿到这道题，我们要先了解什么是二叉树的<strong>中序遍历</strong>，中序遍历指的是以<strong>左、根、右</strong>的顺序对二叉树进行遍历，例如中序遍历为<code>[4, 2, 5, 1, 6, 7, 3]</code>的二叉树，它的形状是这样的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">     1</span><br><span class="line">   /   \</span><br><span class="line">  2     3</span><br><span class="line"> / \   / </span><br><span class="line">4   5 6</span><br><span class="line">       \</span><br><span class="line">        7</span><br></pre></td></tr></table></figure><p>​        如果我们想得到某个节点在中序遍历中的下一个节点，我们就需要留意存在多少种情况，以上面的二叉树为例，有一下情况：</p><ul><li>2：节点<code>2</code>是一个存在右子树的节点，如果一个节点存在右子树，那么它在中序遍历中的下一个节点就是<code>node.right.left.left......left</code>，就是它右子树的最深的左子树</li><li>3：节点<code>3</code>不存在右子树，这时我们要关注它是它父亲节点的哪一个孩子，显然<code>3</code>是右孩子，那就说明它的下一节点要么是它父亲的父亲，例如<code>5</code>，要么为<code>null</code></li><li>4：与上一种情况相反，<code>4</code>虽然没有右孩子，但是它是它父亲节点的左孩子，那它的下一节点就是它的父亲节点</li></ul><p>​    到这里，我们可以根据这几种情况，通过代码来找到下一节点</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for a binary tree node.</span></span><br><span class="line"><span class="comment"> * public class TreeNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     TreeNode left;</span></span><br><span class="line"><span class="comment"> *     TreeNode right;</span></span><br><span class="line"><span class="comment"> *     TreeNode father;</span></span><br><span class="line"><span class="comment"> *     TreeNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> TreeNode <span class="title">inorderSuccessor</span><span class="params">(TreeNode p)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (p.right != <span class="keyword">null</span>) &#123;</span><br><span class="line">            p = p.right;</span><br><span class="line">            <span class="keyword">while</span> (p.left != <span class="keyword">null</span>) p = p.left;</span><br><span class="line">            <span class="keyword">return</span> p;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (p.father != <span class="keyword">null</span> &amp;&amp; p.father.right == p) <span class="keyword">return</span> p.right;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (p.father != <span class="keyword">null</span> &amp;&amp; p.father.left == p) <span class="keyword">return</span> p.father;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> p.father;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指Offer（面试题8-1）&quot;&gt;&lt;a href=&quot;#剑指Offer（面试题8-1）&quot; class=&quot;headerlink&quot; title=&quot;剑指Offer（面试题8-1）&quot;&gt;&lt;/a&gt;剑指Offer（面试题8-1）&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一棵二叉树的其中一个节点，请找出中序遍历序列的下一个节点。&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果给定的节点是中序遍历序列的最后一个，则返回空节点;&lt;/li&gt;
&lt;li&gt;二叉树一定不为空，且给定的节点一定不是空节点；&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;样例&quot;&gt;&lt;a href=&quot;#样例&quot; class=&quot;headerlink&quot; title=&quot;样例&quot;&gt;&lt;/a&gt;样例&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;假定二叉树是：[2, 1, 3, null, null, null, null]， 给出的是值等于2的节点。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;则应返回值等于3的节点。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：该二叉树的结构如下，2的后继节点是3。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1   3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（面试题6-1）——从尾到头打印链表</title>
    <link href="http://yoursite.com/2020/04/01/%E5%89%91%E6%8C%87Offer%EF%BC%88%E9%9D%A2%E8%AF%95%E9%A2%986-1%EF%BC%89%E2%80%94%E2%80%94%E4%BB%8E%E5%B0%BE%E5%88%B0%E5%A4%B4%E6%89%93%E5%8D%B0%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/04/01/剑指Offer（面试题6-1）——从尾到头打印链表/</id>
    <published>2020-04-01T02:45:12.000Z</published>
    <updated>2020-04-01T02:54:23.902Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer-面试题（6-1）"><a href="#剑指-Offer-面试题（6-1）" class="headerlink" title="剑指 Offer 面试题（6-1）"></a>剑指 Offer 面试题（6-1）</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>输入一个链表的头结点，按照 <strong>从尾到头</strong> 的顺序返回节点的值。</p><p>返回的结果用数组存储。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：[2, 3, 5]</span><br><span class="line">返回：[5, 3, 2]</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​        在这里我们不再解释与反转链表思路相同的做法（用三个指针，改变链表结构，想了解可以看这里——<code>https://blog.csdn.net/scfor333/article/details/104968798</code></p><p>​        这里我们提供另一种不改变链表结构的方式，首先我们审读题意，将链表从尾到头输出，也就是类似于后进先出，这可以让我们联想到一种数据结构——栈，我们可以定义一个栈，然后遍历这个链表，从头到尾将每个值入栈，随后再将栈中数据依次出栈，即可达到从头到尾打印链表的目的，我使用了一个数组来模拟栈，下面是代码</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * class ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) &#123; val = x; &#125;</span></span><br><span class="line"><span class="comment"> * &#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">int</span>[] printListReversingly(ListNode head) &#123;</span><br><span class="line">        <span class="keyword">int</span>[] stack = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">100010</span>];</span><br><span class="line">        <span class="keyword">int</span> idx = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> length = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (head != <span class="keyword">null</span>) &#123;</span><br><span class="line">            stack[idx++] = head.val;</span><br><span class="line">            length++;</span><br><span class="line">            head = head.next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span>[] res = <span class="keyword">new</span> <span class="keyword">int</span>[length];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i) res[i] = stack[--idx];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指-Offer-面试题（6-1）&quot;&gt;&lt;a href=&quot;#剑指-Offer-面试题（6-1）&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer 面试题（6-1）&quot;&gt;&lt;/a&gt;剑指 Offer 面试题（6-1）&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;输入一个链表的头结点，按照 &lt;strong&gt;从尾到头&lt;/strong&gt; 的顺序返回节点的值。&lt;/p&gt;
&lt;p&gt;返回的结果用数组存储。&lt;/p&gt;
&lt;h4 id=&quot;样例&quot;&gt;&lt;a href=&quot;#样例&quot; class=&quot;headerlink&quot; title=&quot;样例&quot;&gt;&lt;/a&gt;样例&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：[2, 3, 5]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;返回：[5, 3, 2]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>SpringBoot——SpringBoot自动配置原理（2.2.5版本）</title>
    <link href="http://yoursite.com/2020/03/29/SpringBoot%E2%80%94%E2%80%94SpringBoot%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE%E5%8E%9F%E7%90%86%EF%BC%882-2-5%E7%89%88%E6%9C%AC%EF%BC%89/"/>
    <id>http://yoursite.com/2020/03/29/SpringBoot——SpringBoot自动配置原理（2-2-5版本）/</id>
    <published>2020-03-29T14:56:59.000Z</published>
    <updated>2020-03-29T15:55:59.779Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringBoot-自动配置原理"><a href="#SpringBoot-自动配置原理" class="headerlink" title="SpringBoot 自动配置原理"></a>SpringBoot 自动配置原理</h1><p>​        作为 SpringBoot 的精髓，自动配置是“习惯优于配置”理念的体现，了解 SpringBoot 自动配置的原理也是学习 SpringBoot 过程中不可绕开的重要内容</p><a id="more"></a><h1 id="从启动类开始说起"><a href="#从启动类开始说起" class="headerlink" title="从启动类开始说起"></a>从启动类开始说起</h1><p>​        要了解自动配置原理，我们首先要找到自动配置的入口，或者说是开关，学习过 SpringBoot 的同学都知道，当我们新建一个 SpringBoot 项目时，而这个空项目一定会包含一个<code>xxxxxxxxAutoconfigApplication.java</code>的类，这是 SpringBoot 的启动类，而这个类一定存在<code>@SpringBootApplication</code>这个注解，那似乎就说明了这个注解和自动配置一定存在某些关系</p><p><img src="https://img-blog.csdnimg.cn/20200329234802441.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>​        我们<code>ctrl + 左键</code>进入这个注解，会发现这是一个复合注解，一个很明显的名字<code>@EnableAutoConfiguration</code>启用自动配置就在其中，那很明显了，这个注解就是我们自动配置的开关所在，我们再进入这个注解</p><p><img src="https://img-blog.csdnimg.cn/20200329234834722.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>​        随后我们会发现，<code>@EnableAutoConfiguration</code>是一个很简单的配置类，我们可以看到它存在一个<code>@Import(AutoConfigurationImportSelector.class)</code>注解，在使用注解配置 Spring 时，我们知道<code>@Import</code>注解是用来定义子配置文件的，并且从它导入的子配置类的名称（自动配置导入选择器）我们可以确定，有关自动配置的核心代码就在这个子配置类中</p><p>​        通过查看这个类我们可以发现，SpringBoot 在<code>selectImports</code>方法中，通过调用同类下的<code>getAutoConfigurationEntry</code>方法来获取所谓的自动配置条目，那我们就继续来看一下这个方法</p><p>​        <img src="https://img-blog.csdnimg.cn/20200329234859267.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>​        这个方法中，我们可以注意到有一个<code>configurations</code>的变量，很明显，这是一个包含了配置的集合，这样我们就又找到了一个<code>getCandidateConfigurations</code>（得到候选的配置）方法，而在这个方法中，SpringBoot 又调用了<code>SpringFactoriesLoader.loadFactoryNames</code>，看起来我们离最最核心的代码越来越近了！点它！</p><p><img src="https://img-blog.csdnimg.cn/20200329234926292.jpg#pic_center" alt></p><p>​        这时我们来到了<code>SpringFactoriesLoader.java</code>，在这个类中我们找到了<code>loadFactoryNames</code>方法，发现它关联了<code>loadSpringFactories</code>方法，这个方法中又一大坨代码</p><p>​        <img src="https://img-blog.csdnimg.cn/20200329234955614.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>​        我们可以看到，在<code>loadSpringFactories</code>这个方法中，SpringBoot 从<code>FACTORIES_RESOURCE_LOCATION</code>中获取值，通过获取到的值，将其中所有的条目都放入配置中，我们看一下这个值是个什么东西</p><p>​        <img src="https://img-blog.csdnimg.cn/20200329235012950.jpg#pic_center" alt></p><p>​        终于一坨一坨的代码变成了一个字符串，原来，SpringBoot 是从具有<code>&quot;META-INF/spring.factories&quot;</code>目录的 jar 包下获取自动配置资源的，我们找到<code>spring-boot-auto-configure</code>这个 jar 包，就会在它的目录下找到一个上述的路径，并找到<code>spring.factories</code>文件</p><p><img src="https://img-blog.csdnimg.cn/20200329235037968.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70#pic_center" alt></p><p>​        从上边的图片可以看到，这个文件中包含了很多什么什么自动配置类，原来，SpringBoot 把很多常用配置都已经编写成自动配置类，在启动项目时，SpringBoot 会通过扫描这个配置文件，获取到所有的自动配置类并加载到 Spring 容器中供我们使用</p><p>​        那么自动配置类是如何被使用的呢？今天有点困了，下一篇再更！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SpringBoot-自动配置原理&quot;&gt;&lt;a href=&quot;#SpringBoot-自动配置原理&quot; class=&quot;headerlink&quot; title=&quot;SpringBoot 自动配置原理&quot;&gt;&lt;/a&gt;SpringBoot 自动配置原理&lt;/h1&gt;&lt;p&gt;​        作为 SpringBoot 的精髓，自动配置是“习惯优于配置”理念的体现，了解 SpringBoot 自动配置的原理也是学习 SpringBoot 过程中不可绕开的重要内容&lt;/p&gt;
    
    </summary>
    
    
      <category term="SpringBoot" scheme="http://yoursite.com/tags/SpringBoot/"/>
    
  </entry>
  
  <entry>
    <title>算法——简单理解并查集</title>
    <link href="http://yoursite.com/2020/03/27/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3%E5%B9%B6%E6%9F%A5%E9%9B%86/"/>
    <id>http://yoursite.com/2020/03/27/算法——简单理解并查集/</id>
    <published>2020-03-27T02:46:34.000Z</published>
    <updated>2020-03-27T03:13:58.962Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是并查集"><a href="#什么是并查集" class="headerlink" title="什么是并查集"></a>什么是并查集</h1><p>​        并查集是一种树形的数据结构，，用于处理一些不想交集合的合并即查询问题，我们可以通过并查集以接近<code>O(1)</code>的时间完成两个不相交集合的合并，并且以<code>O(1)</code>的时间判断一个元素属于哪个集合</p><a id="more"></a><h1 id="理解并查集"><a href="#理解并查集" class="headerlink" title="理解并查集"></a>理解并查集</h1><p>​        假设我们有<code>[1, 2, 3, 4, 5]</code>和<code>[6, 7, 8, 9]</code>两个集合，以并查集的思想，我们要以如下方式存储它</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1    6</span><br><span class="line">|    |</span><br><span class="line">2    7</span><br><span class="line">|    |</span><br><span class="line">3    8</span><br><span class="line">|    |</span><br><span class="line">4    9</span><br><span class="line">|</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>​        这实际上是两个每个节点只包含一个子节点的树状结构，这样树的根节点即表示集合的名称，而树种所有的叶子节点都存在唯一的一个根节点，我们可以根据这个性质来判断某个元素是否属于一个集合</p><p>​        那么我们如何实现两个集合的合并呢，如果是普通的使用数组存储的集合的话，我们一定需要将其中一个数组整个复制进另一个数组中，这需要很大的时间，并且我们还需要考虑数组的容量问题，如果使用并查集，我们只需要将一个集合的根节点接在另一个集合中，集合完成两个集合的合并，如下图</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1————6</span><br><span class="line">|    |</span><br><span class="line">2    7</span><br><span class="line">|    |</span><br><span class="line">3    8</span><br><span class="line">|    |</span><br><span class="line">4    9</span><br><span class="line">|</span><br><span class="line">5</span><br></pre></td></tr></table></figure><p>​        这就是使用并查集存储不想交集合以及实现集合合并和查询元素是否属于某集合的方法</p><h1 id="并查集的优化"><a href="#并查集的优化" class="headerlink" title="并查集的优化"></a>并查集的优化</h1><p>​        通过上述的过程，我们发现合并两个集合的操作十分简单，但是判断一个元素是否属于某个集合的过程显得十分复杂，我们需要从一个叶子节点一直回溯到根节点来判断它是否属于一个集合，针对这个问题有一种非常巧妙的优化方式——路径压缩</p><p>​        我们发现，并查集实际上是一颗并不规则的树，它的结构不是固定的，每个节点原则上可以拥有无数个节点，所以如果我们将一个集合中的所有元素都直接和根节点连接，那么通过叶子节点找到根节点的回溯过程就会减少很多时间，如下图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">   2</span><br><span class="line">   |</span><br><span class="line">5——1——3</span><br><span class="line">   |</span><br><span class="line">   4</span><br></pre></td></tr></table></figure><p>​        这样我们找到一个节点的时间就近乎可以压缩到<code>O(1)</code>了</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>​        在代码中，我们使用<code>find</code>函数来实现找到元素所在的集合及路径压缩，我们使用<code>p[x]</code>来表示<code>x</code>属于哪个集合</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> p[N];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回集合名称并实现路径压缩</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (p[x] != x) p[x] = find(p[x]);</span><br><span class="line">    <span class="keyword">return</span> p[x];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) p[i] = i;</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">char</span> op[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> a, b;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%s%d%d"</span>, op, &amp;a, &amp;b);</span><br><span class="line">        <span class="comment">// 合并操作</span></span><br><span class="line">        <span class="keyword">if</span>(op[<span class="number">0</span>] == <span class="string">'M'</span>) p[find(a)] = find(b);</span><br><span class="line">        <span class="comment">// 查询操作</span></span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (find(a) == find(b)) <span class="built_in">puts</span>(<span class="string">"Yes"</span>);</span><br><span class="line">            <span class="keyword">else</span> <span class="built_in">puts</span>(<span class="string">"No"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是并查集&quot;&gt;&lt;a href=&quot;#什么是并查集&quot; class=&quot;headerlink&quot; title=&quot;什么是并查集&quot;&gt;&lt;/a&gt;什么是并查集&lt;/h1&gt;&lt;p&gt;​        并查集是一种树形的数据结构，，用于处理一些不想交集合的合并即查询问题，我们可以通过并查集以接近&lt;code&gt;O(1)&lt;/code&gt;的时间完成两个不相交集合的合并，并且以&lt;code&gt;O(1)&lt;/code&gt;的时间判断一个元素属于哪个集合&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（面试题4-1）——二维数组中的查找</title>
    <link href="http://yoursite.com/2020/03/26/%E5%89%91%E6%8C%87Offer%EF%BC%88%E9%9D%A2%E8%AF%95%E9%A2%984-1%EF%BC%89%E2%80%94%E2%80%94%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2020/03/26/剑指Offer（面试题4-1）——二维数组中的查找/</id>
    <published>2020-03-26T14:12:24.000Z</published>
    <updated>2020-03-26T14:30:23.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer——面试题-4-1"><a href="#剑指-Offer——面试题-4-1" class="headerlink" title="剑指 Offer——面试题 4-1"></a>剑指 Offer——面试题 4-1</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。</p><p>请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。</p><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">输入数组：</span><br><span class="line"></span><br><span class="line">[</span><br><span class="line">  [1,2,8,9]，</span><br><span class="line">  [2,4,9,12]，</span><br><span class="line">  [4,7,10,13]，</span><br><span class="line">  [6,8,11,15]</span><br><span class="line">]</span><br><span class="line"></span><br><span class="line">如果输入查找数值为7，则返回true，</span><br><span class="line"></span><br><span class="line">如果输入查找数值为5，则返回false。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​        首先这道题如果使用暴力做法，遍历数组的每个元素来进行查找的话，时间复杂度为<code>O(n²)</code>，这显然不是一个精妙的解法，我们要通过一些特殊的性质，来减少我们需要访问的元素个数</p><p>​        怎么做呢，我们可以看到，整个二维数组是<strong>每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序</strong>，这是一条很重要的性质，也就是说，每一列的第一个元素是整列中最小的，每一行的第一个元素也是整行中最小的，我们可以从这个数组的右上角开始检测，如果右上角的元素大于<code>target</code>，我们就可以直接排除掉最右边的一列，因为<code>target &lt; 右上角元素 &lt; 最右边的一列中其他元素</code>，而如果右上角元素大于<code>target</code>，那么我们就可以删除最上边的一行，因为有<code>target &gt; 右上角元素 &gt; 第一行中的其他元素</code>，根据这个性质，我们可以每次去除二维数组的一行或者是一列，这样可以大大缩减我们查找所消耗的时间，下面看代码</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">searchArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; <span class="built_in">array</span>, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">array</span>.size() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> j = <span class="built_in">array</span>[<span class="number">0</span>].size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; <span class="built_in">array</span>.size() &amp;&amp; j &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[i][j] == target)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[i][j] &gt; target) --j;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">array</span>[i][j] &lt; target) ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">searchArray</span><span class="params">(<span class="keyword">int</span>[][] array, <span class="keyword">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (array.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = array[<span class="number">0</span>].length - <span class="number">1</span>; i &lt; array.length &amp;&amp; j &gt;= <span class="number">0</span>;) &#123;</span><br><span class="line">            <span class="keyword">if</span> (array[i][j] == target) <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">            <span class="keyword">if</span> (array[i][j] &gt; target) --j;</span><br><span class="line">            <span class="keyword">else</span> ++i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指-Offer——面试题-4-1&quot;&gt;&lt;a href=&quot;#剑指-Offer——面试题-4-1&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer——面试题 4-1&quot;&gt;&lt;/a&gt;剑指 Offer——面试题 4-1&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;在一个二维数组中，每一行都按照从左到右递增的顺序排序，每一列都按照从上到下递增的顺序排序。&lt;/p&gt;
&lt;p&gt;请完成一个函数，输入这样的一个二维数组和一个整数，判断数组中是否含有该整数。&lt;/p&gt;
&lt;h4 id=&quot;样例&quot;&gt;&lt;a href=&quot;#样例&quot; class=&quot;headerlink&quot; title=&quot;样例&quot;&gt;&lt;/a&gt;样例&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入数组：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;[&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [1,2,8,9]，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [2,4,9,12]，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [4,7,10,13]，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  [6,8,11,15]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果输入查找数值为7，则返回true，&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;如果输入查找数值为5，则返回false。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>算法——使用单调队列解决滑动窗口问题</title>
    <link href="http://yoursite.com/2020/03/25/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E5%8D%95%E8%B0%83%E9%98%9F%E5%88%97%E8%A7%A3%E5%86%B3%E6%BB%91%E5%8A%A8%E7%AA%97%E5%8F%A3%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/03/25/算法——使用单调队列解决滑动窗口问题/</id>
    <published>2020-03-25T14:05:31.000Z</published>
    <updated>2020-03-25T14:26:33.082Z</updated>
    
    <content type="html"><![CDATA[<h1 id="滑动窗口"><a href="#滑动窗口" class="headerlink" title="滑动窗口"></a>滑动窗口</h1><p>给定一个大小为<code>n≤106</code>的数组。</p><p>有一个大小为k的滑动窗口，它从数组的最左边移动到最右边。</p><p>您只能在窗口中看到<code>k</code>个数字。</p><p>每次滑动窗口向右移动一个位置。</p><p>以下是一个例子：</p><p>该数组为<code>[1 3 -1 -3 5 3 6 7]</code>，<code>k</code>为<code>3</code>。</p><table><thead><tr><th align="left">窗口位置</th><th align="left">最小值</th><th align="left">最大值</th></tr></thead><tbody><tr><td align="left">[1 3 -1] -3 5 3 6 7</td><td align="left">-1</td><td align="left">3</td></tr><tr><td align="left">1 [3 -1 -3] 5 3 6 7</td><td align="left">-3</td><td align="left">3</td></tr><tr><td align="left">1 3 [-1 -3 5] 3 6 7</td><td align="left">-3</td><td align="left">5</td></tr><tr><td align="left">1 3 -1 [-3 5 3] 6 7</td><td align="left">-3</td><td align="left">5</td></tr><tr><td align="left">1 3 -1 -3 [5 3 6] 7</td><td align="left">3</td><td align="left">6</td></tr><tr><td align="left">1 3 -1 -3 5 [3 6 7]</td><td align="left">3</td><td align="left">7</td></tr></tbody></table><p>您的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。</p><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>输入包含两行。</p><p>第一行包含两个整数<code>n</code>和<code>k</code>，分别代表数组长度和滑动窗口的长度。</p><p>第二行有<code>n</code>个整数，代表数组的具体数值。</p><p>同行数据之间用空格隔开。</p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出包含两个。</p><p>第一行输出，从左至右，每个位置滑动窗口中的最小值。</p><p>第二行输出，从左至右，每个位置滑动窗口中的最大值。</p><h4 id="输入样例："><a href="#输入样例：" class="headerlink" title="输入样例："></a>输入样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">8 3</span><br><span class="line">1 3 -1 -3 5 3 6 7</span><br></pre></td></tr></table></figure><h4 id="输出样例："><a href="#输出样例：" class="headerlink" title="输出样例："></a>输出样例：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-1 -3 -3 -3 3 3</span><br><span class="line">3 3 5 5 6 7</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="使用单调队列解决滑动窗口问题"><a href="#使用单调队列解决滑动窗口问题" class="headerlink" title="使用单调队列解决滑动窗口问题"></a>使用单调队列解决滑动窗口问题</h1><p>​        通过读题，我们可以简单描述为有一个长度为<code>n</code>的数组<code>a[n]</code>，给定一个长度为<code>k</code>的“窗口”，<code>a[n]</code>会从头开始依次经过这个窗口，我们需要求的是数组从第<code>k - 1</code>个元素开始，也就是窗口第一次被填满时开始一直到数组结尾，每一次窗口中的值被更新后的最大值和最小值</p><p>​        不难发现，这个窗口是一个从尾部进入，头部出去的模型，那很容易联想到先入先出的数据结构——队列，我们可以假设这个窗口就是一个队列，每次数组元素会从队尾入队，当窗口被填满后，当前的队头元素要出队，我们维护这样一个长度为<code>k</code>的队列，每次求出它的最大值和最小值即可</p><h2 id="使用单调队列优化"><a href="#使用单调队列优化" class="headerlink" title="使用单调队列优化"></a>使用单调队列优化</h2><p>​        然后即便我们想到使用队列进行求解，这个问题还是显得十分复杂，我们怎样简化它呢？答案就是使用单调队列</p><p>​        单调队列即队列中的元素满足单调递增或递减的性质，保证队头队尾元素是队列的最大值或最小值，因为从模拟这道题的过程我们可以得出，假设在求窗口中的最小值时，数组存在<code>[..., 3, -1, 0, ...]</code>这样一段序列，当<code>3</code>入队时，它可能是当前队中最小的元素，但当窗口再一次向后移动时，<code>-1</code>进入队列，此时无论如何<code>3</code>都不会再被当成最小值输出，因为<code>-1</code>一定会在<code>3</code>之后出队，所以这时<code>3</code>就没有必要再存在于队中，我们将它排除，如此循环，使得每次入队的元素一定大于前面的元素，我们就可以得到一个单调递增的队列，此时求最小值，我们直需要返回队头元素即可</p><p>​        以上是最小值，求最大值时我们只需要改变元素入队时的判断条件，即可改变单调队列的单调性，使队头元素变成最大值，下面是代码</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1000010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[N], a[N];</span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;k);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">int</span> hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 最小值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) ++hh;</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &gt;= a[i]) --tt;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">""</span>);</span><br><span class="line">    hh = <span class="number">0</span>, tt = <span class="number">-1</span>;</span><br><span class="line">    <span class="comment">// 最大值</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span>(hh &lt;= tt &amp;&amp; i - k + <span class="number">1</span> &gt; q[hh]) ++hh;</span><br><span class="line">        <span class="keyword">while</span> (hh &lt;= tt &amp;&amp; a[q[tt]] &lt;= a[i]) --tt;</span><br><span class="line">        q[++tt] = i;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= k - <span class="number">1</span>) <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[q[hh]]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这里我们使用 <code>q[N]</code>来表示滑动窗口中数组元素的下标，这样更方便我们对队列进行操作</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;滑动窗口&quot;&gt;&lt;a href=&quot;#滑动窗口&quot; class=&quot;headerlink&quot; title=&quot;滑动窗口&quot;&gt;&lt;/a&gt;滑动窗口&lt;/h1&gt;&lt;p&gt;给定一个大小为&lt;code&gt;n≤106&lt;/code&gt;的数组。&lt;/p&gt;
&lt;p&gt;有一个大小为k的滑动窗口，它从数组的最左边移动到最右边。&lt;/p&gt;
&lt;p&gt;您只能在窗口中看到&lt;code&gt;k&lt;/code&gt;个数字。&lt;/p&gt;
&lt;p&gt;每次滑动窗口向右移动一个位置。&lt;/p&gt;
&lt;p&gt;以下是一个例子：&lt;/p&gt;
&lt;p&gt;该数组为&lt;code&gt;[1 3 -1 -3 5 3 6 7]&lt;/code&gt;，&lt;code&gt;k&lt;/code&gt;为&lt;code&gt;3&lt;/code&gt;。&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th align=&quot;left&quot;&gt;窗口位置&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;最小值&lt;/th&gt;
&lt;th align=&quot;left&quot;&gt;最大值&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;[1 3 -1] -3 5 3 6 7&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;-1&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;1 [3 -1 -3] 5 3 6 7&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;-3&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;3&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;1 3 [-1 -3 5] 3 6 7&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;-3&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;1 3 -1 [-3 5 3] 6 7&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;-3&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;5&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;1 3 -1 -3 [5 3 6] 7&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;6&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td align=&quot;left&quot;&gt;1 3 -1 -3 5 [3 6 7]&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;3&lt;/td&gt;
&lt;td align=&quot;left&quot;&gt;7&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;p&gt;您的任务是确定滑动窗口位于每个位置时，窗口中的最大值和最小值。&lt;/p&gt;
&lt;h4 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title=&quot;输入格式&quot;&gt;&lt;/a&gt;输入格式&lt;/h4&gt;&lt;p&gt;输入包含两行。&lt;/p&gt;
&lt;p&gt;第一行包含两个整数&lt;code&gt;n&lt;/code&gt;和&lt;code&gt;k&lt;/code&gt;，分别代表数组长度和滑动窗口的长度。&lt;/p&gt;
&lt;p&gt;第二行有&lt;code&gt;n&lt;/code&gt;个整数，代表数组的具体数值。&lt;/p&gt;
&lt;p&gt;同行数据之间用空格隔开。&lt;/p&gt;
&lt;h4 id=&quot;输出格式&quot;&gt;&lt;a href=&quot;#输出格式&quot; class=&quot;headerlink&quot; title=&quot;输出格式&quot;&gt;&lt;/a&gt;输出格式&lt;/h4&gt;&lt;p&gt;输出包含两个。&lt;/p&gt;
&lt;p&gt;第一行输出，从左至右，每个位置滑动窗口中的最小值。&lt;/p&gt;
&lt;p&gt;第二行输出，从左至右，每个位置滑动窗口中的最大值。&lt;/p&gt;
&lt;h4 id=&quot;输入样例：&quot;&gt;&lt;a href=&quot;#输入样例：&quot; class=&quot;headerlink&quot; title=&quot;输入样例：&quot;&gt;&lt;/a&gt;输入样例：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;8 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1 3 -1 -3 5 3 6 7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;输出样例：&quot;&gt;&lt;a href=&quot;#输出样例：&quot; class=&quot;headerlink&quot; title=&quot;输出样例：&quot;&gt;&lt;/a&gt;输出样例：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;-1 -3 -3 -3 3 3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3 3 5 5 6 7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>动态规划（一）——从爬楼梯问题简单理解dp</title>
    <link href="http://yoursite.com/2020/03/24/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%EF%BC%88%E4%B8%80%EF%BC%89%E2%80%94%E2%80%94%E4%BB%8E%E7%88%AC%E6%A5%BC%E6%A2%AF%E9%97%AE%E9%A2%98%E7%AE%80%E5%8D%95%E7%90%86%E8%A7%A3dp/"/>
    <id>http://yoursite.com/2020/03/24/动态规划（一）——从爬楼梯问题简单理解dp/</id>
    <published>2020-03-24T14:25:29.000Z</published>
    <updated>2020-03-24T15:12:39.965Z</updated>
    
    <content type="html"><![CDATA[<h1 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h1><p>​        今天来谈一谈我对动态规划的理解，我也是初学者，这里只是通过爬楼梯这道简单的问题，介绍一下动态规划的核心思想和基于这道题的 DP 分析</p><a id="more"></a><h1 id="dp-思想"><a href="#dp-思想" class="headerlink" title="dp 思想"></a>dp 思想</h1><p>​        动态规划（一下简称 dp）是一种将多个阶段的问题分解成一系列单阶段问题，通过总结各阶段之间的关系得到所谓的状态转换方程，从而解决问题</p><p>​        dp 算法不同于二分、快排、双指针等算法，存在一个大致的模板，dp 问题因为问题要求不尽相同，推导 dp 方程的过程也不尽相同，但是我们还是可以总结一个答题流程，这里借鉴<code>AcWing</code>闫学灿老师的<code>闫氏 DP 分析法</code></p><h1 id="通过爬楼梯问题来理解-dp"><a href="#通过爬楼梯问题来理解-dp" class="headerlink" title="通过爬楼梯问题来理解 dp"></a>通过爬楼梯问题来理解 dp</h1><p>​        先看题目</p><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>​        假设你正在爬楼梯，需要<code>n</code>阶才能到达楼顶，每次你可以爬<code>1</code>或<code>2</code>个台阶，我们有多少种方法可以到达楼顶呢？（<code>n</code>是一个整数）</p><h2 id="dp-思路"><a href="#dp-思路" class="headerlink" title="dp 思路"></a>dp 思路</h2><p>​        dp 问题虽然没有固定的模板，但是我们可以根据经验总结出一个解题的思路，经过总结，我们认为 dp 问题分为<strong>状态表示</strong>和<strong>状态计算</strong>两步，我们依次说明</p><p>​        我们需要根据一个问题，抽象出一个结果的集合，假设为<code>dp[i]</code>，它用来表示<code>到达第 i 个台阶的方法数</code>，这是一个化整为零的过程，我们称为状态表示，<code>dp[i]</code>所表示的含义我们称之为它的属性</p><p>​        随后，我们要通过总结<code>dp[i]</code>的特点或者性质，给<code>dp[i]</code>进行划分，这里划分的依据通常是<strong>寻找最后一个不同点</strong>，那么这个问题的划分点是哪里呢，很明显是<strong>还有<code>1</code>步到第<code>i</code>阶</strong>和<strong>还有<code>2</code>步到第<code>i</code>阶</strong>，这里划分时我们需要注意，我们划分的区间应该包含所有可能存在的情况，并且每个区间都会重复，划分后，我们要通过<code>dp[i]</code>去表示两个区间，很简单，前者是<code>dp[i - 1]</code>，后者是<code>dp[i - 2]</code>，到这里，这道题的思路就很明确了，因为我们已经得到了它的 dp 方程：<code>dp[i] = dp[i - 1] + dp[i - 2]</code>，我们只需要用代码来实现即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">dp</span><span class="params">(<span class="keyword">int</span> stairs)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (stairs == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> dp[stairs + <span class="number">1</span>];</span><br><span class="line">    dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">    dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">3</span>; i &lt;= stairs; ++i) dp[i] = dp[i - <span class="number">2</span>] + dp[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">return</span> dp[stairs];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;动态规划&quot;&gt;&lt;a href=&quot;#动态规划&quot; class=&quot;headerlink&quot; title=&quot;动态规划&quot;&gt;&lt;/a&gt;动态规划&lt;/h1&gt;&lt;p&gt;​        今天来谈一谈我对动态规划的理解，我也是初学者，这里只是通过爬楼梯这道简单的问题，介绍一下动态规划的核心思想和基于这道题的 DP 分析&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法——前缀和及差分</title>
    <link href="http://yoursite.com/2020/03/23/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%89%8D%E7%BC%80%E5%92%8C%E5%8F%8A%E5%B7%AE%E5%88%86/"/>
    <id>http://yoursite.com/2020/03/23/算法——前缀和及差分/</id>
    <published>2020-03-23T08:11:59.000Z</published>
    <updated>2020-03-23T08:35:01.703Z</updated>
    
    <content type="html"><![CDATA[<h1 id="前缀和及差分"><a href="#前缀和及差分" class="headerlink" title="前缀和及差分"></a>前缀和及差分</h1><p>​        前缀和与差分是互为逆运算的两种计算方式，前缀和指的是一个数组是另一个数组中前<code>n</code>项元素之和，而差分指的是一个数组的前<code>n</code>项的和是另一个数组</p><p>​        实际上就是，如果数组<code>a</code>是数组<code>b</code>的前缀和，那<code>b</code>就是<code>a</code>的差分</p><a id="more"></a><h1 id="前缀和"><a href="#前缀和" class="headerlink" title="前缀和"></a>前缀和</h1><p>​        根据如上的的解释，我们可以理解为，假设有数组<code>a</code>为<code>[1, 2, 3, 4, 5]</code>那么代表它的前缀和数组的数组<code>b</code>就是<code>1, 3, 6, 10, 15</code>，也就是说，<code>a[n] = b[1] + b[2] + ... + b[n - 1] + b[n]</code>，这里我们假设数组是从下标<code>1</code>开始的，这样我们可以减去一步繁琐的判断</p><p>​        通过前缀和，我们可以快速的求出原数组从<code>l</code>到<code>r</code>的区间中元素的和，等于<code>S[l ~ r] = b[r] - b[l - 1]</code>，有如下代码:</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">1e5</span> + <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">int</span> a[N], s[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) s[i]= s[i - <span class="number">1</span>] + a[i];</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;l, &amp;r);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d\n"</span>, s[r] - s[l - <span class="number">1</span>]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="差分"><a href="#差分" class="headerlink" title="差分"></a>差分</h1><p>​        作为前缀和的逆运算，差分可以理解为有算数组<code>a</code>，它的差分数组<code>b</code>有如下关系</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a[1] = b[1]</span><br><span class="line">a[2] = b[1] + b[2]</span><br><span class="line">a[3] = b[1] + b[2] + b[3]</span><br><span class="line">...</span><br><span class="line">a[n - 1] = b[1] + b[2] + b[3] + ... + b[n - 2] + b[n - 1]</span><br><span class="line">a[n] = b[1] + b[2] + b[3] + ... + b[n - 2] + b[n - 1] + b[n]</span><br></pre></td></tr></table></figure><p>​        由此可见，如果<code>b</code>是<code>a</code>的差分数组，那<code>a</code>就是<code>b</code>的前缀和数组，通过差分，我们可以快速的实现对一个区间内的所有元素的同增同减操作</p><p>​        假设我们要让<code>a[2]</code>到<code>a[6]</code>的元素全部<code>+1</code>，我们只需要让<code>b[2] += 1</code>，<code>b[7] -= 1</code>即可，代码如下</p><h2 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N], b[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">"%d%d"</span>, &amp;n, &amp;m);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) <span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;a[i]);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) b[i] = a[i] - a[i - <span class="number">1</span>];</span><br><span class="line">    <span class="keyword">while</span> (m--) &#123;</span><br><span class="line">        <span class="keyword">int</span> l, r, c;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">"%d%d%d"</span>, &amp;l, &amp;r, &amp;c);</span><br><span class="line">        b[l] += c;</span><br><span class="line">        b[r + <span class="number">1</span>] -= c;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; ++i) &#123;</span><br><span class="line">        a[i] = a[i - <span class="number">1</span>] + b[i];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, a[i]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;前缀和及差分&quot;&gt;&lt;a href=&quot;#前缀和及差分&quot; class=&quot;headerlink&quot; title=&quot;前缀和及差分&quot;&gt;&lt;/a&gt;前缀和及差分&lt;/h1&gt;&lt;p&gt;​        前缀和与差分是互为逆运算的两种计算方式，前缀和指的是一个数组是另一个数组中前&lt;code&gt;n&lt;/code&gt;项元素之和，而差分指的是一个数组的前&lt;code&gt;n&lt;/code&gt;项的和是另一个数组&lt;/p&gt;
&lt;p&gt;​        实际上就是，如果数组&lt;code&gt;a&lt;/code&gt;是数组&lt;code&gt;b&lt;/code&gt;的前缀和，那&lt;code&gt;b&lt;/code&gt;就是&lt;code&gt;a&lt;/code&gt;的差分&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Spring框架——@Autowired注解用法详解</title>
    <link href="http://yoursite.com/2020/03/22/Spring%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94Autowired%E6%B3%A8%E8%A7%A3%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2020/03/22/Spring框架——Autowired注解用法详解/</id>
    <published>2020-03-22T00:38:03.000Z</published>
    <updated>2020-03-22T03:02:35.262Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Spring-框架中的-Autowired-注解"><a href="#Spring-框架中的-Autowired-注解" class="headerlink" title="Spring 框架中的 @Autowired 注解"></a>Spring 框架中的 @Autowired 注解</h1><p>​        在使用注解进行 Spring 项目的开发时，我们经常会用到<code>Autowired</code>注解，它可以对类成员变量、方法及构造函数进行标注，完成<code>IOC</code>容器自动装配的工作</p><a id="more"></a><h2 id="如何使用"><a href="#如何使用" class="headerlink" title="如何使用"></a>如何使用</h2><p>​        首先我们根据<code>service</code>调取<code>dao</code>层方法的概念，构建<code>dao</code>层和<code>service</code>层</p><p>​        <code>dao</code>层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">PersonDao</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Repository</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonDaoImpl</span> <span class="keyword">implements</span> <span class="title">PersonDao</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"select"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        <code>service</code>层：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PersonService</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> PersonDao personDao;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">select</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        personDao.select();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        测试类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    PersonService personService = ioc.getBean(<span class="string">"personService"</span>, PersonService.class);</span><br><span class="line">    personService.select();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        以上代码运行结果就是控制台输出了 select 字符串，下面我们看看<code>@Autowired</code>注解是如何工作的</p><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>​        我们在<code>private PersonDao personDao</code>上添加<code>@Autowired</code>相当于在<code>&lt;bean id=&quot;personService&quot;&gt;</code>内配置了<code>&lt;property name=&quot;personDao&quot; ref=&quot;personDaoImpl&quot;/&gt;</code>，这个我们可以通过在<code>@Autowired</code>注解下添加一个<code>@Qualifier(&quot;personDaoImpl&quot;)</code>注解来证明</p><p>​        添加后，两种方式运行的代码结果是一样的，这就说明<code>PersonDaoImpl</code>被注入到 <code>IOC</code>容器中时的<code>bean id</code>是<code>personDaoImpl</code>，那为什么我们我们不使用<code>@Qualifier</code>注解同样能实现注入呢？</p><p>​        原因是<code>@Autowired</code>注解的匹配机制是<code>ByType</code>，它会首先匹配类型，并且会匹配子类型的父类或者接口，这是为什么每加<code>@Qualifier</code>注解时可以注入成功，而加上<code>@Qualifier</code>注解后，<code>@Autowired</code>的匹配模式变成了<code>ByName</code>，所以这时必须匹配<code>bean id</code>也就是<code>personDaoImpl</code>才可以注入成功！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Spring-框架中的-Autowired-注解&quot;&gt;&lt;a href=&quot;#Spring-框架中的-Autowired-注解&quot; class=&quot;headerlink&quot; title=&quot;Spring 框架中的 @Autowired 注解&quot;&gt;&lt;/a&gt;Spring 框架中的 @Autowired 注解&lt;/h1&gt;&lt;p&gt;​        在使用注解进行 Spring 项目的开发时，我们经常会用到&lt;code&gt;Autowired&lt;/code&gt;注解，它可以对类成员变量、方法及构造函数进行标注，完成&lt;code&gt;IOC&lt;/code&gt;容器自动装配的工作&lt;/p&gt;
    
    </summary>
    
    
      <category term="Spring 框架" scheme="http://yoursite.com/tags/Spring-%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>剑指Offer（面试题3-2）——不修改数组找出重复的数字</title>
    <link href="http://yoursite.com/2020/03/20/%E5%89%91%E6%8C%87Offer%EF%BC%88%E9%9D%A2%E8%AF%95%E9%A2%983-2%EF%BC%89%E2%80%94%E2%80%94%E4%B8%8D%E4%BF%AE%E6%94%B9%E6%95%B0%E7%BB%84%E6%89%BE%E5%87%BA%E9%87%8D%E5%A4%8D%E7%9A%84%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/03/20/剑指Offer（面试题3-2）——不修改数组找出重复的数字/</id>
    <published>2020-03-20T14:43:56.000Z</published>
    <updated>2020-03-20T15:07:03.739Z</updated>
    
    <content type="html"><![CDATA[<h1 id="剑指-Offer——面试题-3-2"><a href="#剑指-Offer——面试题-3-2" class="headerlink" title="剑指 Offer——面试题 3-2"></a>剑指 Offer——面试题 3-2</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>不修改数组找出重复的数字</p><p>在一个长度位<code>n + 1</code>的数组里的所有数字都在<code>1 ~ n</code>的范围内，所以数组中至少有一个数字是重复的，请找出数组中任意一个重复的数字，但不能修改输入的数组</p><h4 id="输入样例"><a href="#输入样例" class="headerlink" title="输入样例"></a>输入样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[2, 3, 5, 4, 3, 2, 6, 7]</span><br></pre></td></tr></table></figure><h4 id="输出样例"><a href="#输出样例" class="headerlink" title="输出样例"></a>输出样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">2 或 3</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​        这道题比较特殊的点就是不允许改变输入数组，如果不改变输入数组的话，我们就不能对数组进行排序，也不能交换数组元素，所以面试题 3-2 中的方法就不能用了</p><p>​        那我们如何找到数组中的重复元素呢？可以考虑二分的思想</p><p>​        因为数组是从<code>1 ~ n</code>的长度为<code>n + 1</code>的数组，所以数组中一定存在重复元素，我们先取数组的值的中点<code>mind = 1 + n &gt;&gt; 1</code>，随后我们统计数组中<code>&lt;= mid</code>的元素个数，如果数量大于<code>mid - l（左边界）</code>，说明重复元素在左边，否则说明重复元素在右边，不断的二分，我们最后就会找到这个重复出现的元素！代码如下：</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">duplicateInArray</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> l = <span class="number">1</span>, r = nums.size() - <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums) &#123;</span><br><span class="line">    <span class="keyword">if</span> (num &lt;= mid &amp;&amp; num &gt;= l) ++s;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (s &gt; (mid - l + <span class="number">1</span>)) r = mid;</span><br><span class="line">    <span class="keyword">else</span> l = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;剑指-Offer——面试题-3-2&quot;&gt;&lt;a href=&quot;#剑指-Offer——面试题-3-2&quot; class=&quot;headerlink&quot; title=&quot;剑指 Offer——面试题 3-2&quot;&gt;&lt;/a&gt;剑指 Offer——面试题 3-2&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;不修改数组找出重复的数字&lt;/p&gt;
&lt;p&gt;在一个长度位&lt;code&gt;n + 1&lt;/code&gt;的数组里的所有数字都在&lt;code&gt;1 ~ n&lt;/code&gt;的范围内，所以数组中至少有一个数字是重复的，请找出数组中任意一个重复的数字，但不能修改输入的数组&lt;/p&gt;
&lt;h4 id=&quot;输入样例&quot;&gt;&lt;a href=&quot;#输入样例&quot; class=&quot;headerlink&quot; title=&quot;输入样例&quot;&gt;&lt;/a&gt;输入样例&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;[2, 3, 5, 4, 3, 2, 6, 7]&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;输出样例&quot;&gt;&lt;a href=&quot;#输出样例&quot; class=&quot;headerlink&quot; title=&quot;输出样例&quot;&gt;&lt;/a&gt;输出样例&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;2 或 3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试题——移掉k位数字</title>
    <link href="http://yoursite.com/2020/03/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E2%80%94%E7%A7%BB%E6%8E%89k%E4%BD%8D%E6%95%B0%E5%AD%97/"/>
    <id>http://yoursite.com/2020/03/19/面试题——移掉k位数字/</id>
    <published>2020-03-19T07:31:46.000Z</published>
    <updated>2020-03-19T08:27:48.109Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-1453-移掉-k-位数字"><a href="#AcWing-1453-移掉-k-位数字" class="headerlink" title="AcWing 1453 移掉 k 位数字"></a>AcWing 1453 移掉 k 位数字</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个以字符串表示的非负整数<code>num</code>，移除这个数中的<code>k</code>位数字，使得剩下的数字最小</p><p><strong>注意：</strong></p><ul><li>空字符串被视为<code>0</code></li><li>如果结果中包含前导零，则需要将前导零删除，最后删除的前导零不用包含在移除的<code>k</code>个数字中</li></ul><h4 id="输入格式"><a href="#输入格式" class="headerlink" title="输入格式"></a>输入格式</h4><p>第一行输入一个字符串，用来表示非负整数<code>num</code></p><p>第二行输入一个整数，表示<code>k</code></p><h4 id="输出格式"><a href="#输出格式" class="headerlink" title="输出格式"></a>输出格式</h4><p>输出一个字符串，表示移除<code>k</code>位数字后所能得到的最小数字</p><h4 id="数据范围"><a href="#数据范围" class="headerlink" title="数据范围"></a>数据范围</h4><p><code>0≤k≤</code>字符串长度<code>≤100000</code><br><code>num</code>中不包含任何前导<code>0</code></p><h4 id="输入样例1："><a href="#输入样例1：" class="headerlink" title="输入样例1："></a>输入样例1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">1432219</span><br><span class="line">3</span><br></pre></td></tr></table></figure><h4 id="输出样例1："><a href="#输出样例1：" class="headerlink" title="输出样例1："></a>输出样例1：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1219</span><br></pre></td></tr></table></figure><h4 id="样例1解释"><a href="#样例1解释" class="headerlink" title="样例1解释"></a>样例1解释</h4><p>移除掉三个数字<code>4,3,2</code>可形成一个新的最小的数字<code>1219</code></p><h4 id="输入样例2："><a href="#输入样例2：" class="headerlink" title="输入样例2："></a>输入样例2：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10200</span><br><span class="line">1</span><br></pre></td></tr></table></figure><h4 id="输出样例2："><a href="#输出样例2：" class="headerlink" title="输出样例2："></a>输出样例2：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">200</span><br></pre></td></tr></table></figure><h4 id="样例2解释："><a href="#样例2解释：" class="headerlink" title="样例2解释："></a>样例2解释：</h4><p>移掉首位的<code>1</code>剩下的数字为<code>200</code>，注意<code>输出不能有任何前导零</code></p><h4 id="输入样例3："><a href="#输入样例3：" class="headerlink" title="输入样例3："></a>输入样例3：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10</span><br><span class="line">2</span><br></pre></td></tr></table></figure><h4 id="输出样例3："><a href="#输出样例3：" class="headerlink" title="输出样例3："></a>输出样例3：</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">0</span><br></pre></td></tr></table></figure><h4 id="样例3解释"><a href="#样例3解释" class="headerlink" title="样例3解释"></a>样例3解释</h4><p>从原数字移除所有的数字，剩余为空就是<code>0</code></p><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><p>​        这道题怎么解呢，首先我们考虑一种特殊情况，当原字符串中的每一位都是按字典序排列时，越小的数字排的越靠前，所以要是想移除<code>k</code>位得到最小数字，只需要移除最后<code>k</code>位即可</p><p>​        由此我们可以得到一个思路：将原字符串排序，移除后<code>k</code>位来获得最小数字，但是这里我们不考虑这种方法，接下来介绍另一种方法</p><p>​        有序的情况我们分析了，那无序的呢？假设字符串是<code>1, 5, 3, 2, 1</code>，我们要想移除<code>2</code>位来获得最小数字呢？</p><p>​        我们先正常遍历字符串，当遇到<code>nums[i] &gt; nums[i + 1]</code>的情况时，为了能使最后得到的数字最小，我们一定要移除排名更前且值更大的数字，因为从数字的角度看，越大且排名越前的数字对整个数字的大小影响越大，比如<code>190</code>一定大于<code>109</code></p><p>​        还有一个问题就是前导零的问题，我们当得到了最后的结果之后，从头遍历一下数组，用<code>i</code>记住前面有几个<code>0</code>最后返回时从<code>i</code>开始输出就好啦，下面是代码：</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">string</span> nums;</span><br><span class="line"><span class="keyword">int</span> k;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; nums &gt;&gt; k;</span><br><span class="line"><span class="built_in">string</span> res = <span class="string">"0"</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line"><span class="keyword">while</span> (k &amp;&amp; nums[i] &lt; res.back()) &#123;</span><br><span class="line">res.pop_back();</span><br><span class="line">k--;</span><br><span class="line">&#125;</span><br><span class="line">res += nums[i];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (k) &#123;</span><br><span class="line">res.pop_back();</span><br><span class="line">k--;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>; </span><br><span class="line"><span class="keyword">while</span> (res[i] == <span class="string">'0'</span>)</span><br><span class="line">i++;</span><br><span class="line"><span class="keyword">if</span> (i == res.size())</span><br><span class="line"><span class="built_in">puts</span>(<span class="string">"0"</span>);</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res.substr(i) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AcWing-1453-移掉-k-位数字&quot;&gt;&lt;a href=&quot;#AcWing-1453-移掉-k-位数字&quot; class=&quot;headerlink&quot; title=&quot;AcWing 1453 移掉 k 位数字&quot;&gt;&lt;/a&gt;AcWing 1453 移掉 k 位数字&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个以字符串表示的非负整数&lt;code&gt;num&lt;/code&gt;，移除这个数中的&lt;code&gt;k&lt;/code&gt;位数字，使得剩下的数字最小&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;注意：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;空字符串被视为&lt;code&gt;0&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;如果结果中包含前导零，则需要将前导零删除，最后删除的前导零不用包含在移除的&lt;code&gt;k&lt;/code&gt;个数字中&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;输入格式&quot;&gt;&lt;a href=&quot;#输入格式&quot; class=&quot;headerlink&quot; title=&quot;输入格式&quot;&gt;&lt;/a&gt;输入格式&lt;/h4&gt;&lt;p&gt;第一行输入一个字符串，用来表示非负整数&lt;code&gt;num&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;第二行输入一个整数，表示&lt;code&gt;k&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;输出格式&quot;&gt;&lt;a href=&quot;#输出格式&quot; class=&quot;headerlink&quot; title=&quot;输出格式&quot;&gt;&lt;/a&gt;输出格式&lt;/h4&gt;&lt;p&gt;输出一个字符串，表示移除&lt;code&gt;k&lt;/code&gt;位数字后所能得到的最小数字&lt;/p&gt;
&lt;h4 id=&quot;数据范围&quot;&gt;&lt;a href=&quot;#数据范围&quot; class=&quot;headerlink&quot; title=&quot;数据范围&quot;&gt;&lt;/a&gt;数据范围&lt;/h4&gt;&lt;p&gt;&lt;code&gt;0≤k≤&lt;/code&gt;字符串长度&lt;code&gt;≤100000&lt;/code&gt;&lt;br&gt;&lt;code&gt;num&lt;/code&gt;中不包含任何前导&lt;code&gt;0&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;输入样例1：&quot;&gt;&lt;a href=&quot;#输入样例1：&quot; class=&quot;headerlink&quot; title=&quot;输入样例1：&quot;&gt;&lt;/a&gt;输入样例1：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1432219&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;输出样例1：&quot;&gt;&lt;a href=&quot;#输出样例1：&quot; class=&quot;headerlink&quot; title=&quot;输出样例1：&quot;&gt;&lt;/a&gt;输出样例1：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1219&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;样例1解释&quot;&gt;&lt;a href=&quot;#样例1解释&quot; class=&quot;headerlink&quot; title=&quot;样例1解释&quot;&gt;&lt;/a&gt;样例1解释&lt;/h4&gt;&lt;p&gt;移除掉三个数字&lt;code&gt;4,3,2&lt;/code&gt;可形成一个新的最小的数字&lt;code&gt;1219&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;输入样例2：&quot;&gt;&lt;a href=&quot;#输入样例2：&quot; class=&quot;headerlink&quot; title=&quot;输入样例2：&quot;&gt;&lt;/a&gt;输入样例2：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;10200&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;输出样例2：&quot;&gt;&lt;a href=&quot;#输出样例2：&quot; class=&quot;headerlink&quot; title=&quot;输出样例2：&quot;&gt;&lt;/a&gt;输出样例2：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;200&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;样例2解释：&quot;&gt;&lt;a href=&quot;#样例2解释：&quot; class=&quot;headerlink&quot; title=&quot;样例2解释：&quot;&gt;&lt;/a&gt;样例2解释：&lt;/h4&gt;&lt;p&gt;移掉首位的&lt;code&gt;1&lt;/code&gt;剩下的数字为&lt;code&gt;200&lt;/code&gt;，注意&lt;code&gt;输出不能有任何前导零&lt;/code&gt;&lt;/p&gt;
&lt;h4 id=&quot;输入样例3：&quot;&gt;&lt;a href=&quot;#输入样例3：&quot; class=&quot;headerlink&quot; title=&quot;输入样例3：&quot;&gt;&lt;/a&gt;输入样例3：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;输出样例3：&quot;&gt;&lt;a href=&quot;#输出样例3：&quot; class=&quot;headerlink&quot; title=&quot;输出样例3：&quot;&gt;&lt;/a&gt;输出样例3：&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;0&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;h4 id=&quot;样例3解释&quot;&gt;&lt;a href=&quot;#样例3解释&quot; class=&quot;headerlink&quot; title=&quot;样例3解释&quot;&gt;&lt;/a&gt;样例3解释&lt;/h4&gt;&lt;p&gt;从原数字移除所有的数字，剩余为空就是&lt;code&gt;0&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
  <entry>
    <title>面试题——反转链表</title>
    <link href="http://yoursite.com/2020/03/19/%E9%9D%A2%E8%AF%95%E9%A2%98%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2020/03/19/面试题——反转链表/</id>
    <published>2020-03-19T07:11:19.000Z</published>
    <updated>2020-03-19T08:29:06.247Z</updated>
    
    <content type="html"><![CDATA[<h1 id="AcWing-35-反转链表"><a href="#AcWing-35-反转链表" class="headerlink" title="AcWing 35 反转链表"></a>AcWing 35 反转链表</h1><h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点</p><p><strong>思考题：</strong></p><ul><li>请同时实现迭代版本和递归版本</li></ul><h4 id="样例"><a href="#样例" class="headerlink" title="样例"></a>样例</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入:1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line"></span><br><span class="line">输出:5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="迭代版本"><a href="#迭代版本" class="headerlink" title="迭代版本"></a>迭代版本</h3><p>​        这道题使用迭代的思想很容易思考，我们只需要准备三个指针，分别是上一个节点<code>prev</code>、当前节点<code>curr</code>和<code>curr</code>的下一个节点<code>node</code></p><p>​        通过遍历整个链表，没到一个节点，我们先保存<code>curr.next</code>给<code>node</code>，再将<code>curr.next</code>赋给<code>prev</code>，也就改变了<code>curr</code>的指向，随后我们把<code>curr</code>和<code>prev</code>都后移一位即可（在原来的顺序上，因为我们已经保留了<code>node</code>），当<code>curr == null</code>时，说明链表已经到结尾了，我们返回<code>prev</code>即可</p><h3 id="递归版本"><a href="#递归版本" class="headerlink" title="递归版本"></a>递归版本</h3><p>​        递归版本如何思考呢，我们只需要思考一种情况，由于是递归实现，当递归到<code>head</code>节点时，我们需要递归函数返回的结果是一个从<code>head.next</code>开始已经被反转的链表，所以我们只需要将<code>head</code>接到链表的结尾，并将<code>head.next</code>指空即可</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><h3 id="c-迭代"><a href="#c-迭代" class="headerlink" title="c++ 迭代"></a>c++ 迭代</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">ListNode *prev = <span class="literal">NULL</span>, *cur = head;</span><br><span class="line"><span class="keyword">while</span> (cur) &#123;</span><br><span class="line"><span class="keyword">auto</span> node = cur-&gt;next;</span><br><span class="line">cur-&gt;next = prev;</span><br><span class="line">prev = cur;</span><br><span class="line">cur = node;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> prev;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="c-递归"><a href="#c-递归" class="headerlink" title="c++ 递归"></a>c++ 递归</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (!head || !head-&gt;next)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line"><span class="keyword">auto</span> tail = reverseList(head-&gt;next);</span><br><span class="line">head-&gt;next-&gt;next = head;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> tail;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="java-迭代"><a href="#java-迭代" class="headerlink" title="java 迭代"></a>java 迭代</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        ListNode prev = <span class="keyword">null</span>;</span><br><span class="line">        ListNode curr = head;</span><br><span class="line">        <span class="keyword">while</span> (curr != <span class="keyword">null</span>) &#123;</span><br><span class="line">            ListNode node = curr.next;</span><br><span class="line">            curr.next = prev;</span><br><span class="line">            prev = curr;</span><br><span class="line">            curr = node;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> prev;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="java-递归"><a href="#java-递归" class="headerlink" title="java 递归"></a>java 递归</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="keyword">null</span> || head.next == <span class="keyword">null</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        ListNode tail = head.next;</span><br><span class="line">        ListNode node = reverseList(head.next);</span><br><span class="line">        tail.next = head;</span><br><span class="line">        head.next = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;AcWing-35-反转链表&quot;&gt;&lt;a href=&quot;#AcWing-35-反转链表&quot; class=&quot;headerlink&quot; title=&quot;AcWing 35 反转链表&quot;&gt;&lt;/a&gt;AcWing 35 反转链表&lt;/h1&gt;&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;定义一个函数，输入一个链表的头结点，反转该链表并输出反转后链表的头结点&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;思考题：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;请同时实现迭代版本和递归版本&lt;/li&gt;
&lt;/ul&gt;
&lt;h4 id=&quot;样例&quot;&gt;&lt;a href=&quot;#样例&quot; class=&quot;headerlink&quot; title=&quot;样例&quot;&gt;&lt;/a&gt;样例&lt;/h4&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出:5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="面试题" scheme="http://yoursite.com/tags/%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    
  </entry>
  
</feed>
