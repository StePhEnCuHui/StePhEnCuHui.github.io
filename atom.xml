<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Step By Step</title>
  
  <subtitle>耀出千分光</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-12-29T03:45:10.939Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LiMinghui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JAVA基础——JVM之G1（Garbage First）垃圾回收器</title>
    <link href="http://yoursite.com/2019/12/29/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JVM%E4%B9%8BG1%EF%BC%88Garbage-First%EF%BC%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>http://yoursite.com/2019/12/29/JAVA基础——JVM之G1（Garbage-First）垃圾回收器/</id>
    <published>2019-12-29T02:16:26.000Z</published>
    <updated>2019-12-29T03:45:10.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Garbage-First-垃圾回收器"><a href="#Garbage-First-垃圾回收器" class="headerlink" title="Garbage First 垃圾回收器"></a>Garbage First 垃圾回收器</h1><h2 id="G1-简介"><a href="#G1-简介" class="headerlink" title="G1 简介"></a>G1 简介</h2><p>​        G1（Garbage First）垃圾回收器是最新的 JDK 中默认的垃圾回收器，也是垃圾回收技术最前沿的成果，它同时注重吞吐量（Throughput）和低延迟（Low Latency），默认的暂停目标是 200ms，适用于超大的堆内存</p><p>​        G1 引入了分区（region）的思想，弱化了分代的概念，它将堆内存分为大小相等的区，每个区的大约是 1248M，并且每个区都可以是 Eden、Survivor、Old 或者大对象区，G1 垃圾回收器在整体上使用了标记整理算法，两个区域之间使用的是复制算法</p><a id="more"></a><h2 id="G1-垃圾回收流程"><a href="#G1-垃圾回收流程" class="headerlink" title="G1 垃圾回收流程"></a>G1 垃圾回收流程</h2><p>​        G1 垃圾回收器的名字来源于它的设计原则：优先收集回收效果最大的区域（Garbage First），G1 垃圾回收器不是等到内存耗尽开始进行垃圾回收的，它采用启发式算法，当内存使用达到一定比例时就会开始进行垃圾回收，G1 垃圾回收器的工作流程大体上可以分为三个步骤的循环执行：Young Collection、Young Collection + CM、Mixed Collection</p><p><img src="https://img-blog.csdnimg.cn/20191229114401950.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70" alt></p><h3 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h3><p>​        Young Collection 阶段主要进行新生代的垃圾回收，和其他垃圾回收器一样，当 Eden 区逐渐被沾满时，会将 Eden 区中的幸存对象复制进 Survivor 区，这期间会造成 STW，当 Survivor 区中对象逐渐被占满时，被占满的 Survivor 区的对象中，符合晋升条件的会晋升到老年代，其余的会复制到其他 Survivor 区，另外，在进行 Young Collection 时，JVM 会对对象进行初始标记</p><h3 id="Young-Collection-Concurrent-Mark"><a href="#Young-Collection-Concurrent-Mark" class="headerlink" title="Young Collection + Concurrent Mark"></a>Young Collection + Concurrent Mark</h3><p>​        当老年代占用堆空间比例达到一定的阈值时，会进行并发标记，并发标记不会造成 STW，也就是不会影响其他的用户线程，阈值的默认值是 45%，即老年代占比达到堆空间的 45% 时会开始进行并发标记，这里的并发标记过程也和其他的垃圾回收器一样，就是对初始标记后的对象再进行一次更细致的标记</p><h3 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h3><p>​        混合回收是 G1 垃圾回收循环中的最后一项，在混合回收中，G1 可以将一些老年代区域添加到将回收的 Eden 和 Survivor，G1 垃圾回收器回收足够数量的老年代区域后，G1 会恢复到执行 Young Collection，直到下一个并发标记周期的完成</p><p>​        Mixed Collection 分为最终标记（Remark）和拷贝存活（Evacuation）两个阶段，两个阶段都会造成 STW</p><h4 id="Remark（重标记、最终标记）"><a href="#Remark（重标记、最终标记）" class="headerlink" title="Remark（重标记、最终标记）"></a>Remark（重标记、最终标记）</h4><p>​        最终标记（重标记）对于垃圾回收的过程是十分必要的，比如有如下情况：对象 C 在初始标记时因为没有被强引用所引用，初始标记的过程就不会标记 C 对象，而在垃圾回收之前和并发标记这段时间里，强引用对象 A 又引用了对象 C，如果不在垃圾回收之前进行一次 Remark，这时的对象 C 毫无疑问会被当作垃圾回收掉</p><p>​        为了防止这种事情发生，在并发标记之后，如果对象的引用发生了改变，JVM 会执行写屏障指令，将发生引用改变的对象放入一个 satb_mark_queue 中，当重新标记进行时会检查这个队列，检测其中的对象是否有强引用所引用</p><h4 id="Evacuation（拷贝存活）"><a href="#Evacuation（拷贝存活）" class="headerlink" title="Evacuation（拷贝存活）"></a>Evacuation（拷贝存活）</h4><p>​        拷贝存活即最后的整理，将多个区域的存活对象整理进一个或几个区域，并完成 Eden 到 Survivor，Survivor 到 Old，Old 到 Eden 和 Survivor 的过程，回收老年代的对象时，G1 会优先回收垃圾最多的区域，以达到暂停时间短的目标</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Garbage-First-垃圾回收器&quot;&gt;&lt;a href=&quot;#Garbage-First-垃圾回收器&quot; class=&quot;headerlink&quot; title=&quot;Garbage First 垃圾回收器&quot;&gt;&lt;/a&gt;Garbage First 垃圾回收器&lt;/h1&gt;&lt;h2 id=&quot;G1-简介&quot;&gt;&lt;a href=&quot;#G1-简介&quot; class=&quot;headerlink&quot; title=&quot;G1 简介&quot;&gt;&lt;/a&gt;G1 简介&lt;/h2&gt;&lt;p&gt;​        G1（Garbage First）垃圾回收器是最新的 JDK 中默认的垃圾回收器，也是垃圾回收技术最前沿的成果，它同时注重吞吐量（Throughput）和低延迟（Low Latency），默认的暂停目标是 200ms，适用于超大的堆内存&lt;/p&gt;
&lt;p&gt;​        G1 引入了分区（region）的思想，弱化了分代的概念，它将堆内存分为大小相等的区，每个区的大约是 1248M，并且每个区都可以是 Eden、Survivor、Old 或者大对象区，G1 垃圾回收器在整体上使用了标记整理算法，两个区域之间使用的是复制算法&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JVM之垃圾回收器</title>
    <link href="http://yoursite.com/2019/12/26/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>http://yoursite.com/2019/12/26/JAVA基础——JVM之垃圾回收器/</id>
    <published>2019-12-26T11:58:59.000Z</published>
    <updated>2019-12-28T08:54:08.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-垃圾回收器"><a href="#JVM-垃圾回收器" class="headerlink" title="JVM 垃圾回收器"></a>JVM 垃圾回收器</h1><p>​        在 JVM 中，垃圾回收器大体分为三个种类：串行垃圾回收器、吞吐量优先的垃圾回收器和响应时间优先的垃圾回收器</p><a id="more"></a><h2 id="串行垃圾回收器"><a href="#串行垃圾回收器" class="headerlink" title="串行垃圾回收器"></a>串行垃圾回收器</h2><p>​        串行垃圾回收器是一种单线程的垃圾回收器，适合堆内存小，cpu 个数少的电脑</p><p>​        开启：-XX:+UseSerialGC = Serial + SerialOld</p><p>​        串行垃圾回收器分为两个部分：Serial 和 SerialOld，Serial 工作在新生代，使用的垃圾回收算法是复制算法，SerialOld 工作在老年代，使用标记整理算法</p><p>​        当串行垃圾回收器进行垃圾回收时，所有的用户线程将会暂停，因为垃圾回收的过程中会涉及到地址的变化，当所有线程运行到一个本身的安全点时会进入阻塞状态，等待垃圾回收线程结束后，再恢复运行</p><p><img src="https://img-blog.csdnimg.cn/2019122816521345.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70" alt></p><h2 id="吞吐量优先的垃圾回收器"><a href="#吞吐量优先的垃圾回收器" class="headerlink" title="吞吐量优先的垃圾回收器"></a>吞吐量优先的垃圾回收器</h2><p>​        吞吐量优先的垃圾回收器是一种多线程，并行的垃圾回收器</p><p>​        开启：+UseParallelGC~-XX:+UseParallelOldGC</p><p>​        吞吐量优先的垃圾回收器也分为两个部分：Parallel 和 ParallelOld，Parallel 工作在新生代，使用复制算法，ParallelOld 工作在老年代，使用标记整理算法，两个垃圾回收器都是多线程的垃圾回收器，开启一个的同时会默认开启另一个</p><p>​        当需要进行垃圾回收时，所有线程会到安全点时停下，转换为阻塞状态，之后垃圾回收器会开启多个线程进行垃圾回收，其线程个数一般情况下和 cpu 核数相同，回收结束后，各线程再恢复运行，垃圾回收时，cpu 的利用率会达到 100 %</p><p><img src="https://img-blog.csdnimg.cn/20191228165229857.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70" alt></p><p>​        可以通过参数来设置垃圾回收中的属性：</p><p>​    ·    -XX:+UseAdaptiveSizePolicy<br>​        -XX:GCTimeRatio = ratio 设置垃圾回收时间占总时间的百分比小于 1 / 1 + ratio，ratio 一般设置成 19<br>​        -XX:MaxGCPauseMillis = time 最大暂停毫秒数 &lt; time ms，可能和前一项冲突、对立</p><h2 id="响应时间优先的垃圾回收器"><a href="#响应时间优先的垃圾回收器" class="headerlink" title="响应时间优先的垃圾回收器"></a>响应时间优先的垃圾回收器</h2><p>​        响应时间优先的垃圾回收器是一种多线程，并发的垃圾回收器，用户线程和垃圾回收线程可以同时进行，一起抢占 cpu 资源</p><p>​        开启：-XX:+UseConcMarkSweepGC<del>-XX:+UseParNewGC</del>SerialOl</p><p>​        ConcMarkSweep 是工作在老年代的垃圾回收器，与之配套使用的是工作在新生代的 ParNew，ParNew 是一种基于复制算法的垃圾回收器，ConcMarkSweep 是并发的，基于标记清除算法的垃圾回收器，但是它可能会并发失败，这是它会退化为 SerialOld</p><p>​        当老年代发生垃圾回收时，所有线程会在运行到安全点时暂停并进入阻塞状态，需要进行垃圾回收的线程会进行一次初始标记，初始标记时间很快，只标记一些根对象，接着用户的其他线程便恢复运行，垃圾回收线程与此同时也会并发执行，再一次进行更细致的标记，结束后，会造成第二次 STW，这时对所有的线程进行一次重新标记，以避免并发运行期间，新的内存使用对垃圾回收产生影响，重新标记结束后，垃圾回收线程开始进行清理，用户线程也都恢复运行，这时也是垃圾回收线程和用户线程并发运行，这种垃圾回收方式对系统吞吐量是有影响的，因为用于计算的 cpu 个数降低了</p><p>​        由于这种垃圾回收方式不会保证清除掉所有垃圾，所以不能像以上的两种垃圾回收器那样，等内存占用满时再进行垃圾回收，会在内存占比达到一定比例时便进行垃圾回收</p><p><img src="https://img-blog.csdnimg.cn/20191228165244736.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM-垃圾回收器&quot;&gt;&lt;a href=&quot;#JVM-垃圾回收器&quot; class=&quot;headerlink&quot; title=&quot;JVM 垃圾回收器&quot;&gt;&lt;/a&gt;JVM 垃圾回收器&lt;/h1&gt;&lt;p&gt;​        在 JVM 中，垃圾回收器大体分为三个种类：串行垃圾回收器、吞吐量优先的垃圾回收器和响应时间优先的垃圾回收器&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JVM之垃圾回收算法</title>
    <link href="http://yoursite.com/2019/12/25/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/12/25/JAVA基础——JVM之垃圾回收算法/</id>
    <published>2019-12-25T09:04:47.000Z</published>
    <updated>2019-12-25T10:27:45.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-的垃圾回收算法"><a href="#JVM-的垃圾回收算法" class="headerlink" title="JVM 的垃圾回收算法"></a>JVM 的垃圾回收算法</h1><p>​        在 JVM 中，经常使用的垃圾回收算法有：标记-清除算法、标记-整理算法、复制算法以及分代回收算法，在这里会逐一介绍说明</p><a id="more"></a><h2 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark Sweep）"></a>标记-清除算法（Mark Sweep）</h2><p>​        标记清除算法的运行流程是先标记，将有引用链连接的引用对象进行标记，再将未被标记的引用对象的起始地址和结束地址存入空闲地址列表中，下次需要内存时直接对其进行覆盖</p><p>​        标记清除算法从原理上来说很容易实现，但有一个很严重的问题是此算法容易产生内存碎片，因为标记清除算法回收后的内存可能是断断续续的，而此时就不再可能分配出较大的连续内存空间而触发新一次的垃圾回收</p><p>​        标记清除算法在存活的引用对象多的时候十分高效，但因为其只对未被引用链所连接的即未被标记的引用对象进行清除操作，不移动被标记的对象，所以产生内存碎片是不能避免的</p><h2 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark  Compact）"></a>标记-整理算法（Mark  Compact）</h2><p>​        标记整理算法的标记过程和标记清除算法没有区别，整理的过程会对使用的内存进行整理，将存活的对象都向内存的一端移动，然后清理掉整端边界以外的内存</p><p>​        标记整理算法显然解决了标记清除算法会产生内存碎片的问题，但该算法中涉及到对象的移动，所以运算时的成本会有所提高</p><h2 id="复制算法（Copy）"><a href="#复制算法（Copy）" class="headerlink" title="复制算法（Copy）"></a>复制算法（Copy）</h2><p>​        复制算法是将内存区域分成了大小相等的 FROM 和 TO 两块区域，TO 区开始没有对象，所有的对象都使用 FROM 区，当 FROM 区满了需要垃圾回收时，将存活的对象复制到 TO 区中，然后把 FROM 区清空，这样一来复制到 FROM 区的对象是相连的，不会产生内存碎片的问题，最后改 FROM 为 TO，改 TO 为 FROM，这样新的对象就和老对象继续使用新的 FROM 区，而新的 TO 区依然是空的，如此循环</p><p>​        复制算法实现起来十分简单，也不会产生内存碎片，但缺点是以内存空间的使用率为代价，每次只能使用一半的内存空间，如果存活对象多的话，复制算法的效率也会下降</p><h2 id="分代回收算法（Generational-Collention）"><a href="#分代回收算法（Generational-Collention）" class="headerlink" title="分代回收算法（Generational Collention）"></a>分代回收算法（Generational Collention）</h2><p>​        首先分代收集是大部分 JVM 都采用的垃圾回收算法，它将内存划分为不同的区域，根据对象的生命周期对其进行分类，一般分为：新生代（Young Generation）和老年代（Tenured Generation）</p><p>​        新生代中，又被分成一块伊甸园（Eden Space）和两块幸存区（Survivor），幸存区 FROM 和幸存区TO，其比例一般为 8 : 1 : 1，每次都同时使用伊甸园和幸存区 FROM，在进行垃圾回收时（Minor GC），将伊甸园和幸存区 FROM 中的对象复制进幸存区 TO 中，然后清理掉伊甸园和幸存区 FROM，最后像复制算法一样对 FROM 和 TO 进行一次调换如此循环，也就是说，新生代的垃圾回收主要以复制算法为主</p><p>​        在分代回收算法中，有一个用来控制新生代对象进入老年代的属性，叫阈值，每次垃圾回收后，若该对象还存在于内存中，它的年龄就会 + 1，当对象的年龄超过阈值后，它就会从新生代晋升到老年代，也就是说，老年代存放的都是一些生命周期很长的对象</p><p>​        当老年代内存全部被占用时，会先尝试 Minor GC，若空间仍不足，会再进行一次 Full GC，Full GC 的 STW（Stop The World）时间很长，如果 Full GC 后空间仍不足，就会 OOF</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM-的垃圾回收算法&quot;&gt;&lt;a href=&quot;#JVM-的垃圾回收算法&quot; class=&quot;headerlink&quot; title=&quot;JVM 的垃圾回收算法&quot;&gt;&lt;/a&gt;JVM 的垃圾回收算法&lt;/h1&gt;&lt;p&gt;​        在 JVM 中，经常使用的垃圾回收算法有：标记-清除算法、标记-整理算法、复制算法以及分代回收算法，在这里会逐一介绍说明&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JAVA的五种引用类型及引用队列</title>
    <link href="http://yoursite.com/2019/12/20/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JAVA%E7%9A%84%E4%BA%94%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%BC%95%E7%94%A8%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/12/20/JAVA基础——JAVA的五种引用类型及引用队列/</id>
    <published>2019-12-20T09:15:57.000Z</published>
    <updated>2019-12-22T07:22:21.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA-的五种引用类型及引用队列"><a href="#JAVA-的五种引用类型及引用队列" class="headerlink" title="JAVA 的五种引用类型及引用队列"></a>JAVA 的五种引用类型及引用队列</h1><p>​        在介绍 JAVA 的五种引用之前，先介绍一下什么是引用，以及引用和对象之间的关系</p><h2 id="什么是引用"><a href="#什么是引用" class="headerlink" title="什么是引用"></a>什么是引用</h2><p>​        众所周知，JAVA 是一种面向对象的语言，在 JAVA 程序运行时，对象是存储在堆内存（Heap）中的，C/C++ 中是通过指针来访问所谓对象（结构体）的，而 JAVA 则是通过引用来访问对象，也就是说，引用指向了对象在堆内存中的地址，引用本身也占用内存，64 位的 JVM 中，引用所占内存大小为 8 个字节，通过指针压缩后占用 4 个字节</p><p>​        在 JDK 1.2 之前，JAVA 对引用的定义为：如果一个数据中存储的数值代表的是另外一块内存的起始地址，就称这块数据的内存代表着一个引用</p><p>​        在 JDK 1.2 之后，JAVA 引用的概念得到了扩充，引用被分为：强引用、软引用、弱引用、虚引用、终结器引用</p><a id="more"></a><h2 id="引用和对象"><a href="#引用和对象" class="headerlink" title="引用和对象"></a>引用和对象</h2><p>​        在 JAVA 中，一切都被视为是对象，但标识符（变量名）实际上是对象的一个引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个引用，引用可以独立存在，不是必须要关联某一对象</span></span><br><span class="line">String str;</span><br></pre></td></tr></table></figure><p>​        也可以将引用指向对象，这样操作后就可以通过引用来操作对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br></pre></td></tr></table></figure><h2 id="垃圾回收算法、五种引用类型及引用队列"><a href="#垃圾回收算法、五种引用类型及引用队列" class="headerlink" title="垃圾回收算法、五种引用类型及引用队列"></a>垃圾回收算法、五种引用类型及引用队列</h2><p>​        JAVA 在垃圾回收机制中判断是否要回收某一对象时，都需要引用的概念</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>​        引用计数法的原理为：如果变量被引用：计数 +1，没有对象引用计数 -1，为 0 回收，很明显，当一个对象需要被循环引用时，引用计数法可能会存在问题</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>​        Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象：扫描堆中的对象，看是否能够沿着 GC Root 对象为起点的引用链找到该对象，找不到表示可以回收</p><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>​        只有所有 GC Roots 对象都不通过强引用引用该对象，该对象才能被垃圾回收，换句话说就是，只要强引用存在，JVM 垃圾回收器就永远都不会回收被引用的对象，即使内存不足，JVM 会抛出 OutOfMemoryError</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只要 obj 指向 Object 对象，那它就永远都不会被 JVM 回收</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">//将 obj 置为 null，可以切断引用链，这样 obj 就会被 JVM 回收</span></span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h3><p>​        ReferenceQueue，当一个引用（软引用、弱引用）关联到了一个引用队列后，当这个引用所引用的对象要被垃圾回收时，就会将它加入到所关联的引用队列中，所以判断一个引用对象是否已经被回收的一个现象就是，这个对象的引用是否被加入到了它所关联的引用队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB], queue);</span><br></pre></td></tr></table></figure><p>​        说到底，引用队列就是一个对引用的回收机制，当软引用或弱引用所包装的对象为 null 或被回收时，这个引用也就不在具有价值，引用队列就是清除掉这部分引用的一种回收机制</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>​        仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次触发垃圾回收，回收软引用对象，即在内存足够时，JVM 不会回收软引用对象，但当内存不足时，软引用对象就会被回收，所以软引用对象通常用来描述一些非必要但仍有用的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不直接通过 list 引用 byte[]</span></span><br><span class="line"><span class="comment">//list -----&gt; SoftReference -----&gt; byte[] 添加了一层软引用</span></span><br><span class="line">List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>​        弱引用是较软引用更第一级的引用，只要发生垃圾回收，无论内存是否充足，JVM 都会回收掉弱引用对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;WeakReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>​        虚引用必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</p><h3 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h3><p>​        终结器引用无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用 finalize 方法，第二次 GC 时回收被引用对象</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JAVA-的五种引用类型及引用队列&quot;&gt;&lt;a href=&quot;#JAVA-的五种引用类型及引用队列&quot; class=&quot;headerlink&quot; title=&quot;JAVA 的五种引用类型及引用队列&quot;&gt;&lt;/a&gt;JAVA 的五种引用类型及引用队列&lt;/h1&gt;&lt;p&gt;​        在介绍 JAVA 的五种引用之前，先介绍一下什么是引用，以及引用和对象之间的关系&lt;/p&gt;
&lt;h2 id=&quot;什么是引用&quot;&gt;&lt;a href=&quot;#什么是引用&quot; class=&quot;headerlink&quot; title=&quot;什么是引用&quot;&gt;&lt;/a&gt;什么是引用&lt;/h2&gt;&lt;p&gt;​        众所周知，JAVA 是一种面向对象的语言，在 JAVA 程序运行时，对象是存储在堆内存（Heap）中的，C/C++ 中是通过指针来访问所谓对象（结构体）的，而 JAVA 则是通过引用来访问对象，也就是说，引用指向了对象在堆内存中的地址，引用本身也占用内存，64 位的 JVM 中，引用所占内存大小为 8 个字节，通过指针压缩后占用 4 个字节&lt;/p&gt;
&lt;p&gt;​        在 JDK 1.2 之前，JAVA 对引用的定义为：如果一个数据中存储的数值代表的是另外一块内存的起始地址，就称这块数据的内存代表着一个引用&lt;/p&gt;
&lt;p&gt;​        在 JDK 1.2 之后，JAVA 引用的概念得到了扩充，引用被分为：强引用、软引用、弱引用、虚引用、终结器引用&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JVM之虚拟机堆和方法区</title>
    <link href="http://yoursite.com/2019/12/03/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JVM%E4%B9%8B%E6%96%B9%E6%B3%95%E5%8C%BA%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A0%86/"/>
    <id>http://yoursite.com/2019/12/03/JAVA基础——JVM之方法区和虚拟机堆/</id>
    <published>2019-12-03T09:02:35.000Z</published>
    <updated>2019-12-04T13:17:30.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-虚拟机堆和方法区"><a href="#JVM-虚拟机堆和方法区" class="headerlink" title="JVM 虚拟机堆和方法区"></a>JVM 虚拟机堆和方法区</h1><p>​        虚拟机堆和方法区都存在与 JVM 的线程共享区，占有 JVM 内存中的很大一部分</p><a id="more"></a><h2 id="虚拟机堆"><a href="#虚拟机堆" class="headerlink" title="虚拟机堆"></a>虚拟机堆</h2><p>​        堆（Haep），在 Java 中所有通过 new 关键字创建的对象都会使用堆内存，堆是线程共享的，在堆中的对象都需要考虑线程安全问题（只要局部变量不逃逸出方法的作用范围，它就是线程安全的），另外堆还存在垃圾回收机制</p><p>​        垃圾回收机制是回收不再被引用、使用的变量，如果不断产生新的对象且都有人在使用，当对象数量达到一定限度时，就会产生堆内存溢出（OutOfMemoryError），可以通过指令设置堆内存上限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xmx10m</span><br><span class="line">//设置堆内存上限为 10M</span><br></pre></td></tr></table></figure><h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><p>​        方法区和虚拟机堆一样，是线程共享区的一部分，JVM 规范指出，方法区逻辑上是虚拟机堆的一部分，但不强制方法区的位置，它用于存储已被虚拟机加载的类信息、常量池、静态变量、即时编译器编译后的代码等数据</p><p>​        方法区的官方定义如下：</p><blockquote><p>2.5.4. Method Area<br>The Java Virtual Machine has a method area that is shared among all Java Virtual Machine threads. The method area is analogous to the storage area for compiled code of a conventional language or analogous to the “text” segment in an operating system process. It stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors, including the special methods used in class and instance initialization and interface initialization. The method area is created on virtual machine start-up. Although the method area is logically part of the heap, simple implementations may choose not to either garbage collect or compact it. This specification does not mandate the location of the method area or the policies used to manage compiled code. The method area may be of a fixed size or may be expanded as required by the computation and may be contracted if a larger method area becomes unnecessary. The memory for the method area does not need to be contiguous.</p></blockquote><h3 id="永久代（Permanent-Generation）"><a href="#永久代（Permanent-Generation）" class="headerlink" title="永久代（Permanent Generation）"></a>永久代（Permanent Generation）</h3><p>​        永久代是 HotSpot 虚拟机对方法区的具体实现，永久代本身也存在于虚拟机堆中，在 JDK 1.7 中，移除永久代的工作就已经开始了，存储在永久代中的数据转移到了虚拟机堆或者 Native Memory 中</p><h3 id="元空间（Meta-Space）"><a href="#元空间（Meta-Space）" class="headerlink" title="元空间（Meta Space）"></a>元空间（Meta Space）</h3><p>​        从 JDK 1.8 开始，HotSpot 虚拟机完全移除了永久代，改为在 Native Memory 中存放这些数据，新的空间被称为元空间</p><h3 id="常量池（Constant-Pool）"><a href="#常量池（Constant-Pool）" class="headerlink" title="常量池（Constant Pool）"></a>常量池（Constant Pool）</h3><p>​        一个类的二进制字节码文件大约分为三部分：类的基本信息、常量池、包含的虚拟机指令</p><p>​        常量池的作用是为虚拟机指令提供“常量符号”，根据“常量符号”，虚拟机指令可以找到常量池中存在的数据，所以常量池就是一张表，虚拟机指令根据这张常量表找到要执行的类型、方法名、参数类型、字面量等信息，存在于 .class 文件中</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>​        当一个类被加载时，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</p><h4 id="串池（String-Table）"><a href="#串池（String-Table）" class="headerlink" title="串池（String Table）"></a>串池（String Table）</h4><p>​        为避免字符串被重复创建，JVM 引入了串池的概念，当一个字符串变成字符串对象时，该字符串会在已经被创建好的串池中查找是否有同名的字符串，如果有，就将已存在的字符串的地址赋给该字符串对象，如果没有就将该字符串放入串池中，从而降低相同值得字符串变量对内存得消耗</p><p>​        实际上，串池得本质是一个 Hash Table，字符串是它的 KEY，每当有字符串变成字符串变量时，就会检查串池中是否存在和该字符串同名得 KEY，另外，String Table 不能扩容，在 JDK 1.6 中存在于常量池中，在 1.8 时存在于堆中</p><p>​        javac 会在编译期对字符串变量进行优化，例如：String str = “a” + “b”，JVM 认为，”a”是常量，”b”也是常量，所以变量 str 的值在编译期已经决定了，所以会直接将 str 赋值为 “ab”</p><p>#####String.intern()</p><p>​        String.intern 方法，可以将通过 new 创建的 String 对象放入串池中，并且返回放入串池中的字符串</p><h5 id="直接定义的-String-类型变量和通过-new-创建的-String-对象的区别"><a href="#直接定义的-String-类型变量和通过-new-创建的-String-对象的区别" class="headerlink" title="直接定义的 String 类型变量和通过 new 创建的 String 对象的区别"></a>直接定义的 String 类型变量和通过 new 创建的 String 对象的区别</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"a"</span>;</span><br></pre></td></tr></table></figure><p>​        创建 str 对象，在 String Table 中查找”a”字符串，如果有，就将 String Table 中”a”字符串的地址赋给 str，如果没有，就将”a”字符串放入 String Table 中，并把 String Table 中的”a”字符串的地址赋给 str</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure><p>​        创建 str 对象，在 String Table 中查找”a”字符串，如果有，在虚拟机堆中复制（创建）一个”a”字符串对象，如果没有，就在 String Table 中放入”a”字符串，再在虚拟机堆中创建一个 String Table 中”a”字符串的复制对象</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM-虚拟机堆和方法区&quot;&gt;&lt;a href=&quot;#JVM-虚拟机堆和方法区&quot; class=&quot;headerlink&quot; title=&quot;JVM 虚拟机堆和方法区&quot;&gt;&lt;/a&gt;JVM 虚拟机堆和方法区&lt;/h1&gt;&lt;p&gt;​        虚拟机堆和方法区都存在与 JVM 的线程共享区，占有 JVM 内存中的很大一部分&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JVM之Java虚拟机栈</title>
    <link href="http://yoursite.com/2019/12/02/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JVM%E4%B9%8BJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
    <id>http://yoursite.com/2019/12/02/JAVA基础——JVM之Java虚拟机栈/</id>
    <published>2019-12-02T08:02:28.000Z</published>
    <updated>2019-12-02T11:17:56.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h1><p>​        虚拟机栈描述的是 Java 方法执行的动态内存模型</p><a id="more"></a><h2 id="虚拟机栈的内容"><a href="#虚拟机栈的内容" class="headerlink" title="虚拟机栈的内容"></a>虚拟机栈的内容</h2><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p>​        在 Java 程序中的每个方法执行时，都会创建一个栈帧，伴随着方法从创建到执行完成，用于存储局部变量表、操作数栈、动态链接、方法出口等</p><p>​        虚拟机栈是存在大小的，当方法所占用的空间溢出，会产生 StackOverflowError</p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>​        局部表量表的内存空间在编译期即完成分配，主要保存函数的参数以及局部的变量信息，局部变量表中的变量作用域是当前调用的函数，函数调用结束后，随着函数栈帧的销毁，局部变量表也随之销毁，释放空间</p><p>​        局部变量表的最小存储单位是变量槽（Slot），槽的大小与操作系统位数相同，可以放下操作系统位数以内的数据类型</p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>​        操作数栈可理解为java虚拟机栈中的一个用于计算的临时数据存储区，局部变量表使用索引，操作数栈是通过出栈、入栈来访问，存储的数据与局部变量表一致含 int、long、float、double、reference、returnType，操作数栈中 byte、short、char 压栈前会被转为 int</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-虚拟机栈&quot;&gt;&lt;a href=&quot;#Java-虚拟机栈&quot; class=&quot;headerlink&quot; title=&quot;Java 虚拟机栈&quot;&gt;&lt;/a&gt;Java 虚拟机栈&lt;/h1&gt;&lt;p&gt;​        虚拟机栈描述的是 Java 方法执行的动态内存模型&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JVM简介及程序计数器</title>
    <link href="http://yoursite.com/2019/12/01/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JVM%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
    <id>http://yoursite.com/2019/12/01/JAVA基础——JVM简介及程序计数器/</id>
    <published>2019-12-01T08:34:08.000Z</published>
    <updated>2019-12-01T10:30:43.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>​        JVM（Java 虚拟机），是一种用于计算设备的规范，是一个虚构出来的计算机，通过在实际的计算机上仿真模拟各种计算功能来实现，引入 JVM 后，Java 语言在不同平台上运行时不需要重新编译，它屏蔽了与具体平台相关的信息，使得 Java 程序只需生成在 JVM 上运行的字节码文件，就可以在多种平台上不加修改的运行</p><a id="more"></a><h2 id="JVM-基本结构"><a href="#JVM-基本结构" class="headerlink" title="JVM 基本结构"></a>JVM 基本结构</h2><p>​        首先，JVM 分为线程共享区和线程独占区两部分，线程共享区即线程公有，可以所有线程共享，向下分为方法区和 Java 堆，线程独占区即线程私有，向下分为虚拟机栈、本地方法栈以及一会会详细介绍的程序计数器</p><p>具体结构如图：</p><p><img src="https://img-blog.csdnimg.cn/20191201151515479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70" alt></p><h2 id="JVM-程序计数器"><a href="#JVM-程序计数器" class="headerlink" title="JVM 程序计数器"></a>JVM 程序计数器</h2><p>​        程序计数器是一个记录着当前线程所执行到的字节码行号</p><h3 id="程序计数器的特点"><a href="#程序计数器的特点" class="headerlink" title="程序计数器的特点"></a>程序计数器的特点</h3><ol><li><p>线程隔离，每个线程工作室都有属于自己的独立计数器</p></li><li><p>执行 Java 方法时，程序计数器是有值的，且记录的是正在执行的字节码指令的地址</p></li><li><p>执行本地方法时，程序计数器的值为空（Undefined），因为 native 方法时 java 通过 JNI（Java 本地接口）直接调用本地的 C/C++ 库，由于此方法是通过 C/C++ 实现的，无法生成字节码文件，所以其在执行时内存的分配不是由 JVM 决定的</p></li><li><p>程序计数器占用的内存很小，在进行 JVM 内存计算时，可以忽略</p></li><li><p>另外，JVM 中只有程序计数器没有规定任何 OutOfMemoryError</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM&quot;&gt;&lt;a href=&quot;#JVM&quot; class=&quot;headerlink&quot; title=&quot;JVM&quot;&gt;&lt;/a&gt;JVM&lt;/h1&gt;&lt;p&gt;​        JVM（Java 虚拟机），是一种用于计算设备的规范，是一个虚构出来的计算机，通过在实际的计算机上仿真模拟各种计算功能来实现，引入 JVM 后，Java 语言在不同平台上运行时不需要重新编译，它屏蔽了与具体平台相关的信息，使得 Java 程序只需生成在 JVM 上运行的字节码文件，就可以在多种平台上不加修改的运行&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JAVA简介和运行原理</title>
    <link href="http://yoursite.com/2019/11/27/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JAVA%E7%AE%80%E4%BB%8B%E5%92%8C%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/11/27/JAVA基础——JAVA简介和运行原理/</id>
    <published>2019-11-27T02:12:54.000Z</published>
    <updated>2019-11-27T11:53:13.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><p>​        本系列主要更新 Java 基础相关的知识，最近准备重新复习一遍 Java 基础，主要涉及一些原理上的东西，会持续更新！</p><a id="more"></a><p>##Java 简介</p><p>​        Java 是一种简洁的、面向对象的、分布式的、解释型的、健壮安全的、结构中立的、可移植的、性能优异、多线程的动态语言</p><p>​        看不懂吧，简单来说，Java 就是一种面向对象的编程语言，功能完善、安全、使用广泛，在 WEB</p><p> 程序设计、嵌入式开发、桌面应用开发等开发工作中都占有一席之地</p><p>##Java 平台</p><p>​        当前 Java 技术的平台架构包括三方面：</p><p>​        Java SE：开发部署在桌面、服务器、嵌入式环境和实时环境的 Java 应用程序，包含了 Java Web 服务开发的类，为 Java EE 提供基础</p><p>​        Java EE：帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。Java EE 是在 Java SE 的基础上构建的，提供了 Web 服务、组件模型、管理和通信 API，且可以用来实现企业级的面向服务体系结构和 Web 应用程序</p><p>​        Java ME：为在移动设备和嵌入式设备上运行的应用程序提供了一个健壮且灵活的环境，Java ME 包括灵活的用户界面、健壮的安全模式</p><h2 id="Java-运行流程"><a href="#Java-运行流程" class="headerlink" title="Java 运行流程"></a>Java 运行流程</h2><p>​        1.使用文字编辑软件或集成开发环境编辑 Java 源文件，扩展名为 .java</p><p>​        2.通过编译 .java 文件，生成同名的 .class 字节码文件</p><p>​        3.通过 JVM 解释方式，将 .class 字节码文件转变为由 0 或 1 组成的二进制指令（机器码）运行</p><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>​        JDK 是 Java 开发包（开发工具），JDK 是整个 Java 的核心，包含了 JRE，Java 工具类和 Java 核心类库</p><p>​        JDK 适合编译解释小型 Java 文件，随着项目体积的变大，使用 JDK 来维护各类（class）间的依赖关系将变得十分繁琐和复杂</p><h2 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h2><p>​        JRE 是 Java 运行环境，包含了 JVM（Java 虚拟机）标准实现及 Java 核心类库，但不包含编译器、调试器和其他工具</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>​        JVM 是 Java 虚拟机，是 Java 跨平台性的基础，Java 的 .class 字节码文件因为会在 JVM 中被解释成面型不同系统的机器码文件，所以 Java 才具有了跨平台性</p><h3 id="JVM-的内存模型"><a href="#JVM-的内存模型" class="headerlink" title="JVM 的内存模型"></a>JVM 的内存模型</h3><blockquote><p>运行时数据区</p><blockquote><p>方法区</p><p>虚拟机栈</p><p>本地方法栈</p><p>堆</p><p>程序计数器</p></blockquote><p>执行引擎</p><p>本地接口</p><p>本地方法库</p></blockquote><p>​        JVM 还有很多内容，我还在继续学习！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JAVA&quot;&gt;&lt;a href=&quot;#JAVA&quot; class=&quot;headerlink&quot; title=&quot;JAVA&quot;&gt;&lt;/a&gt;JAVA&lt;/h1&gt;&lt;p&gt;​        本系列主要更新 Java 基础相关的知识，最近准备重新复习一遍 Java 基础，主要涉及一些原理上的东西，会持续更新！&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate——其他查询方法</title>
    <link href="http://yoursite.com/2019/11/25/Hibernate%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/11/25/Hibernate框架——其他查询方法/</id>
    <published>2019-11-25T10:32:30.000Z</published>
    <updated>2019-11-25T12:16:08.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hibernate-框架的查询方法"><a href="#Hibernate-框架的查询方法" class="headerlink" title="Hibernate 框架的查询方法"></a>Hibernate 框架的查询方法</h1><p>​        除了通过 session.get() 方法进行查询外，Hibernate 框架还提供了其他的查询方式</p><a id="more"></a><h2 id="Query-查询对象"><a href="#Query-查询对象" class="headerlink" title="Query 查询对象"></a>Query 查询对象</h2><p>​        query 查询对象可以通过设置查询条件进行查询，使用 HQL 语言（Hibernate Query Language），是 Hibernate 的面向对象查询语言，最终底层要转成面向数据库查询语言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.查询所有用户</span></span><br><span class="line">Query query = session.createQuery(<span class="string">"From User"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.查询符合条件得用户【username 和 password 是 User 对象得属性，而不是表的字段名】</span></span><br><span class="line">Query query = session.createQuery(<span class="string">"From User where username = ? and password = ?"</span>);</span><br><span class="line">query.setParameter(<span class="number">0</span>, <span class="string">"lmh"</span>);</span><br><span class="line">query.setParameter(<span class="number">1</span>, <span class="string">"123"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.分页查询</span></span><br><span class="line">Query query = session.creatQuery(<span class="string">"From User"</span>);</span><br><span class="line">query.setMaxResults(<span class="number">3</span>);</span><br><span class="line">query.setFirstResult(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h2 id="Criteria-查询对象"><a href="#Criteria-查询对象" class="headerlink" title="Criteria 查询对象"></a>Criteria 查询对象</h2><p>​        QBC（query by criteria），是 hibernate 提供纯面向对象查询得语言，提供直接使用 PO 对象进行操作</p><p>​        PO：persistent object，用于与数据库交互数据——dao 层（JavaBean + hbm）</p><p>​        BO：business object，业务数据对象——service 层</p><p>​        VO：value object 值对象——web 层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Criteria：hibernate 独创的查询对象，全程无 hql 语言</span></span><br><span class="line">Criteria criteria = session.createCriteria(User.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等于 =</span></span><br><span class="line">criteria.add(Restriction.eq(<span class="string">"lmh"</span>, <span class="string">"123"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//like</span></span><br><span class="line">criteria.add(Restriction.like(<span class="string">"lmh"</span>, <span class="string">"%123%"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//..........</span></span><br></pre></td></tr></table></figure><h2 id="SQLQuery-查询对象"><a href="#SQLQuery-查询对象" class="headerlink" title="SQLQuery 查询对象"></a>SQLQuery 查询对象</h2><p>​        SQLQuery：使用原生的 SQL 语句查询</p><p>​        并不是所有的 sql 都能转成 hql</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQLQuery query = session.createSQLQuery(<span class="string">"select * from t_user"</span>);</span><br></pre></td></tr></table></figure><h2 id="文件逻辑优化"><a href="#文件逻辑优化" class="headerlink" title="文件逻辑优化"></a>文件逻辑优化</h2><h3 id="使用工具类"><a href="#使用工具类" class="headerlink" title="使用工具类"></a>使用工具类</h3><p>​        将重复代码封装进工具类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.cfg.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateUtils</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SessionFactory sf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"><span class="comment">//1.加载配置</span></span><br><span class="line">Configuration cfg = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建一个sessionFactory</span></span><br><span class="line">sf = cfg.buildSessionFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.在虚拟机关闭时，释放SessionFactory</span></span><br><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sf.close();</span><br><span class="line">System.out.println(<span class="string">"释放资源"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">openSession</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> sf.openSession();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getCurrentSession</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> sf.getCurrentSession();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hibernate-框架的查询方法&quot;&gt;&lt;a href=&quot;#Hibernate-框架的查询方法&quot; class=&quot;headerlink&quot; title=&quot;Hibernate 框架的查询方法&quot;&gt;&lt;/a&gt;Hibernate 框架的查询方法&lt;/h1&gt;&lt;p&gt;​        除了通过 session.get() 方法进行查询外，Hibernate 框架还提供了其他的查询方式&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hibernate框架" scheme="http://yoursite.com/tags/Hibernate%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate框架——框架的使用及简单配置讲解</title>
    <link href="http://yoursite.com/2019/11/18/Hibernate%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E8%AE%B2%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/11/18/Hibernate框架——框架的使用及简单配置讲解/</id>
    <published>2019-11-18T04:28:07.000Z</published>
    <updated>2019-11-19T02:32:50.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hibernate-框架简介"><a href="#Hibernate-框架简介" class="headerlink" title="Hibernate 框架简介"></a>Hibernate 框架简介</h1><h2 id="ORM-框架"><a href="#ORM-框架" class="headerlink" title="ORM 框架"></a>ORM 框架</h2><p>​        对象关系映射，对象和表字段进行对应，是一种程序技术，用于实现面向对象编程语言里不用类型系统的数据之间的转换</p><h2 id="Hibernate-框架"><a href="#Hibernate-框架" class="headerlink" title="Hibernate 框架"></a>Hibernate 框架</h2><p>​        Hibernate 是一个开放源码的对象关系映射框架，它对 JDBC 进行了非常轻量级的对象封装，它将 POJO（简单的 JAVA 对象）与数据库表建立映射关系，是一个全自动的 ORM 框架</p><p>​        Hibernate 可以自动生成 SQL 语句，自动执行，可以应用在任何使用 JDBC 的场合</p><p>优点：</p><p>​        对 JDBC 访问数据库的代码做了封装，大大简化了数据访问层繁琐重复性代码</p><p>​        是一个基于 jdbc 的主流持久化框架，是一个优秀的 orm 实现，有很大程度的简化了 dao 层编码工作</p><p>​        Hibernate 使用了 JAVA 的反射机制</p><p>​        Hibernate 性能好，是一个轻量级框架，映射灵活性出色，它支持很多关系型数据库，有一对一到多对多的各种复杂关系映射</p><a id="more"></a><h2 id="Hibernate-框架使用"><a href="#Hibernate-框架使用" class="headerlink" title="Hibernate 框架使用"></a>Hibernate 框架使用</h2><h3 id="核心配置文件-hibernate-cfg-xml"><a href="#核心配置文件-hibernate-cfg-xml" class="headerlink" title="核心配置文件 hibernate.cfg.xml"></a>核心配置文件 hibernate.cfg.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1、配置数据库连接的4个参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/hibernate_day1?useSSL=false&amp;amp;serverTimezone=Hongkong&amp;amp;characterEncoding=utf-8&amp;amp;autoReconnect=true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.password"</span>&gt;</span>lmh12358<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 开启与当前线程绑定 session 的功能 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.current_session_context_class"</span>&gt;</span>thread<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"javax.persistence.validation.mode"</span>&gt;</span>none<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  是否显示sql语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  是否格式化sql语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  是否自动提交事务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.autocommit"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2、配置JavaBean与表的映射文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"com/lmh/hibernate/domain/User.hbm.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Java-Bean-对象映射文件-Class-hbm-xml"><a href="#Java-Bean-对象映射文件-Class-hbm-xml" class="headerlink" title="Java Bean 对象映射文件 Class.hbm.xml"></a>Java Bean 对象映射文件 Class.hbm.xml</h3><p>User.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lmh.hibernate.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> uid;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUid</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> uid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUid</span><span class="params">(<span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.uid = uid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>User.hbm.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.lmh.hibernate.domain.User"</span> <span class="attr">table</span>=<span class="string">"t_user"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- name：模型中的属性名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"uid"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- id 的生成策略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果表中类中字段名相同不用写 column --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="所用-jar-包"><a href="#所用-jar-包" class="headerlink" title="所用 jar 包"></a>所用 jar 包</h3><blockquote><p>antlr-2.7.6.jar</p><p>commons-collections-3.1.jar</p><p>dom4j-1.6.1.jar</p><p>hibernate-jpa-2.0-api-1.0.1.Final.jar</p><p>hibernate3.jar</p><p>javassist-3.12.0.GA.jar</p><p>jta-1.1.jar</p><p>mysql-connector-java-8.0.16.jar</p><p>slf4j-api-1.6.1.jar</p></blockquote><h3 id="测试类："><a href="#测试类：" class="headerlink" title="测试类："></a>测试类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lmh.hibernate.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Transaction;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.cfg.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmh.hibernate.domain.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDemo</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//保存用户数据</span></span><br><span class="line"><span class="comment">//1.获取核心配置文件对象，configure()无参数默认是加载 src 的 hibernate.cfg.xml 文件</span></span><br><span class="line">Configuration cfg = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//2.创建会话工厂</span></span><br><span class="line">SessionFactory factory = cfg.buildSessionFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.创建会话【相当于连接 Connect】</span></span><br><span class="line"><span class="comment">//openSession()获取一个全新的 session</span></span><br><span class="line"><span class="comment">//factory.getCurrentSession获取一个与当前线程绑定的 session</span></span><br><span class="line">Session session1 = factory.openSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line">Transaction trans = session1.getTransaction();</span><br><span class="line">trans.begin();</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存【直接把对象保存到数据库】</span></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setUsername(<span class="string">"skw"</span>);</span><br><span class="line">user.setPassword(<span class="string">"123"</span>);</span><br><span class="line">session1.save(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line">trans.commit();</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.关闭会话</span></span><br><span class="line">session1.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.关闭工厂</span></span><br><span class="line">factory.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Configuration-配置对象"><a href="#Configuration-配置对象" class="headerlink" title="Configuration 配置对象"></a>Configuration 配置对象</h2><p>​        Configuration 对象用来加载配置文件，new Configuration 构造方法加载的时 hibernate.properties，configure 方法加载的是 hibernate.cfg.xml，通常这两种配置文件都会被放在 src 目录下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存用户数据</span></span><br><span class="line"><span class="comment">//1.获取核心配置文件对象，configure()无参数默认是加载 src 的 hibernate.cfg.xml 文件</span></span><br><span class="line"><span class="comment">//2.直接 new 出来的对象默认调用 hibernate.properties</span></span><br><span class="line">Configuration cfg = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line">Configuration cfg = <span class="keyword">new</span> Configuration();</span><br></pre></td></tr></table></figure><h3 id="加载-Class-hbm-xml-映射文件的方式"><a href="#加载-Class-hbm-xml-映射文件的方式" class="headerlink" title="加载 Class.hbm.xml 映射文件的方式"></a>加载 Class.hbm.xml 映射文件的方式</h3><p>hibernate.cfg.xml中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1.在 hibernate.cfg.xml 中配置JavaBean与表的映射文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"com/lmh/hibernate/domain/User.hbm.xml"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>测试类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.调用 Configuration 对象的 addResource</span></span><br><span class="line">cfg.addResource(<span class="string">"com/lmh/hibernate/domain/User.hbm.xml"</span>);</span><br><span class="line"><span class="comment">//3.调用 Configuration 对象的 addClass 方法</span></span><br><span class="line">cfg.addClass(User.class);</span><br></pre></td></tr></table></figure><h2 id="SessionFactory-工厂"><a href="#SessionFactory-工厂" class="headerlink" title="SessionFactory 工厂"></a>SessionFactory 工厂</h2><p>​        SessionFactory 相当于 Java Web 连接池，用于管理所有的 session，通过调用 Configuration 对象的 buildSessionFactory 方法来获得 SessionFactory，它还用于缓存配置信息（数据库配置信息、映射文件、预定义 HQL 语句等），SessionFactory 线程安全，多个线程同时访问时不会出现线程并发访问问题</p><h2 id="Session-会话"><a href="#Session-会话" class="headerlink" title="Session 会话"></a>Session 会话</h2><p>​        创建一个 Session 就相当于建立了一个 Connection，建立后可以通过 Session 来对数据库中的表进行操作</p><h3 id="Session-会话的获取"><a href="#Session-会话的获取" class="headerlink" title="Session 会话的获取"></a>Session 会话的获取</h3><p>​        SessionFactory 提供了两个方法来获取 Session：</p><p>​        1.factory.openSession()：获取一个全新的 Session</p><p>​        2.factory.getCurrentSession()：获取一个与当前线程绑定的 Session</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Session session1 = factory.openSession();</span><br><span class="line">Session session2 = factory.openSession();</span><br><span class="line">System.out.println(session1.hashCode());</span><br><span class="line">System.out.println(session2.hashCode());</span><br><span class="line"></span><br><span class="line">Session session3 = factory.getCurrentSession();</span><br><span class="line">Session session4 = factory.getCurrentSession();</span><br><span class="line">System.out.println(session3.hashCode());</span><br><span class="line">System.out.println(session4.hashCode());</span><br></pre></td></tr></table></figure><p>​        要使用 2 方法，必须在 hibernate.cfg.xml 中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.current_session_context_class"</span>&gt;</span>thread<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Session-的-api"><a href="#Session-的-api" class="headerlink" title="Session 的 api"></a>Session 的 api</h3><p>save：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setUsername(<span class="string">"lxq"</span>);</span><br><span class="line">user.setPassword(<span class="string">"123"</span>);</span><br><span class="line">session1.save(user);</span><br></pre></td></tr></table></figure><p>get：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User u1 = (User)session1.get(User.class, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//通过 id 查询，没有事返回 null，获取的是 object 对象，需要强制转换</span></span><br></pre></td></tr></table></figure><p>load：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User u2 = (User)session1.load(User.class, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//同样通过 id 查修，但没有时报错</span></span><br></pre></td></tr></table></figure><p>delete：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.先获取要删除的对象，再调用 delete 方法</span></span><br><span class="line">User u1 = (User)session1.get(User.class, <span class="number">3</span>);</span><br><span class="line">session1.delete(u1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建一个 user，设置 id，然后调用 delete 方法</span></span><br><span class="line">User u2 = <span class="keyword">new</span> User();</span><br><span class="line">u2.setUid(<span class="number">2</span>);</span><br><span class="line">session1.delete(u2);</span><br></pre></td></tr></table></figure><p>update：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//session 使用 update 更新数据</span></span><br><span class="line"><span class="comment">//1.通过 get 获取数据，调用 set 方法，事务提交自动执行 update 语句</span></span><br><span class="line"><span class="comment">//2.自己封装 User 对象，设置 id，这个时候，需要调用 update 方法</span></span><br><span class="line">u1.setPassword(<span class="string">"abc"</span>);</span><br><span class="line">session1.update(u1);</span><br></pre></td></tr></table></figure><h4 id="get-和-load-方法的区别（面试）："><a href="#get-和-load-方法的区别（面试）：" class="headerlink" title="get 和 load 方法的区别（面试）："></a>get 和 load 方法的区别（面试）：</h4><p>​        get 方法是直接加载数据库</p><p>​        load 方法的设计是懒加载，用到是才会访问数据库，调用 load 方法时返回的是一个代理对象（javassist）</p><h2 id="Transaction-事务"><a href="#Transaction-事务" class="headerlink" title="Transaction 事务"></a>Transaction 事务</h2><p>​        这里不需要仔细看。因为后期的事务会交给 Spring 管理，直接上代码吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Transaction trans = session1.getTransaction();</span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line">trans.begin();</span><br><span class="line"></span><br><span class="line">User u1 = (User)session1.get(User.class, <span class="number">3</span>);</span><br><span class="line">u1.setPassword(<span class="string">"abc"</span>);</span><br><span class="line">session1.update(u1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line">trans.commit();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hibernate-框架简介&quot;&gt;&lt;a href=&quot;#Hibernate-框架简介&quot; class=&quot;headerlink&quot; title=&quot;Hibernate 框架简介&quot;&gt;&lt;/a&gt;Hibernate 框架简介&lt;/h1&gt;&lt;h2 id=&quot;ORM-框架&quot;&gt;&lt;a href=&quot;#ORM-框架&quot; class=&quot;headerlink&quot; title=&quot;ORM 框架&quot;&gt;&lt;/a&gt;ORM 框架&lt;/h2&gt;&lt;p&gt;​        对象关系映射，对象和表字段进行对应，是一种程序技术，用于实现面向对象编程语言里不用类型系统的数据之间的转换&lt;/p&gt;
&lt;h2 id=&quot;Hibernate-框架&quot;&gt;&lt;a href=&quot;#Hibernate-框架&quot; class=&quot;headerlink&quot; title=&quot;Hibernate 框架&quot;&gt;&lt;/a&gt;Hibernate 框架&lt;/h2&gt;&lt;p&gt;​        Hibernate 是一个开放源码的对象关系映射框架，它对 JDBC 进行了非常轻量级的对象封装，它将 POJO（简单的 JAVA 对象）与数据库表建立映射关系，是一个全自动的 ORM 框架&lt;/p&gt;
&lt;p&gt;​        Hibernate 可以自动生成 SQL 语句，自动执行，可以应用在任何使用 JDBC 的场合&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;p&gt;​        对 JDBC 访问数据库的代码做了封装，大大简化了数据访问层繁琐重复性代码&lt;/p&gt;
&lt;p&gt;​        是一个基于 jdbc 的主流持久化框架，是一个优秀的 orm 实现，有很大程度的简化了 dao 层编码工作&lt;/p&gt;
&lt;p&gt;​        Hibernate 使用了 JAVA 的反射机制&lt;/p&gt;
&lt;p&gt;​        Hibernate 性能好，是一个轻量级框架，映射灵活性出色，它支持很多关系型数据库，有一对一到多对多的各种复杂关系映射&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hibernate框架" scheme="http://yoursite.com/tags/Hibernate%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Struts2框架——Struts的错误回显以及struts标签</title>
    <link href="http://yoursite.com/2019/11/09/Struts2%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94Struts%E7%9A%84%E9%94%99%E8%AF%AF%E5%9B%9E%E6%98%BE%E4%BB%A5%E5%8F%8Astruts%E6%A0%87%E7%AD%BE/"/>
    <id>http://yoursite.com/2019/11/09/Struts2框架——Struts的错误回显以及struts标签/</id>
    <published>2019-11-09T01:37:44.000Z</published>
    <updated>2019-11-09T02:01:27.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Struts的错误回显以及struts标签"><a href="#Struts的错误回显以及struts标签" class="headerlink" title="Struts的错误回显以及struts标签"></a>Struts的错误回显以及struts标签</h1><p>​        本次记录一下 Struts 的错误回显以及 struts 框架前端标签的简单用法</p><a id="more"></a><h2 id="Struts-的错误回显"><a href="#Struts-的错误回显" class="headerlink" title="Struts 的错误回显"></a>Struts 的错误回显</h2><p>​        在 struts.xml 中的 result 标签中，把 name 属性的值设置成 input，这样当数据出现异常时，会自动回显到后边声明的 jsp 页面</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"register"</span> <span class="attr">class</span>=<span class="string">"com.lmh.action.UserAction"</span> <span class="attr">method</span>=<span class="string">"register"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 回显，出错后返回注册界面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"input"</span>&gt;</span>/register2.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="struts-标签"><a href="#struts-标签" class="headerlink" title="struts 标签"></a>struts 标签</h2><p>​        struts 提供了可以在前端页面中使用的标签，使用 struts 标签，可以实现很多 struts 框架支持的高级功能</p><p>​        首先，想要在前端页面中使用 struts 标签，需要在 jsp 页面中声明 struts 标签库</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@taglib</span> uri=<span class="string">"/struts-tags"</span> prefix=<span class="string">"s"</span> %&gt;</span><br></pre></td></tr></table></figure><p>​        下面简单发一下 struts 标签的用法吧</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> <span class="keyword">import</span>=<span class="string">"java.util.*"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">String path = request.getContextPath();</span><br><span class="line">String basePath = request.getScheme()+<span class="string">"://"</span>+request.getServerName()+<span class="string">":"</span>+request.getServerPort()+path+<span class="string">"/"</span>;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%<span class="meta">@taglib</span> uri=<span class="string">"/struts-tags"</span> prefix=<span class="string">"s"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;base href=<span class="string">"&lt;%=basePath%&gt;"</span>&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;title&gt;My JSP 'register2.jsp' starting page&lt;/title&gt;</span><br><span class="line">    </span><br><span class="line">&lt;meta http-equiv=<span class="string">"pragma"</span> content=<span class="string">"no-cache"</span>&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"cache-control"</span> content=<span class="string">"no-cache"</span>&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"expires"</span> content=<span class="string">"0"</span>&gt;    </span><br><span class="line">&lt;meta http-equiv=<span class="string">"keywords"</span> content=<span class="string">"keyword1,keyword2,keyword3"</span>&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"description"</span> content=<span class="string">"This is my page"</span>&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> href=<span class="string">"styles.css"</span>&gt;</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;!-- struts 表单的特点</span><br><span class="line">  <span class="number">1</span>.action 不需要写项目名</span><br><span class="line">  <span class="number">2</span>.会给表单里面的内容放在 table 中，并加上样式</span><br><span class="line">  <span class="number">3</span>.struts 标签必须有 name 属性</span><br><span class="line">   --&gt;</span><br><span class="line">    This is my JSP page. &lt;br&gt;</span><br><span class="line">    &lt;s:form action=<span class="string">"/login/register.action"</span>&gt;</span><br><span class="line">    &lt;s:textfield name="username" label="用户名"&gt;&lt;/s:textfield&gt;</span><br><span class="line">    &lt;s:textfield name="password" label="密码"&gt;&lt;/s:textfield&gt;</span><br><span class="line">    &lt;s:textfield name="birthday" label="生日"&gt;&lt;/s:textfield&gt;</span><br><span class="line">&lt;!-- list 使用 OGNL 表达式 --&gt;</span><br><span class="line">    &lt;s:checkboxlist list="#&#123;'coding':'写代码','basketball':'打篮球','soccer':'踢足球'&#125;" label="爱好" name="hobby"&gt;&lt;/s:checkboxlist&gt;</span><br><span class="line">    &lt;s:radio list="#&#123;'true':'已婚','false':'未婚'&#125;" label="是否已婚" name="married"&gt;&lt;/s:radio&gt;</span><br><span class="line">    &lt;s:submit value="注册" name="zc"&gt;&lt;/s:submit&gt;</span><br><span class="line">    &lt;/s:form&gt;</span><br><span class="line">  &lt;hr&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Struts的错误回显以及struts标签&quot;&gt;&lt;a href=&quot;#Struts的错误回显以及struts标签&quot; class=&quot;headerlink&quot; title=&quot;Struts的错误回显以及struts标签&quot;&gt;&lt;/a&gt;Struts的错误回显以及struts标签&lt;/h1&gt;&lt;p&gt;​        本次记录一下 Struts 的错误回显以及 struts 框架前端标签的简单用法&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaEE——Struts2框架" scheme="http://yoursite.com/tags/JavaEE%E2%80%94%E2%80%94Struts2%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Struts2框架——struts.xml文件配置及Action接受参数的方式</title>
    <link href="http://yoursite.com/2019/11/02/Struts2%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94struts-xml%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E5%8F%8AAction%E6%8E%A5%E5%8F%97%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/11/02/Struts2框架——struts-xml文件配置及Action接受参数的方式/</id>
    <published>2019-11-02T02:28:05.000Z</published>
    <updated>2019-11-02T03:39:31.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="struts-xml-文件配置及-Action-接受参数的方式"><a href="#struts-xml-文件配置及-Action-接受参数的方式" class="headerlink" title="struts.xml 文件配置及 Action 接受参数的方式"></a>struts.xml 文件配置及 Action 接受参数的方式</h1><p>​        本次记录一下 struts.xml 文件在多种模块下的配置方法以及 Action 在接受 view 种参数的方式</p><a id="more"></a><h2 id="struts-xml-配置"><a href="#struts-xml-配置" class="headerlink" title="struts.xml 配置"></a>struts.xml 配置</h2><p>​        在有需要多种模块配置要求下的 struts.xml 文件有两种配置方法</p><h3 id="多模块配置-struts-xml"><a href="#多模块配置-struts-xml" class="headerlink" title="多模块配置 struts.xml"></a>多模块配置 struts.xml</h3><p>​        使用 <package> 标签中的 namespace 属性，来对不同的模块进行分类</package></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 用户模块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">name</span>=<span class="string">"/user"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"addUser"</span> <span class="attr">class</span>=<span class="string">"com.lmh.web.action.UserAction"</span> <span class="attr">method</span>=<span class="string">"addUser"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/login.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 角色模块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"role"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">name</span>=<span class="string">"/role"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"addRole"</span> <span class="attr">class</span>=<span class="string">"com.lmh.web.action.RoleAction"</span> <span class="attr">method</span>=<span class="string">"addRole"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/login.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="多文件配置-struts-xml"><a href="#多文件配置-struts-xml" class="headerlink" title="多文件配置 struts.xml"></a>多文件配置 struts.xml</h3><p>​        使用多个 struts.xml 文件进行配置，在主 struts.xml 文件中添加 <include> 标签来进行引用</include></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"struts-order.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"struts-user.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Action-接受-View-种值的几种方式"><a href="#Action-接受-View-种值的几种方式" class="headerlink" title="Action 接受 View 种值的几种方式"></a>Action 接受 View 种值的几种方式</h2><h3 id="通过-Serlvlet-来获取"><a href="#通过-Serlvlet-来获取" class="headerlink" title="通过 Serlvlet 来获取"></a>通过 Serlvlet 来获取</h3><p>register.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"$&#123;pageContext.request.contextPath&#125;/login/register.action"</span>&gt;</span><br><span class="line">    用户名&lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span>&gt;&lt;br&gt;</span><br><span class="line">    密码&lt;input type=<span class="string">"password"</span> name=<span class="string">"password"</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> name=<span class="string">"zc"</span> value=<span class="string">"注册"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>UserAction：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HttpServletRequest req = ServletActionContext.getRequest();</span><br><span class="line">String username = req.getParameter(<span class="string">"username"</span>);</span><br><span class="line">String password = req.getParameter(<span class="string">"password"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(username);</span><br><span class="line">System.out.println(password);</span><br></pre></td></tr></table></figure><p>struts.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">name</span>=<span class="string">"/user"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"register"</span> <span class="attr">class</span>=<span class="string">"com.lmh.web.action.UserAction"</span> <span class="attr">method</span>=<span class="string">"register"</span>&gt;</span><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="通过-Action-的属性的-set-方法注入"><a href="#通过-Action-的属性的-set-方法注入" class="headerlink" title="通过 Action 的属性的 set 方法注入"></a>通过 Action 的属性的 set 方法注入</h3><p>​        struts 会通过表单字段的名称，调用 set 方法，比如 username 字段会调用 setUsername</p><p>UserAction：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"set username"</span>);</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"set password"</span>);</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过-Action-的属性的-set-模型的形式注入"><a href="#通过-Action-的属性的-set-模型的形式注入" class="headerlink" title="通过 Action 的属性的 set 模型的形式注入"></a>通过 Action 的属性的 set 模型的形式注入</h3><p>User：（模型，提供属性的  get/set 方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.web.model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"User [username="</span> + username + <span class="string">", password="</span> + password + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserAction：（把参数封装到一个 User 模型中，在 Action 中提供模型的 get/set 方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"get user"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"set user"</span>);</span><br><span class="line">    <span class="keyword">this</span>.user = user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>register.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"$&#123;pageContext.request.contextPath&#125;/login/register.action"</span>&gt;</span><br><span class="line">    用户名&lt;input type=<span class="string">"text"</span> name=<span class="string">"user.username"</span>&gt;&lt;br&gt;</span><br><span class="line">    密码&lt;input type=<span class="string">"password"</span> name=<span class="string">"user.password"</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> name=<span class="string">"zc"</span> value=<span class="string">"注册"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h3 id="通过-Action-模型驱动封装参数"><a href="#通过-Action-模型驱动封装参数" class="headerlink" title="通过 Action 模型驱动封装参数"></a>通过 Action 模型驱动封装参数</h3><p>register.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"$&#123;pageContext.request.contextPath&#125;/login/register.action"</span>&gt;</span><br><span class="line">    用户名&lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span>&gt;&lt;br&gt;</span><br><span class="line">    密码&lt;input type=<span class="string">"password"</span> name=<span class="string">"password"</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> name=<span class="string">"zc"</span> value=<span class="string">"注册"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>UserAction：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lmh.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmh.model.User;</span><br><span class="line"><span class="keyword">import</span> com.lmh.service.IUserService;</span><br><span class="line"><span class="keyword">import</span> com.lmh.service.impl.UserServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ModelDriven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> <span class="keyword">implements</span> <span class="title">ModelDriven</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> NONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数注入原理"><a href="#参数注入原理" class="headerlink" title="参数注入原理"></a>参数注入原理</h3><p>​        参数会自动注入是因为 struts-default.xml 中有两个拦截器在工作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">"params"</span> <span class="attr">class</span>=<span class="string">"com.opensymphony.xwork2.interceptor.ParametersInterceptor"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">"modelDriven"</span> <span class="attr">class</span>=<span class="string">"com.opensymphony.xwork2.interceptor.ModelDrivenInterceptor"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>​    1.struts 的默认拦截器是由 defaultStack 决定的</p><p>​    2.如果在 package 中不写拦截器，就是 struts-default 中的defaultStack 的拦截器在工作</p><p>​    3.一旦在 package 中写了拦截器，struts-default 中的 defaultStack 的任何拦截器就都不工作了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;struts-xml-文件配置及-Action-接受参数的方式&quot;&gt;&lt;a href=&quot;#struts-xml-文件配置及-Action-接受参数的方式&quot; class=&quot;headerlink&quot; title=&quot;struts.xml 文件配置及 Action 接受参数的方式&quot;&gt;&lt;/a&gt;struts.xml 文件配置及 Action 接受参数的方式&lt;/h1&gt;&lt;p&gt;​        本次记录一下 struts.xml 文件在多种模块下的配置方法以及 Action 在接受 view 种参数的方式&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaEE——Struts2框架" scheme="http://yoursite.com/tags/JavaEE%E2%80%94%E2%80%94Struts2%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Struts2框架——struts.xml文件详解</title>
    <link href="http://yoursite.com/2019/10/27/Struts2%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94struts-xml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/10/27/Struts2框架——struts-xml文件详解/</id>
    <published>2019-10-27T01:16:04.000Z</published>
    <updated>2019-10-27T03:47:08.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="struts-xml-文件"><a href="#struts-xml-文件" class="headerlink" title="struts.xml 文件"></a>struts.xml 文件</h1><p>​        struts.xml 是 Struts2 最核心最常用的配置文件，下面详细介绍一下 struts.xml 中的元素和配置</p><a id="more"></a><h2 id="package-元素"><a href="#package-元素" class="headerlink" title="package 元素"></a>package 元素</h2><p>​        struts2 的配置文件中引入了面向对象的思想，使用了分包管理。易于管理动作类，便于模块化开发动作类</p><h3 id="package-元素的属性"><a href="#package-元素的属性" class="headerlink" title="package 元素的属性"></a>package 元素的属性</h3><p>​        name：包的名称，必须写，并且名称唯一</p><p>​        extends：继承自哪个基础包，通常继承 struts-default 包</p><p>​                          struts-default.xml 中定义着 struts-default 包</p><p>​                          struts-default.xml 是在 struts.xml 之前加载的</p><p>​        abstract：把包声明为抽象包，抽象包就是用来被继承的</p><p>​                          只要没有 <action> 元素的包，就可以声明为抽象包</action></p><p>​        namespace：命名空间。【访问路径 = 命名空间 + 动作名称】</p><h4 id="namespace-详解"><a href="#namespace-详解" class="headerlink" title="namespace 详解"></a>namespace 详解</h4><p>​        namespace 的默认取值是一个“”，不需要写 /</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"p2"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">namespace</span>=<span class="string">"/user"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"add"</span> <span class="attr">class</span>=<span class="string">"com.web.action.UserAction"</span> <span class="attr">method</span>=<span class="string">"add"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/add.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"delete"</span> <span class="attr">class</span>=<span class="string">"com.web.action.UserAction"</span> <span class="attr">method</span>=<span class="string">"delete"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/delete.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"update"</span> <span class="attr">class</span>=<span class="string">"com.web.action.UserAction"</span> <span class="attr">method</span>=<span class="string">"update"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/update.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"find"</span> <span class="attr">class</span>=<span class="string">"com.web.action.UserAction"</span> <span class="attr">method</span>=<span class="string">"find"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/find.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        如果有两层命名空间，查找规则是从后向前查找</p><h2 id="action-元素"><a href="#action-元素" class="headerlink" title="action 元素"></a>action 元素</h2><p>​        配置动作，处理请求路径</p><h3 id="action-元素的属性"><a href="#action-元素的属性" class="headerlink" title="action 元素的属性"></a>action 元素的属性</h3><p>​        name：动作名称，同一个命名空间下要求名称唯一</p><p>​        class：动作类全路径名</p><p>​        method：动作类中的方法名，默认是 public String execute()</p><p>​            方法的要求：</p><p>​                1.public 的</p><p>​                2.返回值必须是 String</p><p>​                3.没有参数</p><h3 id="动作类-Action-的写法"><a href="#动作类-Action-的写法" class="headerlink" title="动作类 Action 的写法"></a>动作类 Action 的写法</h3><p>####动作类的第一种写法</p><p>​        直接写一个 Action 类，不需要继承任何类，然后在 struts.xml 中配置</p><p>Action 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.web.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloAction</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Success"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>struts.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"p1"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">namespace</span>=<span class="string">"/a"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"hello"</span> <span class="attr">class</span>=<span class="string">"com.web.action.HelloAction"</span> <span class="attr">method</span>=<span class="string">"sayHello"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>####动作类的第二种写法</p><p>​        写一个实现 Action 接口的动作类，然后实现 execute 方法</p><p>Action 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.web.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.Action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demoAction</span> <span class="keyword">implements</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>struts.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"p1"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">namespace</span>=<span class="string">"/a"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"demo"</span> <span class="attr">class</span>=<span class="string">"com.web.action.demoAction"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        Action 接口中有一些静态常量：SUCCESS，NONE，ERROR，INPUT，LOGIN，可以直接在返回值中使用</p><h4 id="动作类的第三种写法（推荐）"><a href="#动作类的第三种写法（推荐）" class="headerlink" title="动作类的第三种写法（推荐）"></a>动作类的第三种写法（推荐）</h4><p>​        写一个继承 ActionSupport 类的 Action 类</p><p>​        ActionSupport 是实现 Action 接口定的类</p><p>Action：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.web.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginAction3</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>struts.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"p1"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">namespace</span>=<span class="string">"/a"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"login3"</span> <span class="attr">class</span>=<span class="string">"com.web.action.LoginAction3"</span> <span class="attr">method</span>=<span class="string">"login"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="默认动作类"><a href="#默认动作类" class="headerlink" title="默认动作类"></a>默认动作类</h4><p>​        struts-default.xml 中定义了默认动作类和方法</p><p>​        默认的动作类就是 com.opensymphony.xwork2.ActionSupport 这个类</p><p>struts.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">default-class-ref</span> <span class="attr">class</span>=<span class="string">"com.web.action.HelloAction"</span>&gt;</span><span class="tag">&lt;/<span class="name">default-class-ref</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"hello"</span> <span class="attr">class</span>=<span class="string">"com.web.action.HelloAction"</span> <span class="attr">method</span>=<span class="string">"sayHello"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 没有配置 method 的 action，默认访问 execute 方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="result-元素"><a href="#result-元素" class="headerlink" title="result 元素"></a>result 元素</h2><p>​        为动作指定结果试图</p><h3 id="result-元素的属性"><a href="#result-元素的属性" class="headerlink" title="result 元素的属性"></a>result 元素的属性</h3><p>​        name：逻辑视图的名称，对应着动作方法的返回值，默认值是 success</p><p>​        type：结果类型，指的就是用什么方式转到定义的页面，默认是 dispather 转发</p><p>​            dispatcher：使用请求转发，转向一个页面</p><p>​            redirect：使用重定向，转向一个页面</p><p>​            chain：转发到另一个相同或不同命名空间的动作</p><p>​            redirectAction：重定向到相同或不同命名空间的动作</p><h4 id="result-元素中的-param-子元素"><a href="#result-元素中的-param-子元素" class="headerlink" title="result 元素中的 param 子元素"></a>result 元素中的 param 子元素</h4><p>​        在转发或者重定向到不同包下的动作时，都要用到 result 元素的子元素 param</p><p>​        param 元素的作用：依赖注入</p><p>​        通过 struts-default.xml 中的 resultTypes 元素中配置可以看出，每个结果试图都是靠一个类来实现的</p><p>​        param 元素就是将配置参数注入到该类中</p><p>​        调用的事i对应类的 setter 方法进行注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"p5"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">namespace</span>=<span class="string">"/demo"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"action1"</span> <span class="attr">class</span>=<span class="string">"com.web.action.Demo1Action"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- result 的 name 可以不写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 转发到同一个包下的 action --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"action3"</span> <span class="attr">class</span>=<span class="string">"com.web.action.ChainAction1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span> <span class="attr">type</span>=<span class="string">"chain"</span>&gt;</span>action1<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"action4"</span> <span class="attr">class</span>=<span class="string">"com.web.action.ChainAction1"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span> <span class="attr">type</span>=<span class="string">"redirectAction"</span>&gt;</span>action1<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"action5"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span> <span class="attr">type</span>=<span class="string">"chain"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 依赖注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"namespace"</span>&gt;</span>/a<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"actionName"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">param</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"action6"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span> <span class="attr">type</span>=<span class="string">"redirectAction"</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 依赖注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"namespace"</span>&gt;</span>/a<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"actionName"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">param</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">result</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;struts-xml-文件&quot;&gt;&lt;a href=&quot;#struts-xml-文件&quot; class=&quot;headerlink&quot; title=&quot;struts.xml 文件&quot;&gt;&lt;/a&gt;struts.xml 文件&lt;/h1&gt;&lt;p&gt;​        struts.xml 是 Struts2 最核心最常用的配置文件，下面详细介绍一下 struts.xml 中的元素和配置&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaEE——Struts2框架" scheme="http://yoursite.com/tags/JavaEE%E2%80%94%E2%80%94Struts2%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Struts2框架—— MyEclipse搭建项目以及运行流程（一）</title>
    <link href="http://yoursite.com/2019/10/18/Struts2%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%20MyEclipse%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E4%BB%A5%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2019/10/18/Struts2框架—— MyEclipse搭建项目以及运行流程（一）/</id>
    <published>2019-10-18T02:16:33.000Z</published>
    <updated>2019-10-18T09:29:14.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Struts-框架"><a href="#Struts-框架" class="headerlink" title="Struts 框架"></a>Struts 框架</h1><p>​        Struts2 框架是 Apache 发行的 MVC 开源框架，是表现层 web 框架</p><a id="more"></a><h2 id="Struts-文件包"><a href="#Struts-文件包" class="headerlink" title="Struts 文件包"></a>Struts 文件包</h2><blockquote><p>apps</p><p>docs</p><p>lib</p><p>src</p></blockquote><p>apps：官方提供的 Demo</p><p>docs：官方提供的文档</p><p>lib：官方提供的 jar 包，需要用到哪个才导入哪个</p><p>src：源码</p><h2 id="使用-MyEclipse2017-配置-Struts2-项目"><a href="#使用-MyEclipse2017-配置-Struts2-项目" class="headerlink" title="使用 MyEclipse2017 配置 Struts2 项目"></a>使用 MyEclipse2017 配置 Struts2 项目</h2><ol><li><p>创建 Web Project（配置 tomcat 服务器）</p></li><li><p>将 Struts2 lib 目录下的 jar 包复制到项目中</p></li><li><p>创建 struts.xml 文件在项目中 src 目录下</p></li><li><p>配置 struts 过滤器（配置 web.xml）</p></li><li><p>运行</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span> <span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"3.1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>lmhStruts2<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（web.xml 文件配置）</p><h2 id="配置-struts-xml-文件及-Action"><a href="#配置-struts-xml-文件及-Action" class="headerlink" title="配置 struts.xml 文件及 Action"></a>配置 struts.xml 文件及 Action</h2><h3 id="struts-xml-文件"><a href="#struts-xml-文件" class="headerlink" title="struts.xml 文件"></a>struts.xml 文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE struts PUBLIC</span></span><br><span class="line"><span class="meta">"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"</span></span><br><span class="line"><span class="meta">"http://struts.apache.org/dtds/struts-2.3.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span> = <span class="string">"p1"</span> <span class="attr">extends</span> = <span class="string">"struts-default"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span> = <span class="string">"hello"</span> <span class="attr">class</span> = <span class="string">"com.web.action.HelloAction"</span> <span class="attr">method</span> = <span class="string">"sayHello"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span> = <span class="string">"success"</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    package：表示包<br>​        name：包名，struts.xml 文件中不能有相同的包名，包名是唯一的<br>​        extends：继承，默认 struts-default<br>​    action：动作<br>​        name：相当于 Servlet 的映射路径<br>​        class：处理请求的类，相当于 Servlet<br>​        method：处理请求的方法<br>​    result：结果，返回的 jsp 页面</p><h3 id="Action-编写"><a href="#Action-编写" class="headerlink" title="Action 编写"></a>Action 编写</h3><p>​        在 src 中创建包并创建 Action 类，并创建准备使用的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.web.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Success"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        根据类名和方法名在 struts.xml 中配好相应的名字，配置完成后启动 tomcat 服务即可访问</p><h2 id="Struts2-执行流程"><a href="#Struts2-执行流程" class="headerlink" title="Struts2 执行流程"></a>Struts2 执行流程</h2><ol><li>tomcat 启动服务，加载 web.xml</li><li>web.xml 实例化并初始化过滤器</li><li>加载 struts.xml</li><li>客户端发送请求</li><li>请求到达过滤器</li><li>截取请求 Action 名称，在 struts.xml 中寻找 Action</li><li>找到 Action 后实例化对应的动作类</li><li>调用对应的方法，获取返回值</li><li>根据返回值，找到 name 取值对应的结果视图</li><li>找到 web 页面</li><li>响应浏览器，展示结果</li></ol><h2 id="Struts2-文件加载顺序"><a href="#Struts2-文件加载顺序" class="headerlink" title="Struts2 文件加载顺序"></a>Struts2 文件加载顺序</h2><ol><li>default.properties  //不可修改</li><li>struts-default.xml  //不可修改</li><li>struts-plugin.xml  //不可修改</li><li>struts.xml  //可以修改（推荐）</li><li>struts.properties  //可以修改</li><li>web.xml  //可以修改，可以给过滤器配置参数</li></ol><p>注：如果不同的文件中对相同的属性给予不同的属性值，最终结果会以后加载的文件为准，因为后加载的文件会更新之前加载的属性配置</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Struts-框架&quot;&gt;&lt;a href=&quot;#Struts-框架&quot; class=&quot;headerlink&quot; title=&quot;Struts 框架&quot;&gt;&lt;/a&gt;Struts 框架&lt;/h1&gt;&lt;p&gt;​        Struts2 框架是 Apache 发行的 MVC 开源框架，是表现层 web 框架&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaEE——Struts2框架" scheme="http://yoursite.com/tags/JavaEE%E2%80%94%E2%80%94Struts2%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaEE——网络留言板（未完）</title>
    <link href="http://yoursite.com/2019/09/16/JavaEE%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E7%95%99%E8%A8%80%E6%9D%BF%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2019/09/16/JavaEE——网络留言板（未完）/</id>
    <published>2019-09-16T14:22:06.000Z</published>
    <updated>2019-10-18T03:12:26.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初学-JavaEE"><a href="#初学-JavaEE" class="headerlink" title="初学 JavaEE"></a>初学 JavaEE</h1><p>​        之前学过一点点 Servlet，现在学校开了 JavaEE，正好复习了一下之前的知识</p><h2 id="什么是-JavaEE"><a href="#什么是-JavaEE" class="headerlink" title="什么是 JavaEE"></a>什么是 JavaEE</h2><p>​        JavaEE 可以理解为一套使用 java 为主体的、课跨平台的、快速设计并进行企业级 Web 应用开发的标准</p><p>​        JavaEE 开发应用程序有两种主要方式——JavaWeb 开发和 Java 框架开发</p><a id="more"></a><h3 id="Java-Web-开发"><a href="#Java-Web-开发" class="headerlink" title="Java Web 开发"></a>Java Web 开发</h3><p>​        这是传统的开发方式，核心技术是 JSP、Servlet、JavaBean。这种开发模式的缺点是：没有一套有效的开发规范来约束 JSP 程序员，整个应用系统结构不清晰，项目规模越大越难维护</p><p>###Java 框架开发</p><p>​        在开发中使用现成的的框架可减少代码量、大大降低编程难度，同时也使开发出来的应用系统结构清晰、易于维护</p><h2 id="JavaEE-初体验——留言板"><a href="#JavaEE-初体验——留言板" class="headerlink" title="JavaEE 初体验——留言板"></a>JavaEE 初体验——留言板</h2><p>​        采用 Java Web 开发，使用 JSP + Servlet + JavaBean 完成</p><h3 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC 模式"></a>MVC 模式</h3><p>​        MVC 模式中，应用程序被划分成：模型层（Model）、视图层（View）、控制层（Controller）三部分，MVC 模型就是把一个应用程序的开发按照业务逻辑、数据、视图进行分离分层并组织代码，在这种模式下，Servlet 负责处理用户请求，JSP 负责显示数据和界面、JavaBean 负责封装数据</p><p>​        在这种架构模式下，模型层（Model）定义了数据模型和业务逻辑，为了将数据访问与业务逻辑分离，模型层又具体划分为 DAO 层和业务层，DAO 即 Data Access Object，主要作用是把数据封装起来变成 JavaBean；业务层是整个系统的核心，几乎所有的数据处理、获取到的原始数据都在这一层发生</p><h3 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h3><blockquote><p>Project</p><blockquote><p>.idea</p><p>out</p><p>src</p><blockquote><p>JDBC</p><blockquote><p>jdbcConn.java</p></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>MainServlet</p><blockquote><p>LybServlet</p><p>ServletTest01</p><p>ZcServlet</p></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>UserDao</p><blockquote><p>UserDao</p></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>Users</p><blockquote><p>Users</p></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><p>web</p><blockquote><p>WEB-INF</p><blockquote><p>lib</p><blockquote><p>mysql-connector-java-8.0.16.jar</p></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><p>web.xml</p></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>index.jsp</p><p>LYB.jsp</p><p>MAIN.jsp</p><p>ZC.jsp</p></blockquote></blockquote></blockquote><blockquote><blockquote><p>FirstServlet.iml</p></blockquote></blockquote><h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><p>​        JDBC 类中为 mysql JDBC 驱动，所有需要连接数据库的代码都从此处获得连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JDBC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConn</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">"com.mysql.cj.jdbc.Driver"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">"jdbc:mysql://localhost:3306/servletdemo?serverTimezone=UTC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库的用户名与密码，需要根据自己的设置</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">"root"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String PASS = <span class="string">"lmh12358"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">GetConn</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection conn;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"开始尝试连接数据库"</span>);</span><br><span class="line">            Class.forName(JDBC_DRIVER);</span><br><span class="line">            System.out.println(<span class="string">"注册驱动成功"</span>);</span><br><span class="line">            conn = DriverManager.getConnection(DB_URL, USER, PASS);</span><br><span class="line">            System.out.println(<span class="string">"连接数据库成功"</span>);</span><br><span class="line">            <span class="keyword">return</span> conn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        MainServlet 包下为所有用到的 Servlet，在这些 Servlet 负责控制调度后台 DAO 层的方法</p><p>​        ServletTest01 负责控制登陆界面，调用 UserDao 中的 check 方法来检验用户名密码是否匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> MainServlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.sql.rowset.serial.SerialException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> Users.Users;</span><br><span class="line"><span class="keyword">import</span> UserDao.UserDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletTest01</span> <span class="keyword">extends</span> <span class="title">javax</span>.<span class="title">servlet</span>.<span class="title">http</span>.<span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message = <span class="string">"hello this is Servlet"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response)</span> <span class="keyword">throws</span> javax.servlet.ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response)</span> <span class="keyword">throws</span> javax.servlet.ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String index01 = request.getParameter(<span class="string">"dl"</span>);</span><br><span class="line">        String index02 = request.getParameter(<span class="string">"zc"</span>);</span><br><span class="line">        String username=request.getParameter(<span class="string">"name"</span>);</span><br><span class="line">        String password=request.getParameter(<span class="string">"password"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index02 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Users u = <span class="keyword">new</span> Users();</span><br><span class="line">            u.setName(username);</span><br><span class="line">            u.setPassword(password);</span><br><span class="line">            UserDao us = <span class="keyword">new</span> UserDao();</span><br><span class="line">            <span class="keyword">boolean</span> t = us.check(u);</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"检验成功"</span>);</span><br><span class="line">                response.sendRedirect(<span class="string">"MAIN.jsp"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"失败"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index01 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            response.sendRedirect(<span class="string">"ZC.jsp"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        LybServlet 用来控制留言板页面，留言提交功能通过调用 CommitLY 方法来控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> MainServlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> UserDao.UserDao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(name = <span class="string">"LybServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LybServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String name=request.getParameter(<span class="string">"username"</span>);</span><br><span class="line">        String ly=request.getParameter(<span class="string">"content"</span>);</span><br><span class="line">        UserDao us = <span class="keyword">new</span> UserDao();</span><br><span class="line">        <span class="keyword">boolean</span> t = us.CommitLY(name, ly);</span><br><span class="line">        <span class="keyword">if</span> (t = <span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"留言成功！"</span>);</span><br><span class="line">            response.sendRedirect(<span class="string">"MAIN.jsp"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"servlet失败！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        ZcServlet 用来控制注册界面中，提交用户名密码由 ZcUser 方法来控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> MainServlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> UserDao.UserDao;</span><br><span class="line"><span class="keyword">import</span> Users.Users;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(name = <span class="string">"ZcServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZcServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String username=request.getParameter(<span class="string">"name"</span>);</span><br><span class="line">        String password=request.getParameter(<span class="string">"password"</span>);</span><br><span class="line">        Users u = <span class="keyword">new</span> Users();</span><br><span class="line">        u.setName(username);</span><br><span class="line">        u.setPassword(password);</span><br><span class="line">        UserDao us = <span class="keyword">new</span> UserDao();</span><br><span class="line">        <span class="keyword">boolean</span> t = us.ZcUser(u);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"注册成功"</span>);</span><br><span class="line">            response.sendRedirect(<span class="string">"index.jsp"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"注册失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        DAO 层定义了 UserDao 类用来定义所有 Servlet 调用的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> UserDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Users.Users;</span><br><span class="line"><span class="keyword">import</span> JDBC.JdbcConn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> JdbcConn NewConn = <span class="keyword">new</span> JdbcConn();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(Users user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection conn = NewConn.GetConn();</span><br><span class="line">            Statement stmt = conn.createStatement();</span><br><span class="line">            String sql = <span class="string">"select name,password from user"</span>;</span><br><span class="line">            ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                System.out.println(user.getName()+rs.getString(<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span>(user.getName().equals(rs.getString(<span class="number">1</span>)))&#123;</span><br><span class="line">                    System.out.println(<span class="string">"能比较用户名了"</span>);</span><br><span class="line">                    <span class="keyword">if</span>(user.getPassword().equals(rs.getString(<span class="number">2</span>)))&#123;</span><br><span class="line">                        System.out.println(<span class="string">"匹配成功了"</span>);</span><br><span class="line">                        x=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">CommitLY</span><span class="params">(String name, String ly)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection conn = NewConn.GetConn();</span><br><span class="line">            String sql = <span class="string">"insert into ly values ('"</span> + name + <span class="string">"' ,'"</span> + ly + <span class="string">"');"</span>;</span><br><span class="line">            PreparedStatement ps;</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            ps.executeUpdate();</span><br><span class="line">            System.out.println(<span class="string">"留言成功"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"留言失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ZcUser</span><span class="params">(Users u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection conn = NewConn.GetConn();</span><br><span class="line">            String sql = <span class="string">"insert into USER (NAME, PASSWORD) values ('"</span> + u.getName() + <span class="string">"' ,'"</span> + u.getPassword() + <span class="string">"');"</span>;</span><br><span class="line">            PreparedStatement ps;</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            ps.executeUpdate();</span><br><span class="line">            System.out.println(<span class="string">"注册成功"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"注册失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        Model 层定义了 Users 类，把用户信息封装成 JavaBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Users;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Users</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String UserName;</span><br><span class="line">    <span class="keyword">private</span> String PassWord;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UserName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        UserName = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PassWord;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        PassWord = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;初学-JavaEE&quot;&gt;&lt;a href=&quot;#初学-JavaEE&quot; class=&quot;headerlink&quot; title=&quot;初学 JavaEE&quot;&gt;&lt;/a&gt;初学 JavaEE&lt;/h1&gt;&lt;p&gt;​        之前学过一点点 Servlet，现在学校开了 JavaEE，正好复习了一下之前的知识&lt;/p&gt;
&lt;h2 id=&quot;什么是-JavaEE&quot;&gt;&lt;a href=&quot;#什么是-JavaEE&quot; class=&quot;headerlink&quot; title=&quot;什么是 JavaEE&quot;&gt;&lt;/a&gt;什么是 JavaEE&lt;/h2&gt;&lt;p&gt;​        JavaEE 可以理解为一套使用 java 为主体的、课跨平台的、快速设计并进行企业级 Web 应用开发的标准&lt;/p&gt;
&lt;p&gt;​        JavaEE 开发应用程序有两种主要方式——JavaWeb 开发和 Java 框架开发&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的 javaEE" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84-javaEE/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-1160——拼写单词</title>
    <link href="http://yoursite.com/2019/08/23/LeetCode-1160%E2%80%94%E2%80%94%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/"/>
    <id>http://yoursite.com/2019/08/23/LeetCode-1160——拼写单词/</id>
    <published>2019-08-23T03:00:40.000Z</published>
    <updated>2019-08-23T03:16:27.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拼写单词（简单）"><a href="#拼写单词（简单）" class="headerlink" title="拼写单词（简单）"></a>拼写单词（简单）</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。</p><p>假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。</p><p>​    注意：每次拼写时，chars 中的每个字母都只能用一次。</p><p>​                返回词汇表 words 中你掌握的所有单词的 长度之和。</p><p>​    示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars = &quot;atach&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释： </span><br><span class="line">可以形成字符串 &quot;cat&quot; 和 &quot;hat&quot;，所以答案是 3 + 3 = 6。</span><br><span class="line"></span><br><span class="line">输入：words = [&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;], chars = &quot;welldonehoneyr&quot;</span><br><span class="line">输出：10</span><br><span class="line">解释：</span><br><span class="line">可以形成字符串 &quot;hello&quot; 和 &quot;world&quot;，所以答案是 5 + 5 = 10。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="通过数组计数"><a href="#通过数组计数" class="headerlink" title="通过数组计数"></a>通过数组计数</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​        通过记录每个字符出现的次数，在遍历两个字符串后即可确定结果</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">string</span> chars)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length(); i++)</span><br><span class="line">                a[chars[i] - <span class="string">'a'</span>]++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.size(); i++) &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1 = a;</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; words[i].length(); j++) &#123;</span><br><span class="line">                    a1[words[i][j] - <span class="string">'a'</span>]--;</span><br><span class="line">                    <span class="keyword">if</span> (a1[words[i][j] - <span class="string">'a'</span>] == <span class="number">-1</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">if</span>(j==words[i].length())ans+=words[i].length();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;       </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>​        先遍历一遍字母表字符串，用长度为 26 的数组来记录每个字母出现的次数，再通过遍历单词表中的每一个字母，出现一次就在数组中的数量上 -1，如果数量出现 -1，就不能组成这个单词，否则就可以继续寻找下去，最后返回结果</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;拼写单词（简单）&quot;&gt;&lt;a href=&quot;#拼写单词（简单）&quot; class=&quot;headerlink&quot; title=&quot;拼写单词（简单）&quot;&gt;&lt;/a&gt;拼写单词（简单）&lt;/h1&gt;&lt;h2 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h2&gt;&lt;p&gt;给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。&lt;/p&gt;
&lt;p&gt;假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。&lt;/p&gt;
&lt;p&gt;​    注意：每次拼写时，chars 中的每个字母都只能用一次。&lt;/p&gt;
&lt;p&gt;​                返回词汇表 words 中你掌握的所有单词的 长度之和。&lt;/p&gt;
&lt;p&gt;​    示例&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：words = [&amp;quot;cat&amp;quot;,&amp;quot;bt&amp;quot;,&amp;quot;hat&amp;quot;,&amp;quot;tree&amp;quot;], chars = &amp;quot;atach&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释： &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可以形成字符串 &amp;quot;cat&amp;quot; 和 &amp;quot;hat&amp;quot;，所以答案是 3 + 3 = 6。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：words = [&amp;quot;hello&amp;quot;,&amp;quot;world&amp;quot;,&amp;quot;leetcode&amp;quot;], chars = &amp;quot;welldonehoneyr&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可以形成字符串 &amp;quot;hello&amp;quot; 和 &amp;quot;world&amp;quot;，所以答案是 5 + 5 = 10。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="李明徽的 LeetCode" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84-LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-125——验证回文串</title>
    <link href="http://yoursite.com/2019/08/23/LeetCode-125%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/08/23/LeetCode-125——验证回文串/</id>
    <published>2019-08-23T01:27:05.000Z</published>
    <updated>2019-08-23T02:04:16.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="验证回文串（简单）"><a href="#验证回文串（简单）" class="headerlink" title="验证回文串（简单）"></a>验证回文串（简单）</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p>​    说明：本题中，我们将空字符串定义为有效的回文串。</p><p>​    示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="C-双指针法解决"><a href="#C-双指针法解决" class="headerlink" title="C++双指针法解决"></a>C++双指针法解决</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​        首先，验证一个普通的标准字符串是不是回文串就是看前后对应位置的字符是不是相同，这明显时要用到双指针前后并行着对照呀</p><p>​        不过根据题目的要求，空格应不计算在内，所以这里要在每次检测元素是否对称前先排除掉中间的空格，并且统一将对应元素转换成小写或者大写来进行比较</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>, j = s.size() - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (s.size() &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; !<span class="built_in">isalnum</span>(s[i]))</span><br><span class="line">          i++;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; !<span class="built_in">isalnum</span>(s[j]))</span><br><span class="line">          j--;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[i++]) != <span class="built_in">tolower</span>(s[j--]))</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>​        使用 i 和 j 表示字符串的头尾索引，之后通过一个大循环遍历字符串，在大循环中，要通过两个小循环分别检测当前首位位置是否存在空格，使用循环的目的是防止连续空格，最后通过将对应位置呃赐福全部转换为小写，比较是否相等</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;验证回文串（简单）&quot;&gt;&lt;a href=&quot;#验证回文串（简单）&quot; class=&quot;headerlink&quot; title=&quot;验证回文串（简单）&quot;&gt;&lt;/a&gt;验证回文串（简单）&lt;/h1&gt;&lt;h2 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h2&gt;&lt;p&gt;给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。&lt;/p&gt;
&lt;p&gt;​    说明：本题中，我们将空字符串定义为有效的回文串。&lt;/p&gt;
&lt;p&gt;​    示例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;A man, a plan, a canal: Panama&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;race a car&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="李明徽的LeetCode" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>数据结构（七）——树与二叉树</title>
    <link href="http://yoursite.com/2019/08/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/08/19/数据结构（七）——树与二叉树/</id>
    <published>2019-08-19T01:30:08.000Z</published>
    <updated>2019-08-22T02:57:13.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>​        树是数据结构中的一种非线性结构，树形结构节点间的关系是除了头节点（根 root）外，每个节点都存在唯一的前驱，但不唯一的后继，也就是说树形结构中节点的关系是一对多的关系，这篇文章主要说一下代码方面实现的过程，理论上设计的比较少</p><a id="more"></a><h3 id="普通树的定义"><a href="#普通树的定义" class="headerlink" title="普通树的定义"></a>普通树的定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双亲存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">int</span> parent;<span class="comment">//指向双亲位置</span></span><br><span class="line">&#125;PTree[MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">//孩子链存储指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">node* sons[MAXSIZE];<span class="comment">//指向孩子节点</span></span><br><span class="line">&#125;TSonNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//孩子兄弟链存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">tnode *hp;<span class="comment">//指向兄弟</span></span><br><span class="line">tnode *vp;<span class="comment">//指向孩子节点</span></span><br><span class="line">&#125;TSBNode;</span><br></pre></td></tr></table></figure><p>​        另外树的操作，我将通过二叉树实现并说明实现原理</p><h2 id="树——二叉树"><a href="#树——二叉树" class="headerlink" title="树——二叉树"></a>树——二叉树</h2><p>​        二叉树是一种十分常用的特殊的树状存储结构，由一个根节点（root）和根节点左右两侧的左子树和右子树组成，一棵二叉树的每个节点最多只能含有两个子节点，且要区分开左孩子和右孩子</p><p>​        满二叉树和完全二叉树是二叉树中的两种状态，满二叉树即除最底层的节点外，每个节点都拥有自己的左孩子和右孩子，完全二叉树的特点则是最多只有下面两层的节点度数小于二，并且最下面一层的叶节点都依次排在该层最左边的位置上</p><p>​        同样也是因为二叉树树状存储结构的特性，在各种操作的实现算法中会经常使用递归操作</p><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><p>​        二叉树的存储结构分为顺序存储和链式存储</p><p>​        在二叉树的顺序存储结构中，想要查找一个结点的双亲和孩子节点都很容易，但是对于一般的二叉树来说，空间的浪费十分惊人，所以这里我们主要讨论二叉树的链式存储结构</p><h3 id="二叉树的链式存储结构"><a href="#二叉树的链式存储结构" class="headerlink" title="二叉树的链式存储结构"></a>二叉树的链式存储结构</h3><p>​        除了定义必要的指针外，二叉链比较节省存储空间；在二叉链中，查找一个节点的孩子很容易，但是查找双亲不方便</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉链，二叉树的链式存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DTnode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">DTnode *lchild, *rchild;</span><br><span class="line">&#125;DTnode;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;DTnode*&gt; s;</span><br><span class="line"><span class="comment">//栈在初始化二叉树时使用</span></span><br></pre></td></tr></table></figure><h4 id="创建二叉链"><a href="#创建二叉链" class="headerlink" title="创建二叉链"></a>创建二叉链</h4><p>​        创建二叉链，是比较复杂的操作，这个操作的思想是，通过一个 “1(2(3(,4)),5(6,7))” 这种可以表示二叉树中每个节点的值的字符串，在遍历这个字符串的过程中，通过不同位置字符的不同来运行不同的代码实现创建二叉树</p><p>​        ch 是用来记录当前遍历位置字符的变量，从 str 的第一个字符开始遍历，当前根节点；一定是为空的，所以把第一个元素的值设置成头节点的值，使用栈的原理，如果遇到 ‘(’ 就先将当前的节点 p 进栈，之后根据 k 的值，来决定将数据赋给栈顶元素的左孩子还是右孩子，最后在遇到 ‘)’ 时就代表当前栈的双亲结点已经定义完，就弹出他</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DTnode *<span class="title">CreateDTnode</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">DTnode *b ;</span><br><span class="line">DTnode *p;</span><br><span class="line"><span class="keyword">int</span> k, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">b = <span class="literal">NULL</span>;</span><br><span class="line">ch = str[j];</span><br><span class="line"><span class="keyword">while</span> (ch != <span class="string">'\0'</span>) &#123;</span><br><span class="line"><span class="keyword">switch</span> (ch) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'('</span>: s.push(p); k = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">')'</span>: s.pop(); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">','</span>: k = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">p = (DTnode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DTnode));</span><br><span class="line">p-&gt;data = ch - <span class="string">'0'</span>;</span><br><span class="line">p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line">b = p;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (k) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: s.top()-&gt;lchild = p; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: s.top()-&gt;rchild = p; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">j++;</span><br><span class="line">ch = str[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树深度"><a href="#二叉树深度" class="headerlink" title="二叉树深度"></a>二叉树深度</h4><p>​        通过递归操作来计算二叉树的深度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DTnodeDepth</span><span class="params">(DTnode *b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lchilddep, rchilddep;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">lchilddep = DTnodeDepth(b-&gt;lchild);</span><br><span class="line">rchilddep = DTnodeDepth(b-&gt;rchild);</span><br><span class="line"><span class="keyword">return</span> (lchilddep &gt; rchilddep) ? (lchilddep + <span class="number">1</span>) : (rchilddep + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打印二叉树"><a href="#打印二叉树" class="headerlink" title="打印二叉树"></a>打印二叉树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PTree</span><span class="params">(DTnode *dt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dt == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dt-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">PTree(dt-&gt;lchild);</span><br><span class="line">PTree(dt-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><p>​        同样是通过递归算法，查找符合给定值的节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DTnode *<span class="title">FindNode</span><span class="params">(DTnode *b, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">DTnode *p;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b-&gt;data == x)</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">p = FindNode(b-&gt;lchild, x);</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> FindNode(b-&gt;rchild, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>​        图片加不上去实在是太难受了！口述吧！</p><p>​        先给一个二叉树</p><p>​        A(B(D,F(E,)),C(G(,H),I))</p><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>​        先序遍历的顺序是先遍历根节点，再遍历左子树，最后遍历右子树</p><p>​        例子中给的二叉树，按照先序遍历排列得到的就是</p><p>​        ABDFECGHI</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FOrder</span><span class="params">(DTnode *dt)</span> </span>&#123;</span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="keyword">if</span> (dt == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dt-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">FOrder(dt-&gt;lchild);</span><br><span class="line">FOrder(dt-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>​        中序遍历的顺序是先遍历左子树，访问根节点，再遍历右子树</p><p>​        结果为：DBEFAGHCI</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">COrder</span><span class="params">(DTnode *dt)</span> </span>&#123;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">if</span>(dt == <span class="literal">NULL</span>) </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">COrder(dt-&gt;lchild);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dt-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">COrder(dt-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>​        后序遍历的顺序是先遍历左子树，再遍历右子树，最后访问根节点</p><p>​        结果为：DEFBHGICA</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LPerOrder</span><span class="params">(DTnode *dt)</span> </span>&#123;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">if</span> (dt == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">LPerOrder(dt-&gt;lchild);</span><br><span class="line">LPerOrder(dt-&gt;rchild);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dt-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;树&quot;&gt;&lt;a href=&quot;#树&quot; class=&quot;headerlink&quot; title=&quot;树&quot;&gt;&lt;/a&gt;树&lt;/h1&gt;&lt;p&gt;​        树是数据结构中的一种非线性结构，树形结构节点间的关系是除了头节点（根 root）外，每个节点都存在唯一的前驱，但不唯一的后继，也就是说树形结构中节点的关系是一对多的关系，这篇文章主要说一下代码方面实现的过程，理论上设计的比较少&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的树" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-1、167——两数相加</title>
    <link href="http://yoursite.com/2019/08/16/LeetCode-1%E3%80%81167%E2%80%94%E2%80%94%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://yoursite.com/2019/08/16/LeetCode-1、167——两数相加/</id>
    <published>2019-08-16T00:39:37.000Z</published>
    <updated>2019-08-23T01:36:39.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两数之和（一、二）"><a href="#两数之和（一、二）" class="headerlink" title="两数之和（一、二）"></a>两数之和（一、二）</h1><p>​        LeetCode 上的两个两数之和问题，一个是输入的有序数组，一个无序，解法稍有偏差，这里在何涛大佬的帮助下多放几种解法！</p><a id="more"></a><h2 id="两数之和（输入有序数组）"><a href="#两数之和（输入有序数组）" class="headerlink" title="两数之和（输入有序数组）"></a>两数之和（输入有序数组）</h2><h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p>​        给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>​        函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p><p>说明:</p><p>​        返回的下标值（index1 和 index2）不是从零开始的。<br>​        你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。<br>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: numbers = [2, 7, 11, 15], target = 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2</span><br></pre></td></tr></table></figure><h3 id="暴力解决"><a href="#暴力解决" class="headerlink" title="暴力解决"></a>暴力解决</h3><p>​        嵌套 for 循环，时间复杂度 O(n²)，慢就完事了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="双指针解决"><a href="#双指针解决" class="headerlink" title="双指针解决"></a>双指针解决</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>​        双指针解法，定义头尾两个指针分别代表输入数组的首末元素，定义 while 循环检测两元素相加与 target 对比大小，小的话就头指针后移，大的话就尾指针前移（因为数组是有序的！），这样折半查找来找到这两个数</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = numbers.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[l] + numbers[r] &gt; target)</span><br><span class="line">                r--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (numbers[l] + numbers[r] &lt; target)</span><br><span class="line">                l++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;l + <span class="number">1</span>, r + <span class="number">1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="两数之和（输入无序数组）"><a href="#两数之和（输入无序数组）" class="headerlink" title="两数之和（输入无序数组）"></a>两数之和（输入无序数组）</h2><h3 id="题目要求-1"><a href="#题目要求-1" class="headerlink" title="题目要求"></a>题目要求</h3><p>​        给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>​        你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><h3 id="使用-unordered-map-解决"><a href="#使用-unordered-map-解决" class="headerlink" title="使用 unordered_map 解决"></a>使用 unordered_map 解决</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>​        首先因为输入的数组是无序的，不可以直接使用双指针的解法来作答，但是既然不能两个元素两个元素查，那就一个元素一个元素查吧！先定义一个 unordered_map（使用无序 map 是因为要比普通 map 更快），然后使用 for 循环来遍历整个数组，流程是：两个数相加遍历时两个加数总要有一个先被遍历到，这时候因为 map 中没有与之匹配的另一个加数，这时候就把当前遍历到这个加数放进 map 中，等到循环遍历到另一个加数时，就可检测到之前放入 map 中的加数，这样这道题就解决了</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> another = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(m.count(another))</span><br><span class="line">                <span class="keyword">return</span> &#123;m[another], i&#125;;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="先排序再用双指针"><a href="#先排序再用双指针" class="headerlink" title="先排序再用双指针"></a>先排序再用双指针</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>​        既然输入的数组无序！那就给他排序！排序后就可以按照有序数组的解法来解决啦，不过这里需要注意数组下标的问题，因为重新排序后，原数组的下标就被打乱了，所以需要使用另一个数组先记录原数组的个元素位置，最后再另一个数组里找到元素组对应元素的下标值返回就好了</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; n, <span class="keyword">int</span> t) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        m=n;</span><br><span class="line">        sort(n.begin(),n.end());</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=n.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n[l]+n[r]&gt;t)r--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n[l]+n[r]&lt;t)l++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;l)<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m[i]==n[l]||m[i]==n[r])ans.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;两数之和（一、二）&quot;&gt;&lt;a href=&quot;#两数之和（一、二）&quot; class=&quot;headerlink&quot; title=&quot;两数之和（一、二）&quot;&gt;&lt;/a&gt;两数之和（一、二）&lt;/h1&gt;&lt;p&gt;​        LeetCode 上的两个两数之和问题，一个是输入的有序数组，一个无序，解法稍有偏差，这里在何涛大佬的帮助下多放几种解法！&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的LeetCode" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>神奇的动态数组——vector</title>
    <link href="http://yoursite.com/2019/08/14/%E7%A5%9E%E5%A5%87%E7%9A%84%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E2%80%94%E2%80%94vector/"/>
    <id>http://yoursite.com/2019/08/14/神奇的动态数组——vector/</id>
    <published>2019-08-14T15:01:18.000Z</published>
    <updated>2019-08-15T12:20:08.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="神奇的-Vector-动态数组"><a href="#神奇的-Vector-动态数组" class="headerlink" title="神奇的 Vector 动态数组"></a>神奇的 Vector 动态数组</h1><h2 id="什么是-Vector"><a href="#什么是-Vector" class="headerlink" title="什么是 Vector"></a>什么是 Vector</h2><p>​        Vector 是一个动态数组（dynamic array），提供了很多操作的接口，使用 Vector 需要引入头文件 #include<vector> 并且一定要声明命名空间 std，因为 Vector 是定义在 std 里 template 中的</vector></p><p>​        Vector 是一种动态的顺序表结构，可以像数组一样访问、随机访问、只用迭代器访问其中的元素</p><a id="more"></a><h2 id="Vector-的属性"><a href="#Vector-的属性" class="headerlink" title="Vector 的属性"></a>Vector 的属性</h2><h3 id="大小和容量"><a href="#大小和容量" class="headerlink" title="大小和容量"></a>大小和容量</h3><p>​        对于常规数组来说，最大的限制就是其大小必须事先定义好，而 Vector 中通过 size() 和 capacity() 分别来表示其大小和容量，其中 size() 用来表示大小，即 Vector 中当前存放了多少数据；capacity() 用来表示容量，即 Vector 中最大存放的数据是多少，而当 size() 将要超过 capacity() 时，Vector 会自动扩充其容量，这就是 Vector 是动态数组的原因</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;<span class="comment">//定义 int 类型的 Vector</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">a.push_back(i);<span class="comment">//在 Vector 尾部添加元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" size = "</span> &lt;&lt; a.size() &lt;&lt; <span class="string">" capacity = "</span> &lt;&lt; a.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        以上代码可以很好的反应 capacity() 可以自行扩大的特性</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;DataType&gt; item;<span class="comment">//定义 Vector</span></span><br><span class="line"><span class="built_in">vector</span>&lt;DataType&gt; item(n);<span class="comment">//初始化 Vector 的容量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;DataType&gt; item(<span class="keyword">int</span>, DataType);<span class="comment">//初始化 Vector 的容量并且使其内容全部为 Datatype</span></span><br><span class="line"><span class="built_in">vector</span>&lt;DataType&gt; item(it.begin(), it.end());<span class="comment">//传进一个迭代器区间用来为 Vector 赋值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;DataType&gt; item(Class);<span class="comment">//传进一个对象，执行其构造函数</span></span><br></pre></td></tr></table></figure><p>​        Vector 动态数组里可以存放任何类型的变量，但前提是一个 Vector 只能存放同一种类型的数据，并且 Vector 中有很多定义方法，可以根据需求使用不同的方法来定义你的 Vector</p><h3 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; item;</span><br><span class="line">item.empty();<span class="comment">//布尔型函数，空返回 true，非空返回 false</span></span><br><span class="line">item.size();<span class="comment">//返回当前 Vector 的元素数量</span></span><br><span class="line">item.max_size();<span class="comment">//返回当前 Vector 可容纳的最大元素数量</span></span><br><span class="line">item.capacity();<span class="comment">//返回当前 Vector 的容量</span></span><br><span class="line">item.reserve(n);<span class="comment">//重新设定当前 Vector 的容量，若新值小于当前值，则语句无效</span></span><br><span class="line">item.shrink_to_fit();<span class="comment">//修改当前 Vector 的容量为其 size() 值</span></span><br><span class="line">item.assign(n, data);<span class="comment">//将n个数据 data 添加进 Vector 中</span></span><br><span class="line">item.assign(begin(), end());<span class="comment">//复制迭代器中 begin 到 end 的内容并赋值给 Vector</span></span><br><span class="line">item.swap(Vector);</span><br><span class="line">swap(item, Vector);<span class="comment">//以上两个方法都是用来交换两个 Vector 中的元素的</span></span><br><span class="line">item.push_back(data);<span class="comment">//在 Vector 末尾插入新元素 data</span></span><br><span class="line">item.pop_back();<span class="comment">//移除 Vector 的最后一个元素</span></span><br><span class="line">item.insert(pos, data);<span class="comment">//在 pos 的位置插入 data，并返回这个 data 的 pos（int 类型）</span></span><br><span class="line">item.insert(pos, n, data);<span class="comment">//在 pos 的位置上插入 n 个 data，并返回第一个 data 的位置</span></span><br><span class="line">item.insert(pos, begin(), end());<span class="comment">//在 pos 的位置上，添加一段迭代器返回的值</span></span><br></pre></td></tr></table></figure><h3 id="迭代器！"><a href="#迭代器！" class="headerlink" title="迭代器！"></a>迭代器！</h3><p>​        迭代器用来访问 Vector 中的数据元素，这也是 Vector 特有的功能，使用迭代器可以实现一种十分简便的遍历方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it1 = item.begin();</span><br><span class="line"><span class="comment">//指向首个元素的迭代器</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;::iterator it1 = item.begin();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator it1 = item.end();</span><br></pre></td></tr></table></figure><p>​        迭代器可以正反迭代</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = a.cbegin(); it != a.cend(); it++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br></pre></td></tr></table></figure><p>​        auto 在 C++ 11 中的作用是自动推断变量类型，但是必须在定义时就初始化该变量，类似于 const</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        Vector 的本质就是一个动态数组，因为基本操作上是一个有序容器，所以也可以当作栈或者表来使用</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;神奇的-Vector-动态数组&quot;&gt;&lt;a href=&quot;#神奇的-Vector-动态数组&quot; class=&quot;headerlink&quot; title=&quot;神奇的 Vector 动态数组&quot;&gt;&lt;/a&gt;神奇的 Vector 动态数组&lt;/h1&gt;&lt;h2 id=&quot;什么是-Vector&quot;&gt;&lt;a href=&quot;#什么是-Vector&quot; class=&quot;headerlink&quot; title=&quot;什么是 Vector&quot;&gt;&lt;/a&gt;什么是 Vector&lt;/h2&gt;&lt;p&gt;​        Vector 是一个动态数组（dynamic array），提供了很多操作的接口，使用 Vector 需要引入头文件 #include&lt;vector&gt; 并且一定要声明命名空间 std，因为 Vector 是定义在 std 里 template 中的&lt;/vector&gt;&lt;/p&gt;
&lt;p&gt;​        Vector 是一种动态的顺序表结构，可以像数组一样访问、随机访问、只用迭代器访问其中的元素&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vector动态数组" scheme="http://yoursite.com/tags/Vector%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
</feed>
