<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Step By Step</title>
  
  <subtitle>耀出千分光</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-01T12:00:10.052Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LiMinghui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python——正则表达式</title>
    <link href="http://yoursite.com/2020/02/01/Python%E2%80%94%E2%80%94%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/02/01/Python——正则表达式/</id>
    <published>2020-02-01T10:56:03.000Z</published>
    <updated>2020-02-01T12:00:10.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-中的正则表达式"><a href="#Python-中的正则表达式" class="headerlink" title="Python 中的正则表达式"></a>Python 中的正则表达式</h1><p>​        正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定的字符串、及这些特定字符的组合，组成一个”规则字符串“，这个规则字符串用来表示对字符串的一种过滤逻辑</p><p>​        字符串是编程时涉及到的最多的一种数据结构，使用正则表达式可以完成判断一个字符串是否为合法电话号、是否是 Email 格式等操作</p><p>​        文章最后符一些常用的正则表达式！</p><a id="more"></a><h2 id="正则表达式通用符号及解释"><a href="#正则表达式通用符号及解释" class="headerlink" title="正则表达式通用符号及解释"></a>正则表达式通用符号及解释</h2><table><thead><tr><th align="center">模式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">.</td><td align="center">匹配任意除 <code>\n</code>外的字符</td></tr><tr><td align="center">\</td><td align="center">转义字符，是一个特殊字符原来的意思</td></tr><tr><td align="center">[…]</td><td align="center">对应位置可以是字符集中的任意字符</td></tr><tr><td align="center">\d</td><td align="center">数字（0~9）</td></tr><tr><td align="center">\D</td><td align="center">非数字</td></tr><tr><td align="center">\s</td><td align="center">空白字符（空格、\t、\r、\n、\f、\v）</td></tr><tr><td align="center">\S</td><td align="center">非空白字符</td></tr><tr><td align="center">\w</td><td align="center">单词字符（A<del>Z、a</del>z、0~9）</td></tr><tr><td align="center">\W</td><td align="center">非单词字符</td></tr><tr><td align="center">*</td><td align="center">匹配前一个字符 0 或 无限次</td></tr><tr><td align="center">+</td><td align="center">匹配前一个字符 1 或 无限次</td></tr><tr><td align="center">？</td><td align="center">匹配前一个字符 0 或 1 次</td></tr><tr><td align="center">{m}</td><td align="center">匹配前一个字符串 m 次</td></tr><tr><td align="center">{m, n}</td><td align="center">匹配前一个字符串 m 至 n 次</td></tr><tr><td align="center">^</td><td align="center">匹配字符串开头</td></tr><tr><td align="center">$</td><td align="center">匹配字符串末尾</td></tr><tr><td align="center">\A</td><td align="center">仅匹配字符串开头</td></tr><tr><td align="center">\Z</td><td align="center">仅匹配字符串末尾</td></tr><tr><td align="center">\b</td><td align="center">匹配 \w 和 \W 之间</td></tr><tr><td align="center">\B</td><td align="center">与上一个相反</td></tr></tbody></table><h2 id="re-模块"><a href="#re-模块" class="headerlink" title="re 模块"></a>re 模块</h2><p>​        python 通过导入 re 模块来使用正则表达式功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure><h3 id="re-compile"><a href="#re-compile" class="headerlink" title="re.compile"></a>re.compile</h3><p>​        compile 函数的返回值是一个 <code>pattern</code>（正则表达式对象），是用来自己定义正则表达式的函数，下面的句子是描述一个以 he 开头，后面接任意字符，并且以 o 结尾的字符串的正则表达式，例如 hello</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r'^(he)+.*o$'</span>)</span><br></pre></td></tr></table></figure><h3 id="re-match"><a href="#re-match" class="headerlink" title="re.match"></a>re.match</h3><p>​        match 函数是根据给定的正则表达式，来判定一个字符串是否符合规则的函数，匹配成功返回一个 match 对象，否则返回 None，下面是以上边 compile 函数返回的正则表达式为基础，对字符串检测的语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result = re.match(pattern, <span class="string">'hello'</span>)</span><br><span class="line">result = re.match(pattern, <span class="string">'hello'</span>, re.l)</span><br><span class="line"><span class="comment"># match 函数的第三个参数 flag 为可选参数，表示标志位，用于控制正则表达式的匹配方式，有如下用法：</span></span><br><span class="line"><span class="comment"># re.l 使匹配对大小写不敏感</span></span><br><span class="line"><span class="comment"># re.L 使匹配对大小写不敏感</span></span><br><span class="line"><span class="comment"># re.M 多行匹配</span></span><br><span class="line"><span class="comment"># re.S 使 . 匹配包括换行在内的左右字符</span></span><br><span class="line"><span class="comment"># re.U 根据 Unicode 字符集解析字符</span></span><br><span class="line"><span class="comment"># re.X 使格式更灵活，以便正则表达式更易于理解</span></span><br></pre></td></tr></table></figure><h3 id="match-group"><a href="#match-group" class="headerlink" title="match.group"></a>match.group</h3><p>​        这个函数是用来获取匹配后的字符串的，它的返回值是一个元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号</span></span><br><span class="line">result.group()</span><br><span class="line"><span class="comment"># 返回一个包含 num 指定小组所对应值的元组</span></span><br><span class="line">result.group(num)</span><br></pre></td></tr></table></figure><h3 id="re-search"><a href="#re-search" class="headerlink" title="re.search"></a>re.search</h3><p>​        search 函数的用法和 match 函数很接近，search 函数会扫描整个字符串并返回第一个成功的匹配，也是一个 match 对象，使用的参数也与 match 函数相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = re.search(pattern1, str)</span><br><span class="line">res = re.search(pattern1, str, re.l)</span><br></pre></td></tr></table></figure><p>​        二者的区别在于，match 函数只匹配字符串的开始，如果开始不符合，就会匹配失败，而 search 函数会匹配整个字符串，直到找到一个匹配</p><h3 id="re-findall"><a href="#re-findall" class="headerlink" title="re.findall"></a>re.findall</h3><p>​        findall 函数会找到字符串中所有符合正则表达式规则的字符串，返回值是一个列表，如果没有匹配，就会返回一个空列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res1 = re.findall(pattern1, str)</span><br></pre></td></tr></table></figure><h3 id="re-finditer"><a href="#re-finditer" class="headerlink" title="re.finditer"></a>re.finditer</h3><p>​        finditer 也是查找所有符合正则表达式规则的字符串，不同的是返回值，finditer 返回的是一个迭代器，用法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> re.finditer(pattern1, str):</span><br><span class="line">    print(item.group())</span><br></pre></td></tr></table></figure><h2 id="小样例"><a href="#小样例" class="headerlink" title="小样例"></a>小样例</h2><p>​        常用的正则表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</span><br><span class="line"></span><br><span class="line">2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?</span><br><span class="line"></span><br><span class="line">3. InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 手机号码：^(<span class="number">13</span>[<span class="number">0</span><span class="number">-9</span>]|<span class="number">14</span>[<span class="number">5</span>|<span class="number">7</span>]|<span class="number">15</span>[<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">5</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9</span>]|<span class="number">18</span>[<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">5</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9</span>])\d&#123;<span class="number">8</span>&#125;$</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 电话号码(<span class="string">"XXX-XXXXXXX"</span>、<span class="string">"XXXX-XXXXXXXX"</span>、<span class="string">"XXX-XXXXXXX"</span>、<span class="string">"XXX-XXXXXXXX"</span>、<span class="string">"XXXXXXX"</span>和<span class="string">"XXXXXXXX)：^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">6. 国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">7. 身份证号(15位、18位数字)：^\d&#123;15&#125;|\d&#123;18&#125;$</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-中的正则表达式&quot;&gt;&lt;a href=&quot;#Python-中的正则表达式&quot; class=&quot;headerlink&quot; title=&quot;Python 中的正则表达式&quot;&gt;&lt;/a&gt;Python 中的正则表达式&lt;/h1&gt;&lt;p&gt;​        正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定的字符串、及这些特定字符的组合，组成一个”规则字符串“，这个规则字符串用来表示对字符串的一种过滤逻辑&lt;/p&gt;
&lt;p&gt;​        字符串是编程时涉及到的最多的一种数据结构，使用正则表达式可以完成判断一个字符串是否为合法电话号、是否是 Email 格式等操作&lt;/p&gt;
&lt;p&gt;​        文章最后符一些常用的正则表达式！&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的Python" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84Python/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JAVA中的流</title>
    <link href="http://yoursite.com/2020/01/31/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JAVA%E4%B8%AD%E7%9A%84%E6%B5%81/"/>
    <id>http://yoursite.com/2020/01/31/JAVA基础——JAVA中的流/</id>
    <published>2020-01-31T11:41:20.000Z</published>
    <updated>2020-01-31T13:33:13.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-JAVA-中的“流”"><a href="#什么是-JAVA-中的“流”" class="headerlink" title="什么是 JAVA 中的“流”"></a>什么是 JAVA 中的“流”</h1><p>​        流是一种抽象出来的概念，当数据在介质中传输，就形成了流，所以流就是用来进行数据的传输的</p><a id="more"></a><h2 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h2><p>​        JAVA 中的流根据其在方向上、处理数据单元上、使用方式上可以分为很多种类</p><p>​        流可以分为输入流和输出流两大类， I（input）和 O（output），即我们常说的 I/O 流，这里的输入和输出是对 JAVA 程序来说的，数据流向 JAVA 程序时，是流入，即输入流，数据从 JAVA 程序中输出时，是流出，即输出流</p><p>​        又可以根据数据单元的不同，分为字节流和字符流，字节流可以处理所有类型的数据，因为它是一个字节一个字节的去读取数据的，而字符流则更适合处理文本数据，他们和输入流及输出流的概念并不冲突</p><h2 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h2><p>​        输入流是指将数据读入到 JAVA 程序中，包括 <code>Reader</code>、<code>InputStream</code> 以及它们的子类，一下以实例说明用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">    br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"F://lmh.txt"</span>));</span><br><span class="line">    String str = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((str = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (br != <span class="keyword">null</span>) &#123;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这个样例是以 <code>FileReader</code> 为基础，使用包装流 <code>Buffered</code> 包装，将一个文件中的数据读入程序中，所有的输入流中，都包含 read 方法用来读入数据，与字节流不同的是，字符流中的 <code>Reader</code> 支持 <code>readLine</code> 方法，可以将一行数据一次性读入，这也证明了字符流更适合操作文本数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"F:/lmh.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file.exists())</span><br><span class="line">        file.createNewFile();</span><br><span class="line">    String path = file.getPath();</span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10000</span>];</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">    <span class="keyword">int</span> fisRead = <span class="number">0</span>;</span><br><span class="line">    fisRead = fis.read(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这个样例是一个典型的，使用字节流向 JAVA 程序读入数据的功能，这里的读入使用 read 函数，read 函数有三种使用方法，一种是无参的读入，<code>read()</code> ，它不会存储读入的数据，只是一味的将读入指针在文件中后移，第二种是有参的读入，<code>read(byte[] bt)</code>，它会存储读入的数据，保存在名为 bt 的 byte 数组中，第三种是 <code>read(byte[] bt, int orr, int len)</code>，它是从输入流读取 len 个字节的数据到 bt 数组，off 为 bt 数组的起始偏移量，这也体现了字符流和字节流在读入数据时的区别</p><h2 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h2><p>​        输出流是将数据从 JAVA 程序输出到控制台或者文件中的流，可以理解为流出 JAVA 程序，包括 <code>Writer</code> 和 <code>OutputStream</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">    BufferedWriter bw = <span class="keyword">null</span>;</span><br><span class="line">    br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"F://lmh.txt"</span>));</span><br><span class="line">    bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"F://lmh01.txt"</span>));</span><br><span class="line">    String str = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((str = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bw.write(str, <span class="number">0</span>, str.length());</span><br><span class="line">        bw.newLine();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (br != <span class="keyword">null</span> || bw != <span class="keyword">null</span>) &#123;</span><br><span class="line">        br.close();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这个样例是一个先使用 <code>Reader</code> 读入数据，再将读入到的数据使用 <code>Writer</code> 写入另一个文件的功能，使用包装流 <code>BufferedWriter</code> 对 <code>FileWriter</code> 进行包装，可以提高运行效率，在使用 <code>Writer</code> 中定义的 write 方法，将其写入到文件中，write 方法有三种，一种是<code>write(char c)</code>，将指定的字符写入，第二种是<code>write(CharSequence cs)</code>，将指定的字符序列写入，第三种是<code>write(CharSequence cs, int off, int len)</code>，写入字符序列 cs 中从 off 位置开始，长度为 len 的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DataInputStream dis = <span class="keyword">null</span>;</span><br><span class="line">    DataOutputStream dos = <span class="keyword">null</span>;</span><br><span class="line">    dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"C://Users//StephenCurry//Desktop//chance//IMA//curry.jpg"</span>));</span><br><span class="line">    dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"C://Users//StephenCurry//Desktop//chance//IMA//curry5.jpg"</span>));</span><br><span class="line">    <span class="keyword">byte</span>[] bt = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024000</span>];</span><br><span class="line">    <span class="keyword">int</span> length = dis.read(bt);</span><br><span class="line">    dos.write(bt, <span class="number">0</span>, length);</span><br><span class="line">    <span class="keyword">if</span> (dis != <span class="keyword">null</span> || dos != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dis.close();</span><br><span class="line">        dos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这个样例就比较有趣了，使用字节流读入一张 jpg 的图片，再使用字节流输出到一个空的 jpg 文件中，实现文件的复制，因为是图片，这里必须使用字节流，使用 write 函数，将读入的字节数据，全部写入到另一个文件中，便完成了文件的复制</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        这里说的只不过是流的简单用法，最重要的是，每种流都有它最擅长的地方，学会在什么情景下使用什么流，才是最关键的</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是-JAVA-中的“流”&quot;&gt;&lt;a href=&quot;#什么是-JAVA-中的“流”&quot; class=&quot;headerlink&quot; title=&quot;什么是 JAVA 中的“流”&quot;&gt;&lt;/a&gt;什么是 JAVA 中的“流”&lt;/h1&gt;&lt;p&gt;​        流是一种抽象出来的概念，当数据在介质中传输，就形成了流，所以流就是用来进行数据的传输的&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>算法——双指针算法</title>
    <link href="http://yoursite.com/2020/01/17/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/01/17/算法——双指针算法/</id>
    <published>2020-01-17T13:56:51.000Z</published>
    <updated>2020-01-17T14:38:40.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h1><p>​        双指针算法是指一切采用双指针的方式，降低原本暴力解法的时间复杂度的算法，通常双指针算法可以将暴力的 <code>O(n^2)</code>降低到 <code>O(n)</code></p><p>​        由于双指针算法指的是一类算法，下面我用两道题来简单解释一下</p><a id="more"></a><h2 id="单词个数问题"><a href="#单词个数问题" class="headerlink" title="单词个数问题"></a>单词个数问题</h2><p>​        即查找一段字符串中，以空格为分隔的单词的个数，这道题用暴力法完全可解，外层 for 循环遍历整个字符数组，内层 for 循环检测 <code>&#39; &#39;</code> 字符，但是显然这种方法时间复杂度是 <code>O(n^2)</code></p><p>​        如果采用双指针算法， 外层循环用来控制遍历字符串，内层循环直接跳到 <code>&#39; &#39;</code> 处，记住这个单词后，直接将外层循环跳到 <code>&#39; &#39;</code> 的下一位继续执行，时间复杂度便为 <code>&#39;O(n)&#39;</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numStr</span><span class="params">(<span class="keyword">char</span> str[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> length = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">while</span> (str[l]) &#123;</span><br><span class="line"><span class="keyword">while</span> (r &lt;= length &amp;&amp; str[r] != <span class="string">' '</span>)</span><br><span class="line">r++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt; r; k++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str[k];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">sum++;</span><br><span class="line">l = ++r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = numStr(<span class="string">"hello world !"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"有 "</span> &lt;&lt; sum &lt;&lt; <span class="string">" 个单词"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长连续不重复子序列问题"><a href="#最长连续不重复子序列问题" class="headerlink" title="最长连续不重复子序列问题"></a>最长连续不重复子序列问题</h2><p>​        首先，这个问题也可以使用暴力法，嵌套 for 循环，可以解决问题，但是速度慢且代码复杂</p><p>​        采用双指针算法的思想，第一个指针持续后移，使用另一个数组统计每个数字出现的次数来控制第二个指针的移动，以此来计算不重复子序列，时间复杂度可达到 <code>O(n)</code></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">s[a[i]]++;</span><br><span class="line"><span class="keyword">while</span> (s[a[i]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">s[a[j]]--;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">res = max(res, i - j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>​        另外归并排序也是双指针算法的一个实例，归并排序在我之前的博客有讲过，链接是：<a href="https://stephencuhui.github.io/2020/01/14/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" target="_blank" rel="noopener">归并排序讲解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;双指针算法&quot;&gt;&lt;a href=&quot;#双指针算法&quot; class=&quot;headerlink&quot; title=&quot;双指针算法&quot;&gt;&lt;/a&gt;双指针算法&lt;/h1&gt;&lt;p&gt;​        双指针算法是指一切采用双指针的方式，降低原本暴力解法的时间复杂度的算法，通常双指针算法可以将暴力的 &lt;code&gt;O(n^2)&lt;/code&gt;降低到 &lt;code&gt;O(n)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​        由于双指针算法指的是一类算法，下面我用两道题来简单解释一下&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法——二分查找</title>
    <link href="http://yoursite.com/2020/01/15/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2020/01/15/算法——二分查找/</id>
    <published>2020-01-15T05:25:57.000Z</published>
    <updated>2020-01-15T07:07:46.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分算法"><a href="#二分算法" class="headerlink" title="二分算法"></a>二分算法</h1><p>​        二分算法分为浮点数二分和整数二分，整数二分相对于浮点数二分来讲更复杂，需要考虑边界问题等</p><a id="more"></a><h2 id="二分思想"><a href="#二分思想" class="headerlink" title="二分思想"></a>二分思想</h2><p>​        二分算法的思想是就一段有序序列来讲，想要查找其中某一个数，可以先找到位于序列中点的数，如果目标值小等于中点值，且序列是单调递增的，那么目标值一定在中点左侧，这样再用同样的方式对左侧区间进行二分，如此查找，最后就会找到要找的数字</p><h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><p>​        整数二分思想上很好理解，就是将有序的序列从中间分开，判断目标值在哪半边，再继续二分那段序列就可以</p><p>​        下面给出整数二分的一个例子，包括了整数二分的两种写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line"><span class="keyword">return</span> q[l];</span><br><span class="line"><span class="keyword">int</span> x = q[l], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">while</span> (x &gt; q[++i]);</span><br><span class="line"><span class="keyword">while</span> (x &lt; q[--j]);</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line">swap(q[i], q[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sl = j - l + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (k &lt;= sl)</span><br><span class="line"><span class="keyword">return</span> quick_sort(l, j, k);</span><br><span class="line"><span class="keyword">return</span> quick_sort(j + <span class="number">1</span>, r, k - sl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; quick_sort(<span class="number">0</span>, n - <span class="number">1</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这里之所以存在两种写法，主要区别在于求中点 mid 的值时，如果边界值采取不当的话，整数二分极有可能产生死循环导致程序崩溃，所以须在求 mid 时进行向下取整，即 <code>mid = (l + r + 1) / 2</code></p><h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><p>​        在理解了整数二分的基础上，理解浮点数二分就变得十分简单了，因为浮点数二分不会涉及到边界问题，所以在确定边界值上十分简单，下面是用浮点数二分的思想实现的开平方问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="keyword">double</span> l = <span class="number">0</span>, r = x;</span><br><span class="line"><span class="keyword">while</span> (r - l &gt; <span class="number">1e-6</span>) &#123;</span><br><span class="line"><span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (mid * mid &gt;= x)</span><br><span class="line">r = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">l = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二分算法&quot;&gt;&lt;a href=&quot;#二分算法&quot; class=&quot;headerlink&quot; title=&quot;二分算法&quot;&gt;&lt;/a&gt;二分算法&lt;/h1&gt;&lt;p&gt;​        二分算法分为浮点数二分和整数二分，整数二分相对于浮点数二分来讲更复杂，需要考虑边界问题等&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法——归并排序</title>
    <link href="http://yoursite.com/2020/01/14/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/01/14/算法——归并排序/</id>
    <published>2020-01-14T09:54:45.000Z</published>
    <updated>2020-01-14T10:39:35.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>​        归并排序是另一种排序算法，也是采用分治的思想，但是和快排有很大的区别，归并排序是稳定的，而快排则不稳定</p><a id="more"></a><h2 id="归并的思想"><a href="#归并的思想" class="headerlink" title="归并的思想"></a>归并的思想</h2><p>​        归并排序的思想可以简单的分为三个步骤：</p><ol><li>确定分界点 mid</li><li>递归分界点得到左右空间</li><li>归并，将若干数组合并为一个有序数组</li></ol><h2 id="确定分界点"><a href="#确定分界点" class="headerlink" title="确定分界点"></a>确定分界点</h2><p>​        确定分界点，归并排序的分界点即为数组的中点，设数组左边界为 left，有边界为 right，那么分界点 mid 便为 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>​        归并排序的分界点和快排的分界点有本质的区别，快排的分界点是对数组的元素值而言的，而归并排序的分界点是就数组的 index 来说的</p><p>​        通过确定的分界点，一个数组就被分解成了两个以 mid 为分界的数组，第一个数组的就原素组而言的下标范围是 left &lt;= index &lt;= mid，第二个数组是 mid + 1 &lt;= index &lt;= right</p><h2 id="递归分界点左右空间"><a href="#递归分界点左右空间" class="headerlink" title="递归分界点左右空间"></a>递归分界点左右空间</h2><p>​        根据第一步得到的结果，可以使用递归将得到的两个数组继续分解，即</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">merge_sort(q, l, mid);</span><br><span class="line">merge_sort(q, mid + <span class="number">1</span>, r);</span><br></pre></td></tr></table></figure><h2 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h2><p>​        这是归并排序最重要的一步，是对归并得到的数组得处理，对于两个有序数组来说，想要合并，就要不断得对比数组头位置元素的大小，这又是使用双指针，分别指向两个数组的头元素，不断对比两个指针对应元素大小，保存较小的那个，并后移与其对应的指针，由于两个指针实际上是分步执行的，当其中一个数组被遍历完后，直接将另一个数组接到答案数组的尾部即可，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//k 用来记录答案数组中现存元素的数量</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line"><span class="keyword">if</span> (q[i] &lt;= q[j])</span><br><span class="line">tmp[k++] = q[i++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tmp[k++] = q[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">tmp[k++] = q[i++];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">tmp[k++] = q[j++];</span><br><span class="line"><span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++)</span><br><span class="line">q[i] = tmp[j];</span><br></pre></td></tr></table></figure><h2 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[N], tmp[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">merge_sort(q, l, mid);</span><br><span class="line">merge_sort(q, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line"><span class="keyword">if</span> (q[i] &lt;= q[j])</span><br><span class="line">tmp[k++] = q[i++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tmp[k++] = q[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">tmp[k++] = q[i++];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">tmp[k++] = q[j++];</span><br><span class="line"><span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++)</span><br><span class="line">q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; q[i];</span><br><span class="line">&#125;</span><br><span class="line">merge_sort(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; q[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h1&gt;&lt;p&gt;​        归并排序是另一种排序算法，也是采用分治的思想，但是和快排有很大的区别，归并排序是稳定的，而快排则不稳定&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法——快速排序</title>
    <link href="http://yoursite.com/2020/01/13/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/01/13/算法——快速排序/</id>
    <published>2020-01-13T09:53:56.000Z</published>
    <updated>2020-01-14T10:40:00.623Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><p>​        从头开始学习算法，从最简单的排序算法开始，第一个接触的就是快排，学习的平台是 AcWing，希望现在学习还不晚，对以后能有帮助</p><a id="more"></a><h2 id="快排的原理"><a href="#快排的原理" class="headerlink" title="快排的原理"></a>快排的原理</h2><p>​        快排使用的是分治的思想，有三个关键点：确定分界点、调整区间、递归处理左右两段，这里的思想是使用两个指针，分别对应数组的左右边界，一下简称 l 和 r，通过循环来将两个指针向中间移动直到 l 和 r 相遇，在这期间，将数组调整为小于等于分界点的值和大于等于分界点的值两部分，再使用递归的思想处理</p><p>​        首先要做的是确定一个分治的分界点，这个点可以是任意的一个数组元素，但不要给它设置成固定值，最好通过变量来对它进行定义，例如 array[l]、array[r]、array[(l + r) / 2] 这种都可以</p><p>​        然后通过分界点的值来调整数组空间，，这里需要用到刚才提到的 l 和 r 两个指针，过程是：先将 l 向后移动，检验 l 对应的值是否小于分界点，如果小于则继续后移 l，否则 l 就会停下，这是 r 开始前移，检测移动后的 r 所对应的值是否大于分界点，如果大于则继续前移 r，否则 r 也会停下，这个时候 l 和 r 都已经停下了，说明 l 和 r 都已经遇到了不属于自己对应空间的值，直接交换两个指针当前所对应的值，然后继续移动 l 和 r 指针，直到 l 和 r 相遇</p><p>​        最后便是使用递归的思想，对分界点左边（大小意义上的左，并非是排序上的左）和分界点右边的元素再进行第二步的过程，当最后一次递归结束后，数组便完成了排序</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span> <span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//x:分治变量 循环变量需在两侧边界外一个偏移量的位置，因为每次都是先让指针后/前移一格，所以循环变量需要在边界的前/后一个偏移量的位置</span></span><br><span class="line">    <span class="keyword">int</span> x = arr[l], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">while</span> (arr[i] &lt; x);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        j++;</span><br><span class="line">    <span class="keyword">while</span> (arr[j] &gt; x);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) </span><br><span class="line">       swap(arr[i], arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    quick_sort(arr, l, j);</span><br><span class="line">    quick_sort(arr, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;快排&quot;&gt;&lt;a href=&quot;#快排&quot; class=&quot;headerlink&quot; title=&quot;快排&quot;&gt;&lt;/a&gt;快排&lt;/h1&gt;&lt;p&gt;​        从头开始学习算法，从最简单的排序算法开始，第一个接触的就是快排，学习的平台是 AcWing，希望现在学习还不晚，对以后能有帮助&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JAVA线程简介及两种创建方式</title>
    <link href="http://yoursite.com/2020/01/04/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JAVA%E7%BA%BF%E7%A8%8B%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%B8%A4%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/01/04/JAVA基础——JAVA线程简介及两种创建方式/</id>
    <published>2020-01-04T01:34:30.000Z</published>
    <updated>2020-01-04T03:07:25.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p>​        进程是程序的一次执行过程，是一个动态的概念，是程序在执行过程中分配和管理资源的基本单位，每一个进程都有一个自己的地址空间，也就是说，进程是应用程序运行的状态，应用程序的执行实例，有独立的内存空间和系统资源</p><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>​        一个进程中包括多个线程，线程是 CPU 调度和分派的基本单位，是进程中执行运算的最小单位，真正在 CPU 上运行的是线程，可以与同一个进程中的其他线程共享进程的全部资源</p><a id="more"></a><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>​        线程是进程的一部分，它也是一个动态执行的概念，有从产生到死亡的过程，线程的生命周期可以分为五个部分：</p><p>​        新生状态-&gt;（线程创建了，还未运行）-&gt;可运行状态（CPU 准备调度线程）-&gt;（系统调度，获取 CPU 资源）-&gt;运行状态-&gt;阻塞状态（线程阻塞，让出 CPU 资源）-&gt;死亡状态</p><h3 id="新生状态"><a href="#新生状态" class="headerlink" title="新生状态"></a>新生状态</h3><p>​        线程对象被创建后，这个线程就处于新生状态，这个状态会一直持续到 start() 这个线程</p><h3 id="可运行状态"><a href="#可运行状态" class="headerlink" title="可运行状态"></a>可运行状态</h3><p>​        当线程调用了 start() 方法后，该线程就进入可运行状态，进入可运行状态的线程会被插入就绪队列中，等待 JVM 里线程调度器的调度</p><h3 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h3><p>​        当可运行状态的线程得到 CPU 资源后，该线程就可以执行 run()，此时线程便处于运行状态，运行状态的线程可以向阻塞状态、就绪状态和死亡状态转变</p><h3 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h3><p>​        当一个线程调用了 sleep()、join()、yield() 等方法，失去所占用的资源后，线程进入阻塞状态，在说的资源或者睡眠时间已到后可以重新进入就绪状态</p><h3 id="死亡状态"><a href="#死亡状态" class="headerlink" title="死亡状态"></a>死亡状态</h3><p>​        正常死亡和非正常死亡都会杀死进程，进程死亡即进程被销毁</p><h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>​        在 Java 中，线程有优先级的概念，其范围为 1 - 10，默认优先级为 5，但是优先级是概率性的，优先级高的线程并不一定优先执行，只是被分配资源的概率更高</p><p>​        setPriority() 方法有三种常量：</p><p>​            MAX_PRIORITY (10)</p><p>​            MIN_PRIORITY (1)</p><p>​            NORM_PRIORITY (5)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(mt);</span><br><span class="line">t.setPriority(<span class="number">1</span>);</span><br><span class="line">t.start();</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(mt);</span><br><span class="line"><span class="comment">//设置线程名称</span></span><br><span class="line">t2.setName(<span class="string">"sc"</span>);</span><br><span class="line"><span class="comment">//设置线程优先级，但是是概率事件，并非优先级高一定先运行，1 - 10 表示，10 最高，默认值是 5</span></span><br><span class="line">t2.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">Thread.currentThread().setPriority(Thread.MIN_PRIORITY);</span><br></pre></td></tr></table></figure><h2 id="线程在-Java-中的两种创建方式"><a href="#线程在-Java-中的两种创建方式" class="headerlink" title="线程在 Java 中的两种创建方式"></a>线程在 Java 中的两种创建方式</h2><p>​        在 Java 中有两种创建线程的方法，下面逐个解释并说明他们的区别</p><h3 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h3><p>​        通过继承 Thread 类来创建线程，创建该类的实例，继承类必须重写 run() 方法，run() 方法中是线程所执行的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        mt.start();</span><br><span class="line">        </span><br><span class="line">        MyThread mt2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        mt2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        Thread 类实际上是实现了 Runnable 接口的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br></pre></td></tr></table></figure><h3 id="通过实现-Runnable-接口"><a href="#通过实现-Runnable-接口" class="headerlink" title="通过实现 Runnable 接口"></a>通过实现 Runnable 接口</h3><p>​        实现 Runnable 接口直需要重写其中的 run() 方法，Thread 的构造方法中，可以通过静态代理的方法，使用 Runnable 的实现类来创建进程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread2 mt = <span class="keyword">new</span> MyThread2();</span><br><span class="line">        <span class="comment">//静态代理</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(mt);</span><br><span class="line">        t.setPriority(<span class="number">1</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(mt);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>​        首先，单继承不能再继承其他类，而实现可以多实现，同时也可以继承</p><p>​        另外，通过实现 Runnable 接口来创建的线程可以共享实现类的资源，这是多线程实现的基础</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;进程与线程&quot;&gt;&lt;a href=&quot;#进程与线程&quot; class=&quot;headerlink&quot; title=&quot;进程与线程&quot;&gt;&lt;/a&gt;进程与线程&lt;/h1&gt;&lt;h2 id=&quot;什么是进程&quot;&gt;&lt;a href=&quot;#什么是进程&quot; class=&quot;headerlink&quot; title=&quot;什么是进程&quot;&gt;&lt;/a&gt;什么是进程&lt;/h2&gt;&lt;p&gt;​        进程是程序的一次执行过程，是一个动态的概念，是程序在执行过程中分配和管理资源的基本单位，每一个进程都有一个自己的地址空间，也就是说，进程是应用程序运行的状态，应用程序的执行实例，有独立的内存空间和系统资源&lt;/p&gt;
&lt;h2 id=&quot;什么是线程&quot;&gt;&lt;a href=&quot;#什么是线程&quot; class=&quot;headerlink&quot; title=&quot;什么是线程&quot;&gt;&lt;/a&gt;什么是线程&lt;/h2&gt;&lt;p&gt;​        一个进程中包括多个线程，线程是 CPU 调度和分派的基本单位，是进程中执行运算的最小单位，真正在 CPU 上运行的是线程，可以与同一个进程中的其他线程共享进程的全部资源&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JVM之G1（Garbage First）垃圾回收器</title>
    <link href="http://yoursite.com/2019/12/29/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JVM%E4%B9%8BG1%EF%BC%88Garbage-First%EF%BC%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>http://yoursite.com/2019/12/29/JAVA基础——JVM之G1（Garbage-First）垃圾回收器/</id>
    <published>2019-12-29T02:16:26.000Z</published>
    <updated>2019-12-29T03:45:10.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Garbage-First-垃圾回收器"><a href="#Garbage-First-垃圾回收器" class="headerlink" title="Garbage First 垃圾回收器"></a>Garbage First 垃圾回收器</h1><h2 id="G1-简介"><a href="#G1-简介" class="headerlink" title="G1 简介"></a>G1 简介</h2><p>​        G1（Garbage First）垃圾回收器是最新的 JDK 中默认的垃圾回收器，也是垃圾回收技术最前沿的成果，它同时注重吞吐量（Throughput）和低延迟（Low Latency），默认的暂停目标是 200ms，适用于超大的堆内存</p><p>​        G1 引入了分区（region）的思想，弱化了分代的概念，它将堆内存分为大小相等的区，每个区的大约是 1248M，并且每个区都可以是 Eden、Survivor、Old 或者大对象区，G1 垃圾回收器在整体上使用了标记整理算法，两个区域之间使用的是复制算法</p><a id="more"></a><h2 id="G1-垃圾回收流程"><a href="#G1-垃圾回收流程" class="headerlink" title="G1 垃圾回收流程"></a>G1 垃圾回收流程</h2><p>​        G1 垃圾回收器的名字来源于它的设计原则：优先收集回收效果最大的区域（Garbage First），G1 垃圾回收器不是等到内存耗尽开始进行垃圾回收的，它采用启发式算法，当内存使用达到一定比例时就会开始进行垃圾回收，G1 垃圾回收器的工作流程大体上可以分为三个步骤的循环执行：Young Collection、Young Collection + CM、Mixed Collection</p><p><img src="https://img-blog.csdnimg.cn/20191229114401950.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70" alt></p><h3 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h3><p>​        Young Collection 阶段主要进行新生代的垃圾回收，和其他垃圾回收器一样，当 Eden 区逐渐被沾满时，会将 Eden 区中的幸存对象复制进 Survivor 区，这期间会造成 STW，当 Survivor 区中对象逐渐被占满时，被占满的 Survivor 区的对象中，符合晋升条件的会晋升到老年代，其余的会复制到其他 Survivor 区，另外，在进行 Young Collection 时，JVM 会对对象进行初始标记</p><h3 id="Young-Collection-Concurrent-Mark"><a href="#Young-Collection-Concurrent-Mark" class="headerlink" title="Young Collection + Concurrent Mark"></a>Young Collection + Concurrent Mark</h3><p>​        当老年代占用堆空间比例达到一定的阈值时，会进行并发标记，并发标记不会造成 STW，也就是不会影响其他的用户线程，阈值的默认值是 45%，即老年代占比达到堆空间的 45% 时会开始进行并发标记，这里的并发标记过程也和其他的垃圾回收器一样，就是对初始标记后的对象再进行一次更细致的标记</p><h3 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h3><p>​        混合回收是 G1 垃圾回收循环中的最后一项，在混合回收中，G1 可以将一些老年代区域添加到将回收的 Eden 和 Survivor，G1 垃圾回收器回收足够数量的老年代区域后，G1 会恢复到执行 Young Collection，直到下一个并发标记周期的完成</p><p>​        Mixed Collection 分为最终标记（Remark）和拷贝存活（Evacuation）两个阶段，两个阶段都会造成 STW</p><h4 id="Remark（重标记、最终标记）"><a href="#Remark（重标记、最终标记）" class="headerlink" title="Remark（重标记、最终标记）"></a>Remark（重标记、最终标记）</h4><p>​        最终标记（重标记）对于垃圾回收的过程是十分必要的，比如有如下情况：对象 C 在初始标记时因为没有被强引用所引用，初始标记的过程就不会标记 C 对象，而在垃圾回收之前和并发标记这段时间里，强引用对象 A 又引用了对象 C，如果不在垃圾回收之前进行一次 Remark，这时的对象 C 毫无疑问会被当作垃圾回收掉</p><p>​        为了防止这种事情发生，在并发标记之后，如果对象的引用发生了改变，JVM 会执行写屏障指令，将发生引用改变的对象放入一个 satb_mark_queue 中，当重新标记进行时会检查这个队列，检测其中的对象是否有强引用所引用</p><h4 id="Evacuation（拷贝存活）"><a href="#Evacuation（拷贝存活）" class="headerlink" title="Evacuation（拷贝存活）"></a>Evacuation（拷贝存活）</h4><p>​        拷贝存活即最后的整理，将多个区域的存活对象整理进一个或几个区域，并完成 Eden 到 Survivor，Survivor 到 Old，Old 到 Eden 和 Survivor 的过程，回收老年代的对象时，G1 会优先回收垃圾最多的区域，以达到暂停时间短的目标</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Garbage-First-垃圾回收器&quot;&gt;&lt;a href=&quot;#Garbage-First-垃圾回收器&quot; class=&quot;headerlink&quot; title=&quot;Garbage First 垃圾回收器&quot;&gt;&lt;/a&gt;Garbage First 垃圾回收器&lt;/h1&gt;&lt;h2 id=&quot;G1-简介&quot;&gt;&lt;a href=&quot;#G1-简介&quot; class=&quot;headerlink&quot; title=&quot;G1 简介&quot;&gt;&lt;/a&gt;G1 简介&lt;/h2&gt;&lt;p&gt;​        G1（Garbage First）垃圾回收器是最新的 JDK 中默认的垃圾回收器，也是垃圾回收技术最前沿的成果，它同时注重吞吐量（Throughput）和低延迟（Low Latency），默认的暂停目标是 200ms，适用于超大的堆内存&lt;/p&gt;
&lt;p&gt;​        G1 引入了分区（region）的思想，弱化了分代的概念，它将堆内存分为大小相等的区，每个区的大约是 1248M，并且每个区都可以是 Eden、Survivor、Old 或者大对象区，G1 垃圾回收器在整体上使用了标记整理算法，两个区域之间使用的是复制算法&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JVM之垃圾回收器</title>
    <link href="http://yoursite.com/2019/12/26/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>http://yoursite.com/2019/12/26/JAVA基础——JVM之垃圾回收器/</id>
    <published>2019-12-26T11:58:59.000Z</published>
    <updated>2019-12-28T08:54:08.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-垃圾回收器"><a href="#JVM-垃圾回收器" class="headerlink" title="JVM 垃圾回收器"></a>JVM 垃圾回收器</h1><p>​        在 JVM 中，垃圾回收器大体分为三个种类：串行垃圾回收器、吞吐量优先的垃圾回收器和响应时间优先的垃圾回收器</p><a id="more"></a><h2 id="串行垃圾回收器"><a href="#串行垃圾回收器" class="headerlink" title="串行垃圾回收器"></a>串行垃圾回收器</h2><p>​        串行垃圾回收器是一种单线程的垃圾回收器，适合堆内存小，cpu 个数少的电脑</p><p>​        开启：-XX:+UseSerialGC = Serial + SerialOld</p><p>​        串行垃圾回收器分为两个部分：Serial 和 SerialOld，Serial 工作在新生代，使用的垃圾回收算法是复制算法，SerialOld 工作在老年代，使用标记整理算法</p><p>​        当串行垃圾回收器进行垃圾回收时，所有的用户线程将会暂停，因为垃圾回收的过程中会涉及到地址的变化，当所有线程运行到一个本身的安全点时会进入阻塞状态，等待垃圾回收线程结束后，再恢复运行</p><p><img src="https://img-blog.csdnimg.cn/2019122816521345.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70" alt></p><h2 id="吞吐量优先的垃圾回收器"><a href="#吞吐量优先的垃圾回收器" class="headerlink" title="吞吐量优先的垃圾回收器"></a>吞吐量优先的垃圾回收器</h2><p>​        吞吐量优先的垃圾回收器是一种多线程，并行的垃圾回收器</p><p>​        开启：+UseParallelGC~-XX:+UseParallelOldGC</p><p>​        吞吐量优先的垃圾回收器也分为两个部分：Parallel 和 ParallelOld，Parallel 工作在新生代，使用复制算法，ParallelOld 工作在老年代，使用标记整理算法，两个垃圾回收器都是多线程的垃圾回收器，开启一个的同时会默认开启另一个</p><p>​        当需要进行垃圾回收时，所有线程会到安全点时停下，转换为阻塞状态，之后垃圾回收器会开启多个线程进行垃圾回收，其线程个数一般情况下和 cpu 核数相同，回收结束后，各线程再恢复运行，垃圾回收时，cpu 的利用率会达到 100 %</p><p><img src="https://img-blog.csdnimg.cn/20191228165229857.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70" alt></p><p>​        可以通过参数来设置垃圾回收中的属性：</p><p>​    ·    -XX:+UseAdaptiveSizePolicy<br>​        -XX:GCTimeRatio = ratio 设置垃圾回收时间占总时间的百分比小于 1 / 1 + ratio，ratio 一般设置成 19<br>​        -XX:MaxGCPauseMillis = time 最大暂停毫秒数 &lt; time ms，可能和前一项冲突、对立</p><h2 id="响应时间优先的垃圾回收器"><a href="#响应时间优先的垃圾回收器" class="headerlink" title="响应时间优先的垃圾回收器"></a>响应时间优先的垃圾回收器</h2><p>​        响应时间优先的垃圾回收器是一种多线程，并发的垃圾回收器，用户线程和垃圾回收线程可以同时进行，一起抢占 cpu 资源</p><p>​        开启：-XX:+UseConcMarkSweepGC<del>-XX:+UseParNewGC</del>SerialOl</p><p>​        ConcMarkSweep 是工作在老年代的垃圾回收器，与之配套使用的是工作在新生代的 ParNew，ParNew 是一种基于复制算法的垃圾回收器，ConcMarkSweep 是并发的，基于标记清除算法的垃圾回收器，但是它可能会并发失败，这是它会退化为 SerialOld</p><p>​        当老年代发生垃圾回收时，所有线程会在运行到安全点时暂停并进入阻塞状态，需要进行垃圾回收的线程会进行一次初始标记，初始标记时间很快，只标记一些根对象，接着用户的其他线程便恢复运行，垃圾回收线程与此同时也会并发执行，再一次进行更细致的标记，结束后，会造成第二次 STW，这时对所有的线程进行一次重新标记，以避免并发运行期间，新的内存使用对垃圾回收产生影响，重新标记结束后，垃圾回收线程开始进行清理，用户线程也都恢复运行，这时也是垃圾回收线程和用户线程并发运行，这种垃圾回收方式对系统吞吐量是有影响的，因为用于计算的 cpu 个数降低了</p><p>​        由于这种垃圾回收方式不会保证清除掉所有垃圾，所以不能像以上的两种垃圾回收器那样，等内存占用满时再进行垃圾回收，会在内存占比达到一定比例时便进行垃圾回收</p><p><img src="https://img-blog.csdnimg.cn/20191228165244736.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM-垃圾回收器&quot;&gt;&lt;a href=&quot;#JVM-垃圾回收器&quot; class=&quot;headerlink&quot; title=&quot;JVM 垃圾回收器&quot;&gt;&lt;/a&gt;JVM 垃圾回收器&lt;/h1&gt;&lt;p&gt;​        在 JVM 中，垃圾回收器大体分为三个种类：串行垃圾回收器、吞吐量优先的垃圾回收器和响应时间优先的垃圾回收器&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JVM之垃圾回收算法</title>
    <link href="http://yoursite.com/2019/12/25/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/12/25/JAVA基础——JVM之垃圾回收算法/</id>
    <published>2019-12-25T09:04:47.000Z</published>
    <updated>2019-12-25T10:27:45.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-的垃圾回收算法"><a href="#JVM-的垃圾回收算法" class="headerlink" title="JVM 的垃圾回收算法"></a>JVM 的垃圾回收算法</h1><p>​        在 JVM 中，经常使用的垃圾回收算法有：标记-清除算法、标记-整理算法、复制算法以及分代回收算法，在这里会逐一介绍说明</p><a id="more"></a><h2 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark Sweep）"></a>标记-清除算法（Mark Sweep）</h2><p>​        标记清除算法的运行流程是先标记，将有引用链连接的引用对象进行标记，再将未被标记的引用对象的起始地址和结束地址存入空闲地址列表中，下次需要内存时直接对其进行覆盖</p><p>​        标记清除算法从原理上来说很容易实现，但有一个很严重的问题是此算法容易产生内存碎片，因为标记清除算法回收后的内存可能是断断续续的，而此时就不再可能分配出较大的连续内存空间而触发新一次的垃圾回收</p><p>​        标记清除算法在存活的引用对象多的时候十分高效，但因为其只对未被引用链所连接的即未被标记的引用对象进行清除操作，不移动被标记的对象，所以产生内存碎片是不能避免的</p><h2 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark  Compact）"></a>标记-整理算法（Mark  Compact）</h2><p>​        标记整理算法的标记过程和标记清除算法没有区别，整理的过程会对使用的内存进行整理，将存活的对象都向内存的一端移动，然后清理掉整端边界以外的内存</p><p>​        标记整理算法显然解决了标记清除算法会产生内存碎片的问题，但该算法中涉及到对象的移动，所以运算时的成本会有所提高</p><h2 id="复制算法（Copy）"><a href="#复制算法（Copy）" class="headerlink" title="复制算法（Copy）"></a>复制算法（Copy）</h2><p>​        复制算法是将内存区域分成了大小相等的 FROM 和 TO 两块区域，TO 区开始没有对象，所有的对象都使用 FROM 区，当 FROM 区满了需要垃圾回收时，将存活的对象复制到 TO 区中，然后把 FROM 区清空，这样一来复制到 FROM 区的对象是相连的，不会产生内存碎片的问题，最后改 FROM 为 TO，改 TO 为 FROM，这样新的对象就和老对象继续使用新的 FROM 区，而新的 TO 区依然是空的，如此循环</p><p>​        复制算法实现起来十分简单，也不会产生内存碎片，但缺点是以内存空间的使用率为代价，每次只能使用一半的内存空间，如果存活对象多的话，复制算法的效率也会下降</p><h2 id="分代回收算法（Generational-Collention）"><a href="#分代回收算法（Generational-Collention）" class="headerlink" title="分代回收算法（Generational Collention）"></a>分代回收算法（Generational Collention）</h2><p>​        首先分代收集是大部分 JVM 都采用的垃圾回收算法，它将内存划分为不同的区域，根据对象的生命周期对其进行分类，一般分为：新生代（Young Generation）和老年代（Tenured Generation）</p><p>​        新生代中，又被分成一块伊甸园（Eden Space）和两块幸存区（Survivor），幸存区 FROM 和幸存区TO，其比例一般为 8 : 1 : 1，每次都同时使用伊甸园和幸存区 FROM，在进行垃圾回收时（Minor GC），将伊甸园和幸存区 FROM 中的对象复制进幸存区 TO 中，然后清理掉伊甸园和幸存区 FROM，最后像复制算法一样对 FROM 和 TO 进行一次调换如此循环，也就是说，新生代的垃圾回收主要以复制算法为主</p><p>​        在分代回收算法中，有一个用来控制新生代对象进入老年代的属性，叫阈值，每次垃圾回收后，若该对象还存在于内存中，它的年龄就会 + 1，当对象的年龄超过阈值后，它就会从新生代晋升到老年代，也就是说，老年代存放的都是一些生命周期很长的对象</p><p>​        当老年代内存全部被占用时，会先尝试 Minor GC，若空间仍不足，会再进行一次 Full GC，Full GC 的 STW（Stop The World）时间很长，如果 Full GC 后空间仍不足，就会 OOF</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM-的垃圾回收算法&quot;&gt;&lt;a href=&quot;#JVM-的垃圾回收算法&quot; class=&quot;headerlink&quot; title=&quot;JVM 的垃圾回收算法&quot;&gt;&lt;/a&gt;JVM 的垃圾回收算法&lt;/h1&gt;&lt;p&gt;​        在 JVM 中，经常使用的垃圾回收算法有：标记-清除算法、标记-整理算法、复制算法以及分代回收算法，在这里会逐一介绍说明&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JAVA的五种引用类型及引用队列</title>
    <link href="http://yoursite.com/2019/12/20/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JAVA%E7%9A%84%E4%BA%94%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%BC%95%E7%94%A8%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/12/20/JAVA基础——JAVA的五种引用类型及引用队列/</id>
    <published>2019-12-20T09:15:57.000Z</published>
    <updated>2019-12-22T07:22:21.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA-的五种引用类型及引用队列"><a href="#JAVA-的五种引用类型及引用队列" class="headerlink" title="JAVA 的五种引用类型及引用队列"></a>JAVA 的五种引用类型及引用队列</h1><p>​        在介绍 JAVA 的五种引用之前，先介绍一下什么是引用，以及引用和对象之间的关系</p><h2 id="什么是引用"><a href="#什么是引用" class="headerlink" title="什么是引用"></a>什么是引用</h2><p>​        众所周知，JAVA 是一种面向对象的语言，在 JAVA 程序运行时，对象是存储在堆内存（Heap）中的，C/C++ 中是通过指针来访问所谓对象（结构体）的，而 JAVA 则是通过引用来访问对象，也就是说，引用指向了对象在堆内存中的地址，引用本身也占用内存，64 位的 JVM 中，引用所占内存大小为 8 个字节，通过指针压缩后占用 4 个字节</p><p>​        在 JDK 1.2 之前，JAVA 对引用的定义为：如果一个数据中存储的数值代表的是另外一块内存的起始地址，就称这块数据的内存代表着一个引用</p><p>​        在 JDK 1.2 之后，JAVA 引用的概念得到了扩充，引用被分为：强引用、软引用、弱引用、虚引用、终结器引用</p><a id="more"></a><h2 id="引用和对象"><a href="#引用和对象" class="headerlink" title="引用和对象"></a>引用和对象</h2><p>​        在 JAVA 中，一切都被视为是对象，但标识符（变量名）实际上是对象的一个引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个引用，引用可以独立存在，不是必须要关联某一对象</span></span><br><span class="line">String str;</span><br></pre></td></tr></table></figure><p>​        也可以将引用指向对象，这样操作后就可以通过引用来操作对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br></pre></td></tr></table></figure><h2 id="垃圾回收算法、五种引用类型及引用队列"><a href="#垃圾回收算法、五种引用类型及引用队列" class="headerlink" title="垃圾回收算法、五种引用类型及引用队列"></a>垃圾回收算法、五种引用类型及引用队列</h2><p>​        JAVA 在垃圾回收机制中判断是否要回收某一对象时，都需要引用的概念</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>​        引用计数法的原理为：如果变量被引用：计数 +1，没有对象引用计数 -1，为 0 回收，很明显，当一个对象需要被循环引用时，引用计数法可能会存在问题</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>​        Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象：扫描堆中的对象，看是否能够沿着 GC Root 对象为起点的引用链找到该对象，找不到表示可以回收</p><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>​        只有所有 GC Roots 对象都不通过强引用引用该对象，该对象才能被垃圾回收，换句话说就是，只要强引用存在，JVM 垃圾回收器就永远都不会回收被引用的对象，即使内存不足，JVM 会抛出 OutOfMemoryError</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只要 obj 指向 Object 对象，那它就永远都不会被 JVM 回收</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">//将 obj 置为 null，可以切断引用链，这样 obj 就会被 JVM 回收</span></span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h3><p>​        ReferenceQueue，当一个引用（软引用、弱引用）关联到了一个引用队列后，当这个引用所引用的对象要被垃圾回收时，就会将它加入到所关联的引用队列中，所以判断一个引用对象是否已经被回收的一个现象就是，这个对象的引用是否被加入到了它所关联的引用队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB], queue);</span><br></pre></td></tr></table></figure><p>​        说到底，引用队列就是一个对引用的回收机制，当软引用或弱引用所包装的对象为 null 或被回收时，这个引用也就不在具有价值，引用队列就是清除掉这部分引用的一种回收机制</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>​        仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次触发垃圾回收，回收软引用对象，即在内存足够时，JVM 不会回收软引用对象，但当内存不足时，软引用对象就会被回收，所以软引用对象通常用来描述一些非必要但仍有用的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不直接通过 list 引用 byte[]</span></span><br><span class="line"><span class="comment">//list -----&gt; SoftReference -----&gt; byte[] 添加了一层软引用</span></span><br><span class="line">List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>​        弱引用是较软引用更第一级的引用，只要发生垃圾回收，无论内存是否充足，JVM 都会回收掉弱引用对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;WeakReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>​        虚引用必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</p><h3 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h3><p>​        终结器引用无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用 finalize 方法，第二次 GC 时回收被引用对象</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JAVA-的五种引用类型及引用队列&quot;&gt;&lt;a href=&quot;#JAVA-的五种引用类型及引用队列&quot; class=&quot;headerlink&quot; title=&quot;JAVA 的五种引用类型及引用队列&quot;&gt;&lt;/a&gt;JAVA 的五种引用类型及引用队列&lt;/h1&gt;&lt;p&gt;​        在介绍 JAVA 的五种引用之前，先介绍一下什么是引用，以及引用和对象之间的关系&lt;/p&gt;
&lt;h2 id=&quot;什么是引用&quot;&gt;&lt;a href=&quot;#什么是引用&quot; class=&quot;headerlink&quot; title=&quot;什么是引用&quot;&gt;&lt;/a&gt;什么是引用&lt;/h2&gt;&lt;p&gt;​        众所周知，JAVA 是一种面向对象的语言，在 JAVA 程序运行时，对象是存储在堆内存（Heap）中的，C/C++ 中是通过指针来访问所谓对象（结构体）的，而 JAVA 则是通过引用来访问对象，也就是说，引用指向了对象在堆内存中的地址，引用本身也占用内存，64 位的 JVM 中，引用所占内存大小为 8 个字节，通过指针压缩后占用 4 个字节&lt;/p&gt;
&lt;p&gt;​        在 JDK 1.2 之前，JAVA 对引用的定义为：如果一个数据中存储的数值代表的是另外一块内存的起始地址，就称这块数据的内存代表着一个引用&lt;/p&gt;
&lt;p&gt;​        在 JDK 1.2 之后，JAVA 引用的概念得到了扩充，引用被分为：强引用、软引用、弱引用、虚引用、终结器引用&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JVM之虚拟机堆和方法区</title>
    <link href="http://yoursite.com/2019/12/03/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JVM%E4%B9%8B%E6%96%B9%E6%B3%95%E5%8C%BA%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A0%86/"/>
    <id>http://yoursite.com/2019/12/03/JAVA基础——JVM之方法区和虚拟机堆/</id>
    <published>2019-12-03T09:02:35.000Z</published>
    <updated>2019-12-04T13:17:30.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-虚拟机堆和方法区"><a href="#JVM-虚拟机堆和方法区" class="headerlink" title="JVM 虚拟机堆和方法区"></a>JVM 虚拟机堆和方法区</h1><p>​        虚拟机堆和方法区都存在与 JVM 的线程共享区，占有 JVM 内存中的很大一部分</p><a id="more"></a><h2 id="虚拟机堆"><a href="#虚拟机堆" class="headerlink" title="虚拟机堆"></a>虚拟机堆</h2><p>​        堆（Haep），在 Java 中所有通过 new 关键字创建的对象都会使用堆内存，堆是线程共享的，在堆中的对象都需要考虑线程安全问题（只要局部变量不逃逸出方法的作用范围，它就是线程安全的），另外堆还存在垃圾回收机制</p><p>​        垃圾回收机制是回收不再被引用、使用的变量，如果不断产生新的对象且都有人在使用，当对象数量达到一定限度时，就会产生堆内存溢出（OutOfMemoryError），可以通过指令设置堆内存上限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xmx10m</span><br><span class="line">//设置堆内存上限为 10M</span><br></pre></td></tr></table></figure><h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><p>​        方法区和虚拟机堆一样，是线程共享区的一部分，JVM 规范指出，方法区逻辑上是虚拟机堆的一部分，但不强制方法区的位置，它用于存储已被虚拟机加载的类信息、常量池、静态变量、即时编译器编译后的代码等数据</p><p>​        方法区的官方定义如下：</p><blockquote><p>2.5.4. Method Area<br>The Java Virtual Machine has a method area that is shared among all Java Virtual Machine threads. The method area is analogous to the storage area for compiled code of a conventional language or analogous to the “text” segment in an operating system process. It stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors, including the special methods used in class and instance initialization and interface initialization. The method area is created on virtual machine start-up. Although the method area is logically part of the heap, simple implementations may choose not to either garbage collect or compact it. This specification does not mandate the location of the method area or the policies used to manage compiled code. The method area may be of a fixed size or may be expanded as required by the computation and may be contracted if a larger method area becomes unnecessary. The memory for the method area does not need to be contiguous.</p></blockquote><h3 id="永久代（Permanent-Generation）"><a href="#永久代（Permanent-Generation）" class="headerlink" title="永久代（Permanent Generation）"></a>永久代（Permanent Generation）</h3><p>​        永久代是 HotSpot 虚拟机对方法区的具体实现，永久代本身也存在于虚拟机堆中，在 JDK 1.7 中，移除永久代的工作就已经开始了，存储在永久代中的数据转移到了虚拟机堆或者 Native Memory 中</p><h3 id="元空间（Meta-Space）"><a href="#元空间（Meta-Space）" class="headerlink" title="元空间（Meta Space）"></a>元空间（Meta Space）</h3><p>​        从 JDK 1.8 开始，HotSpot 虚拟机完全移除了永久代，改为在 Native Memory 中存放这些数据，新的空间被称为元空间</p><h3 id="常量池（Constant-Pool）"><a href="#常量池（Constant-Pool）" class="headerlink" title="常量池（Constant Pool）"></a>常量池（Constant Pool）</h3><p>​        一个类的二进制字节码文件大约分为三部分：类的基本信息、常量池、包含的虚拟机指令</p><p>​        常量池的作用是为虚拟机指令提供“常量符号”，根据“常量符号”，虚拟机指令可以找到常量池中存在的数据，所以常量池就是一张表，虚拟机指令根据这张常量表找到要执行的类型、方法名、参数类型、字面量等信息，存在于 .class 文件中</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>​        当一个类被加载时，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</p><h4 id="串池（String-Table）"><a href="#串池（String-Table）" class="headerlink" title="串池（String Table）"></a>串池（String Table）</h4><p>​        为避免字符串被重复创建，JVM 引入了串池的概念，当一个字符串变成字符串对象时，该字符串会在已经被创建好的串池中查找是否有同名的字符串，如果有，就将已存在的字符串的地址赋给该字符串对象，如果没有就将该字符串放入串池中，从而降低相同值得字符串变量对内存得消耗</p><p>​        实际上，串池得本质是一个 Hash Table，字符串是它的 KEY，每当有字符串变成字符串变量时，就会检查串池中是否存在和该字符串同名得 KEY，另外，String Table 不能扩容，在 JDK 1.6 中存在于常量池中，在 1.8 时存在于堆中</p><p>​        javac 会在编译期对字符串变量进行优化，例如：String str = “a” + “b”，JVM 认为，”a”是常量，”b”也是常量，所以变量 str 的值在编译期已经决定了，所以会直接将 str 赋值为 “ab”</p><p>#####String.intern()</p><p>​        String.intern 方法，可以将通过 new 创建的 String 对象放入串池中，并且返回放入串池中的字符串</p><h5 id="直接定义的-String-类型变量和通过-new-创建的-String-对象的区别"><a href="#直接定义的-String-类型变量和通过-new-创建的-String-对象的区别" class="headerlink" title="直接定义的 String 类型变量和通过 new 创建的 String 对象的区别"></a>直接定义的 String 类型变量和通过 new 创建的 String 对象的区别</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"a"</span>;</span><br></pre></td></tr></table></figure><p>​        创建 str 对象，在 String Table 中查找”a”字符串，如果有，就将 String Table 中”a”字符串的地址赋给 str，如果没有，就将”a”字符串放入 String Table 中，并把 String Table 中的”a”字符串的地址赋给 str</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure><p>​        创建 str 对象，在 String Table 中查找”a”字符串，如果有，在虚拟机堆中复制（创建）一个”a”字符串对象，如果没有，就在 String Table 中放入”a”字符串，再在虚拟机堆中创建一个 String Table 中”a”字符串的复制对象</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM-虚拟机堆和方法区&quot;&gt;&lt;a href=&quot;#JVM-虚拟机堆和方法区&quot; class=&quot;headerlink&quot; title=&quot;JVM 虚拟机堆和方法区&quot;&gt;&lt;/a&gt;JVM 虚拟机堆和方法区&lt;/h1&gt;&lt;p&gt;​        虚拟机堆和方法区都存在与 JVM 的线程共享区，占有 JVM 内存中的很大一部分&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JVM之Java虚拟机栈</title>
    <link href="http://yoursite.com/2019/12/02/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JVM%E4%B9%8BJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
    <id>http://yoursite.com/2019/12/02/JAVA基础——JVM之Java虚拟机栈/</id>
    <published>2019-12-02T08:02:28.000Z</published>
    <updated>2019-12-02T11:17:56.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h1><p>​        虚拟机栈描述的是 Java 方法执行的动态内存模型</p><a id="more"></a><h2 id="虚拟机栈的内容"><a href="#虚拟机栈的内容" class="headerlink" title="虚拟机栈的内容"></a>虚拟机栈的内容</h2><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p>​        在 Java 程序中的每个方法执行时，都会创建一个栈帧，伴随着方法从创建到执行完成，用于存储局部变量表、操作数栈、动态链接、方法出口等</p><p>​        虚拟机栈是存在大小的，当方法所占用的空间溢出，会产生 StackOverflowError</p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>​        局部表量表的内存空间在编译期即完成分配，主要保存函数的参数以及局部的变量信息，局部变量表中的变量作用域是当前调用的函数，函数调用结束后，随着函数栈帧的销毁，局部变量表也随之销毁，释放空间</p><p>​        局部变量表的最小存储单位是变量槽（Slot），槽的大小与操作系统位数相同，可以放下操作系统位数以内的数据类型</p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>​        操作数栈可理解为java虚拟机栈中的一个用于计算的临时数据存储区，局部变量表使用索引，操作数栈是通过出栈、入栈来访问，存储的数据与局部变量表一致含 int、long、float、double、reference、returnType，操作数栈中 byte、short、char 压栈前会被转为 int</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-虚拟机栈&quot;&gt;&lt;a href=&quot;#Java-虚拟机栈&quot; class=&quot;headerlink&quot; title=&quot;Java 虚拟机栈&quot;&gt;&lt;/a&gt;Java 虚拟机栈&lt;/h1&gt;&lt;p&gt;​        虚拟机栈描述的是 Java 方法执行的动态内存模型&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JVM简介及程序计数器</title>
    <link href="http://yoursite.com/2019/12/01/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JVM%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
    <id>http://yoursite.com/2019/12/01/JAVA基础——JVM简介及程序计数器/</id>
    <published>2019-12-01T08:34:08.000Z</published>
    <updated>2019-12-01T10:30:43.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>​        JVM（Java 虚拟机），是一种用于计算设备的规范，是一个虚构出来的计算机，通过在实际的计算机上仿真模拟各种计算功能来实现，引入 JVM 后，Java 语言在不同平台上运行时不需要重新编译，它屏蔽了与具体平台相关的信息，使得 Java 程序只需生成在 JVM 上运行的字节码文件，就可以在多种平台上不加修改的运行</p><a id="more"></a><h2 id="JVM-基本结构"><a href="#JVM-基本结构" class="headerlink" title="JVM 基本结构"></a>JVM 基本结构</h2><p>​        首先，JVM 分为线程共享区和线程独占区两部分，线程共享区即线程公有，可以所有线程共享，向下分为方法区和 Java 堆，线程独占区即线程私有，向下分为虚拟机栈、本地方法栈以及一会会详细介绍的程序计数器</p><p>具体结构如图：</p><p><img src="https://img-blog.csdnimg.cn/20191201151515479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70" alt></p><h2 id="JVM-程序计数器"><a href="#JVM-程序计数器" class="headerlink" title="JVM 程序计数器"></a>JVM 程序计数器</h2><p>​        程序计数器是一个记录着当前线程所执行到的字节码行号</p><h3 id="程序计数器的特点"><a href="#程序计数器的特点" class="headerlink" title="程序计数器的特点"></a>程序计数器的特点</h3><ol><li><p>线程隔离，每个线程工作室都有属于自己的独立计数器</p></li><li><p>执行 Java 方法时，程序计数器是有值的，且记录的是正在执行的字节码指令的地址</p></li><li><p>执行本地方法时，程序计数器的值为空（Undefined），因为 native 方法时 java 通过 JNI（Java 本地接口）直接调用本地的 C/C++ 库，由于此方法是通过 C/C++ 实现的，无法生成字节码文件，所以其在执行时内存的分配不是由 JVM 决定的</p></li><li><p>程序计数器占用的内存很小，在进行 JVM 内存计算时，可以忽略</p></li><li><p>另外，JVM 中只有程序计数器没有规定任何 OutOfMemoryError</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM&quot;&gt;&lt;a href=&quot;#JVM&quot; class=&quot;headerlink&quot; title=&quot;JVM&quot;&gt;&lt;/a&gt;JVM&lt;/h1&gt;&lt;p&gt;​        JVM（Java 虚拟机），是一种用于计算设备的规范，是一个虚构出来的计算机，通过在实际的计算机上仿真模拟各种计算功能来实现，引入 JVM 后，Java 语言在不同平台上运行时不需要重新编译，它屏蔽了与具体平台相关的信息，使得 Java 程序只需生成在 JVM 上运行的字节码文件，就可以在多种平台上不加修改的运行&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JAVA简介和运行原理</title>
    <link href="http://yoursite.com/2019/11/27/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JAVA%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2019/11/27/JAVA基础——JAVA简介/</id>
    <published>2019-11-27T02:12:54.000Z</published>
    <updated>2019-11-27T11:53:13.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><p>​        本系列主要更新 Java 基础相关的知识，最近准备重新复习一遍 Java 基础，主要涉及一些原理上的东西，会持续更新！</p><a id="more"></a><p>##Java 简介</p><p>​        Java 是一种简洁的、面向对象的、分布式的、解释型的、健壮安全的、结构中立的、可移植的、性能优异、多线程的动态语言</p><p>​        看不懂吧，简单来说，Java 就是一种面向对象的编程语言，功能完善、安全、使用广泛，在 WEB</p><p> 程序设计、嵌入式开发、桌面应用开发等开发工作中都占有一席之地</p><p>##Java 平台</p><p>​        当前 Java 技术的平台架构包括三方面：</p><p>​        Java SE：开发部署在桌面、服务器、嵌入式环境和实时环境的 Java 应用程序，包含了 Java Web 服务开发的类，为 Java EE 提供基础</p><p>​        Java EE：帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。Java EE 是在 Java SE 的基础上构建的，提供了 Web 服务、组件模型、管理和通信 API，且可以用来实现企业级的面向服务体系结构和 Web 应用程序</p><p>​        Java ME：为在移动设备和嵌入式设备上运行的应用程序提供了一个健壮且灵活的环境，Java ME 包括灵活的用户界面、健壮的安全模式</p><h2 id="Java-运行流程"><a href="#Java-运行流程" class="headerlink" title="Java 运行流程"></a>Java 运行流程</h2><p>​        1.使用文字编辑软件或集成开发环境编辑 Java 源文件，扩展名为 .java</p><p>​        2.通过编译 .java 文件，生成同名的 .class 字节码文件</p><p>​        3.通过 JVM 解释方式，将 .class 字节码文件转变为由 0 或 1 组成的二进制指令（机器码）运行</p><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>​        JDK 是 Java 开发包（开发工具），JDK 是整个 Java 的核心，包含了 JRE，Java 工具类和 Java 核心类库</p><p>​        JDK 适合编译解释小型 Java 文件，随着项目体积的变大，使用 JDK 来维护各类（class）间的依赖关系将变得十分繁琐和复杂</p><h2 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h2><p>​        JRE 是 Java 运行环境，包含了 JVM（Java 虚拟机）标准实现及 Java 核心类库，但不包含编译器、调试器和其他工具</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>​        JVM 是 Java 虚拟机，是 Java 跨平台性的基础，Java 的 .class 字节码文件因为会在 JVM 中被解释成面型不同系统的机器码文件，所以 Java 才具有了跨平台性</p><h3 id="JVM-的内存模型"><a href="#JVM-的内存模型" class="headerlink" title="JVM 的内存模型"></a>JVM 的内存模型</h3><blockquote><p>运行时数据区</p><blockquote><p>方法区</p><p>虚拟机栈</p><p>本地方法栈</p><p>堆</p><p>程序计数器</p></blockquote><p>执行引擎</p><p>本地接口</p><p>本地方法库</p></blockquote><p>​        JVM 还有很多内容，我还在继续学习！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JAVA&quot;&gt;&lt;a href=&quot;#JAVA&quot; class=&quot;headerlink&quot; title=&quot;JAVA&quot;&gt;&lt;/a&gt;JAVA&lt;/h1&gt;&lt;p&gt;​        本系列主要更新 Java 基础相关的知识，最近准备重新复习一遍 Java 基础，主要涉及一些原理上的东西，会持续更新！&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate——其他查询方法</title>
    <link href="http://yoursite.com/2019/11/25/Hibernate%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/11/25/Hibernate框架——其他查询方法/</id>
    <published>2019-11-25T10:32:30.000Z</published>
    <updated>2019-11-25T12:16:08.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hibernate-框架的查询方法"><a href="#Hibernate-框架的查询方法" class="headerlink" title="Hibernate 框架的查询方法"></a>Hibernate 框架的查询方法</h1><p>​        除了通过 session.get() 方法进行查询外，Hibernate 框架还提供了其他的查询方式</p><a id="more"></a><h2 id="Query-查询对象"><a href="#Query-查询对象" class="headerlink" title="Query 查询对象"></a>Query 查询对象</h2><p>​        query 查询对象可以通过设置查询条件进行查询，使用 HQL 语言（Hibernate Query Language），是 Hibernate 的面向对象查询语言，最终底层要转成面向数据库查询语言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.查询所有用户</span></span><br><span class="line">Query query = session.createQuery(<span class="string">"From User"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.查询符合条件得用户【username 和 password 是 User 对象得属性，而不是表的字段名】</span></span><br><span class="line">Query query = session.createQuery(<span class="string">"From User where username = ? and password = ?"</span>);</span><br><span class="line">query.setParameter(<span class="number">0</span>, <span class="string">"lmh"</span>);</span><br><span class="line">query.setParameter(<span class="number">1</span>, <span class="string">"123"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.分页查询</span></span><br><span class="line">Query query = session.creatQuery(<span class="string">"From User"</span>);</span><br><span class="line">query.setMaxResults(<span class="number">3</span>);</span><br><span class="line">query.setFirstResult(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h2 id="Criteria-查询对象"><a href="#Criteria-查询对象" class="headerlink" title="Criteria 查询对象"></a>Criteria 查询对象</h2><p>​        QBC（query by criteria），是 hibernate 提供纯面向对象查询得语言，提供直接使用 PO 对象进行操作</p><p>​        PO：persistent object，用于与数据库交互数据——dao 层（JavaBean + hbm）</p><p>​        BO：business object，业务数据对象——service 层</p><p>​        VO：value object 值对象——web 层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Criteria：hibernate 独创的查询对象，全程无 hql 语言</span></span><br><span class="line">Criteria criteria = session.createCriteria(User.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等于 =</span></span><br><span class="line">criteria.add(Restriction.eq(<span class="string">"lmh"</span>, <span class="string">"123"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//like</span></span><br><span class="line">criteria.add(Restriction.like(<span class="string">"lmh"</span>, <span class="string">"%123%"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//..........</span></span><br></pre></td></tr></table></figure><h2 id="SQLQuery-查询对象"><a href="#SQLQuery-查询对象" class="headerlink" title="SQLQuery 查询对象"></a>SQLQuery 查询对象</h2><p>​        SQLQuery：使用原生的 SQL 语句查询</p><p>​        并不是所有的 sql 都能转成 hql</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQLQuery query = session.createSQLQuery(<span class="string">"select * from t_user"</span>);</span><br></pre></td></tr></table></figure><h2 id="文件逻辑优化"><a href="#文件逻辑优化" class="headerlink" title="文件逻辑优化"></a>文件逻辑优化</h2><h3 id="使用工具类"><a href="#使用工具类" class="headerlink" title="使用工具类"></a>使用工具类</h3><p>​        将重复代码封装进工具类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.cfg.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateUtils</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SessionFactory sf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"><span class="comment">//1.加载配置</span></span><br><span class="line">Configuration cfg = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建一个sessionFactory</span></span><br><span class="line">sf = cfg.buildSessionFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.在虚拟机关闭时，释放SessionFactory</span></span><br><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sf.close();</span><br><span class="line">System.out.println(<span class="string">"释放资源"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">openSession</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> sf.openSession();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getCurrentSession</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> sf.getCurrentSession();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hibernate-框架的查询方法&quot;&gt;&lt;a href=&quot;#Hibernate-框架的查询方法&quot; class=&quot;headerlink&quot; title=&quot;Hibernate 框架的查询方法&quot;&gt;&lt;/a&gt;Hibernate 框架的查询方法&lt;/h1&gt;&lt;p&gt;​        除了通过 session.get() 方法进行查询外，Hibernate 框架还提供了其他的查询方式&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hibernate框架" scheme="http://yoursite.com/tags/Hibernate%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate框架——框架的使用及简单配置讲解</title>
    <link href="http://yoursite.com/2019/11/18/Hibernate%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E8%AE%B2%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/11/18/Hibernate框架——框架的使用及简单配置讲解/</id>
    <published>2019-11-18T04:28:07.000Z</published>
    <updated>2019-11-19T02:32:50.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hibernate-框架简介"><a href="#Hibernate-框架简介" class="headerlink" title="Hibernate 框架简介"></a>Hibernate 框架简介</h1><h2 id="ORM-框架"><a href="#ORM-框架" class="headerlink" title="ORM 框架"></a>ORM 框架</h2><p>​        对象关系映射，对象和表字段进行对应，是一种程序技术，用于实现面向对象编程语言里不用类型系统的数据之间的转换</p><h2 id="Hibernate-框架"><a href="#Hibernate-框架" class="headerlink" title="Hibernate 框架"></a>Hibernate 框架</h2><p>​        Hibernate 是一个开放源码的对象关系映射框架，它对 JDBC 进行了非常轻量级的对象封装，它将 POJO（简单的 JAVA 对象）与数据库表建立映射关系，是一个全自动的 ORM 框架</p><p>​        Hibernate 可以自动生成 SQL 语句，自动执行，可以应用在任何使用 JDBC 的场合</p><p>优点：</p><p>​        对 JDBC 访问数据库的代码做了封装，大大简化了数据访问层繁琐重复性代码</p><p>​        是一个基于 jdbc 的主流持久化框架，是一个优秀的 orm 实现，有很大程度的简化了 dao 层编码工作</p><p>​        Hibernate 使用了 JAVA 的反射机制</p><p>​        Hibernate 性能好，是一个轻量级框架，映射灵活性出色，它支持很多关系型数据库，有一对一到多对多的各种复杂关系映射</p><a id="more"></a><h2 id="Hibernate-框架使用"><a href="#Hibernate-框架使用" class="headerlink" title="Hibernate 框架使用"></a>Hibernate 框架使用</h2><h3 id="核心配置文件-hibernate-cfg-xml"><a href="#核心配置文件-hibernate-cfg-xml" class="headerlink" title="核心配置文件 hibernate.cfg.xml"></a>核心配置文件 hibernate.cfg.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1、配置数据库连接的4个参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/hibernate_day1?useSSL=false&amp;amp;serverTimezone=Hongkong&amp;amp;characterEncoding=utf-8&amp;amp;autoReconnect=true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.password"</span>&gt;</span>lmh12358<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 开启与当前线程绑定 session 的功能 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.current_session_context_class"</span>&gt;</span>thread<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"javax.persistence.validation.mode"</span>&gt;</span>none<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  是否显示sql语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  是否格式化sql语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  是否自动提交事务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.autocommit"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2、配置JavaBean与表的映射文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"com/lmh/hibernate/domain/User.hbm.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Java-Bean-对象映射文件-Class-hbm-xml"><a href="#Java-Bean-对象映射文件-Class-hbm-xml" class="headerlink" title="Java Bean 对象映射文件 Class.hbm.xml"></a>Java Bean 对象映射文件 Class.hbm.xml</h3><p>User.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lmh.hibernate.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> uid;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUid</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> uid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUid</span><span class="params">(<span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.uid = uid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>User.hbm.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.lmh.hibernate.domain.User"</span> <span class="attr">table</span>=<span class="string">"t_user"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- name：模型中的属性名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"uid"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- id 的生成策略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果表中类中字段名相同不用写 column --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="所用-jar-包"><a href="#所用-jar-包" class="headerlink" title="所用 jar 包"></a>所用 jar 包</h3><blockquote><p>antlr-2.7.6.jar</p><p>commons-collections-3.1.jar</p><p>dom4j-1.6.1.jar</p><p>hibernate-jpa-2.0-api-1.0.1.Final.jar</p><p>hibernate3.jar</p><p>javassist-3.12.0.GA.jar</p><p>jta-1.1.jar</p><p>mysql-connector-java-8.0.16.jar</p><p>slf4j-api-1.6.1.jar</p></blockquote><h3 id="测试类："><a href="#测试类：" class="headerlink" title="测试类："></a>测试类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lmh.hibernate.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Transaction;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.cfg.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmh.hibernate.domain.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDemo</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//保存用户数据</span></span><br><span class="line"><span class="comment">//1.获取核心配置文件对象，configure()无参数默认是加载 src 的 hibernate.cfg.xml 文件</span></span><br><span class="line">Configuration cfg = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//2.创建会话工厂</span></span><br><span class="line">SessionFactory factory = cfg.buildSessionFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.创建会话【相当于连接 Connect】</span></span><br><span class="line"><span class="comment">//openSession()获取一个全新的 session</span></span><br><span class="line"><span class="comment">//factory.getCurrentSession获取一个与当前线程绑定的 session</span></span><br><span class="line">Session session1 = factory.openSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line">Transaction trans = session1.getTransaction();</span><br><span class="line">trans.begin();</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存【直接把对象保存到数据库】</span></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setUsername(<span class="string">"skw"</span>);</span><br><span class="line">user.setPassword(<span class="string">"123"</span>);</span><br><span class="line">session1.save(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line">trans.commit();</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.关闭会话</span></span><br><span class="line">session1.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.关闭工厂</span></span><br><span class="line">factory.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Configuration-配置对象"><a href="#Configuration-配置对象" class="headerlink" title="Configuration 配置对象"></a>Configuration 配置对象</h2><p>​        Configuration 对象用来加载配置文件，new Configuration 构造方法加载的时 hibernate.properties，configure 方法加载的是 hibernate.cfg.xml，通常这两种配置文件都会被放在 src 目录下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存用户数据</span></span><br><span class="line"><span class="comment">//1.获取核心配置文件对象，configure()无参数默认是加载 src 的 hibernate.cfg.xml 文件</span></span><br><span class="line"><span class="comment">//2.直接 new 出来的对象默认调用 hibernate.properties</span></span><br><span class="line">Configuration cfg = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line">Configuration cfg = <span class="keyword">new</span> Configuration();</span><br></pre></td></tr></table></figure><h3 id="加载-Class-hbm-xml-映射文件的方式"><a href="#加载-Class-hbm-xml-映射文件的方式" class="headerlink" title="加载 Class.hbm.xml 映射文件的方式"></a>加载 Class.hbm.xml 映射文件的方式</h3><p>hibernate.cfg.xml中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1.在 hibernate.cfg.xml 中配置JavaBean与表的映射文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"com/lmh/hibernate/domain/User.hbm.xml"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>测试类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.调用 Configuration 对象的 addResource</span></span><br><span class="line">cfg.addResource(<span class="string">"com/lmh/hibernate/domain/User.hbm.xml"</span>);</span><br><span class="line"><span class="comment">//3.调用 Configuration 对象的 addClass 方法</span></span><br><span class="line">cfg.addClass(User.class);</span><br></pre></td></tr></table></figure><h2 id="SessionFactory-工厂"><a href="#SessionFactory-工厂" class="headerlink" title="SessionFactory 工厂"></a>SessionFactory 工厂</h2><p>​        SessionFactory 相当于 Java Web 连接池，用于管理所有的 session，通过调用 Configuration 对象的 buildSessionFactory 方法来获得 SessionFactory，它还用于缓存配置信息（数据库配置信息、映射文件、预定义 HQL 语句等），SessionFactory 线程安全，多个线程同时访问时不会出现线程并发访问问题</p><h2 id="Session-会话"><a href="#Session-会话" class="headerlink" title="Session 会话"></a>Session 会话</h2><p>​        创建一个 Session 就相当于建立了一个 Connection，建立后可以通过 Session 来对数据库中的表进行操作</p><h3 id="Session-会话的获取"><a href="#Session-会话的获取" class="headerlink" title="Session 会话的获取"></a>Session 会话的获取</h3><p>​        SessionFactory 提供了两个方法来获取 Session：</p><p>​        1.factory.openSession()：获取一个全新的 Session</p><p>​        2.factory.getCurrentSession()：获取一个与当前线程绑定的 Session</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Session session1 = factory.openSession();</span><br><span class="line">Session session2 = factory.openSession();</span><br><span class="line">System.out.println(session1.hashCode());</span><br><span class="line">System.out.println(session2.hashCode());</span><br><span class="line"></span><br><span class="line">Session session3 = factory.getCurrentSession();</span><br><span class="line">Session session4 = factory.getCurrentSession();</span><br><span class="line">System.out.println(session3.hashCode());</span><br><span class="line">System.out.println(session4.hashCode());</span><br></pre></td></tr></table></figure><p>​        要使用 2 方法，必须在 hibernate.cfg.xml 中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.current_session_context_class"</span>&gt;</span>thread<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Session-的-api"><a href="#Session-的-api" class="headerlink" title="Session 的 api"></a>Session 的 api</h3><p>save：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setUsername(<span class="string">"lxq"</span>);</span><br><span class="line">user.setPassword(<span class="string">"123"</span>);</span><br><span class="line">session1.save(user);</span><br></pre></td></tr></table></figure><p>get：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User u1 = (User)session1.get(User.class, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//通过 id 查询，没有事返回 null，获取的是 object 对象，需要强制转换</span></span><br></pre></td></tr></table></figure><p>load：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User u2 = (User)session1.load(User.class, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//同样通过 id 查修，但没有时报错</span></span><br></pre></td></tr></table></figure><p>delete：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.先获取要删除的对象，再调用 delete 方法</span></span><br><span class="line">User u1 = (User)session1.get(User.class, <span class="number">3</span>);</span><br><span class="line">session1.delete(u1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建一个 user，设置 id，然后调用 delete 方法</span></span><br><span class="line">User u2 = <span class="keyword">new</span> User();</span><br><span class="line">u2.setUid(<span class="number">2</span>);</span><br><span class="line">session1.delete(u2);</span><br></pre></td></tr></table></figure><p>update：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//session 使用 update 更新数据</span></span><br><span class="line"><span class="comment">//1.通过 get 获取数据，调用 set 方法，事务提交自动执行 update 语句</span></span><br><span class="line"><span class="comment">//2.自己封装 User 对象，设置 id，这个时候，需要调用 update 方法</span></span><br><span class="line">u1.setPassword(<span class="string">"abc"</span>);</span><br><span class="line">session1.update(u1);</span><br></pre></td></tr></table></figure><h4 id="get-和-load-方法的区别（面试）："><a href="#get-和-load-方法的区别（面试）：" class="headerlink" title="get 和 load 方法的区别（面试）："></a>get 和 load 方法的区别（面试）：</h4><p>​        get 方法是直接加载数据库</p><p>​        load 方法的设计是懒加载，用到是才会访问数据库，调用 load 方法时返回的是一个代理对象（javassist）</p><h2 id="Transaction-事务"><a href="#Transaction-事务" class="headerlink" title="Transaction 事务"></a>Transaction 事务</h2><p>​        这里不需要仔细看。因为后期的事务会交给 Spring 管理，直接上代码吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Transaction trans = session1.getTransaction();</span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line">trans.begin();</span><br><span class="line"></span><br><span class="line">User u1 = (User)session1.get(User.class, <span class="number">3</span>);</span><br><span class="line">u1.setPassword(<span class="string">"abc"</span>);</span><br><span class="line">session1.update(u1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line">trans.commit();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hibernate-框架简介&quot;&gt;&lt;a href=&quot;#Hibernate-框架简介&quot; class=&quot;headerlink&quot; title=&quot;Hibernate 框架简介&quot;&gt;&lt;/a&gt;Hibernate 框架简介&lt;/h1&gt;&lt;h2 id=&quot;ORM-框架&quot;&gt;&lt;a href=&quot;#ORM-框架&quot; class=&quot;headerlink&quot; title=&quot;ORM 框架&quot;&gt;&lt;/a&gt;ORM 框架&lt;/h2&gt;&lt;p&gt;​        对象关系映射，对象和表字段进行对应，是一种程序技术，用于实现面向对象编程语言里不用类型系统的数据之间的转换&lt;/p&gt;
&lt;h2 id=&quot;Hibernate-框架&quot;&gt;&lt;a href=&quot;#Hibernate-框架&quot; class=&quot;headerlink&quot; title=&quot;Hibernate 框架&quot;&gt;&lt;/a&gt;Hibernate 框架&lt;/h2&gt;&lt;p&gt;​        Hibernate 是一个开放源码的对象关系映射框架，它对 JDBC 进行了非常轻量级的对象封装，它将 POJO（简单的 JAVA 对象）与数据库表建立映射关系，是一个全自动的 ORM 框架&lt;/p&gt;
&lt;p&gt;​        Hibernate 可以自动生成 SQL 语句，自动执行，可以应用在任何使用 JDBC 的场合&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;p&gt;​        对 JDBC 访问数据库的代码做了封装，大大简化了数据访问层繁琐重复性代码&lt;/p&gt;
&lt;p&gt;​        是一个基于 jdbc 的主流持久化框架，是一个优秀的 orm 实现，有很大程度的简化了 dao 层编码工作&lt;/p&gt;
&lt;p&gt;​        Hibernate 使用了 JAVA 的反射机制&lt;/p&gt;
&lt;p&gt;​        Hibernate 性能好，是一个轻量级框架，映射灵活性出色，它支持很多关系型数据库，有一对一到多对多的各种复杂关系映射&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hibernate框架" scheme="http://yoursite.com/tags/Hibernate%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Struts2框架——Struts的错误回显以及struts标签</title>
    <link href="http://yoursite.com/2019/11/09/Struts2%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94Struts%E7%9A%84%E9%94%99%E8%AF%AF%E5%9B%9E%E6%98%BE%E4%BB%A5%E5%8F%8Astruts%E6%A0%87%E7%AD%BE/"/>
    <id>http://yoursite.com/2019/11/09/Struts2框架——Struts的错误回显以及struts标签/</id>
    <published>2019-11-09T01:37:44.000Z</published>
    <updated>2019-11-09T02:01:27.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Struts的错误回显以及struts标签"><a href="#Struts的错误回显以及struts标签" class="headerlink" title="Struts的错误回显以及struts标签"></a>Struts的错误回显以及struts标签</h1><p>​        本次记录一下 Struts 的错误回显以及 struts 框架前端标签的简单用法</p><a id="more"></a><h2 id="Struts-的错误回显"><a href="#Struts-的错误回显" class="headerlink" title="Struts 的错误回显"></a>Struts 的错误回显</h2><p>​        在 struts.xml 中的 result 标签中，把 name 属性的值设置成 input，这样当数据出现异常时，会自动回显到后边声明的 jsp 页面</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"register"</span> <span class="attr">class</span>=<span class="string">"com.lmh.action.UserAction"</span> <span class="attr">method</span>=<span class="string">"register"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 回显，出错后返回注册界面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"input"</span>&gt;</span>/register2.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="struts-标签"><a href="#struts-标签" class="headerlink" title="struts 标签"></a>struts 标签</h2><p>​        struts 提供了可以在前端页面中使用的标签，使用 struts 标签，可以实现很多 struts 框架支持的高级功能</p><p>​        首先，想要在前端页面中使用 struts 标签，需要在 jsp 页面中声明 struts 标签库</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@taglib</span> uri=<span class="string">"/struts-tags"</span> prefix=<span class="string">"s"</span> %&gt;</span><br></pre></td></tr></table></figure><p>​        下面简单发一下 struts 标签的用法吧</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> <span class="keyword">import</span>=<span class="string">"java.util.*"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">String path = request.getContextPath();</span><br><span class="line">String basePath = request.getScheme()+<span class="string">"://"</span>+request.getServerName()+<span class="string">":"</span>+request.getServerPort()+path+<span class="string">"/"</span>;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%<span class="meta">@taglib</span> uri=<span class="string">"/struts-tags"</span> prefix=<span class="string">"s"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;base href=<span class="string">"&lt;%=basePath%&gt;"</span>&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;title&gt;My JSP 'register2.jsp' starting page&lt;/title&gt;</span><br><span class="line">    </span><br><span class="line">&lt;meta http-equiv=<span class="string">"pragma"</span> content=<span class="string">"no-cache"</span>&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"cache-control"</span> content=<span class="string">"no-cache"</span>&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"expires"</span> content=<span class="string">"0"</span>&gt;    </span><br><span class="line">&lt;meta http-equiv=<span class="string">"keywords"</span> content=<span class="string">"keyword1,keyword2,keyword3"</span>&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"description"</span> content=<span class="string">"This is my page"</span>&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> href=<span class="string">"styles.css"</span>&gt;</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;!-- struts 表单的特点</span><br><span class="line">  <span class="number">1</span>.action 不需要写项目名</span><br><span class="line">  <span class="number">2</span>.会给表单里面的内容放在 table 中，并加上样式</span><br><span class="line">  <span class="number">3</span>.struts 标签必须有 name 属性</span><br><span class="line">   --&gt;</span><br><span class="line">    This is my JSP page. &lt;br&gt;</span><br><span class="line">    &lt;s:form action=<span class="string">"/login/register.action"</span>&gt;</span><br><span class="line">    &lt;s:textfield name="username" label="用户名"&gt;&lt;/s:textfield&gt;</span><br><span class="line">    &lt;s:textfield name="password" label="密码"&gt;&lt;/s:textfield&gt;</span><br><span class="line">    &lt;s:textfield name="birthday" label="生日"&gt;&lt;/s:textfield&gt;</span><br><span class="line">&lt;!-- list 使用 OGNL 表达式 --&gt;</span><br><span class="line">    &lt;s:checkboxlist list="#&#123;'coding':'写代码','basketball':'打篮球','soccer':'踢足球'&#125;" label="爱好" name="hobby"&gt;&lt;/s:checkboxlist&gt;</span><br><span class="line">    &lt;s:radio list="#&#123;'true':'已婚','false':'未婚'&#125;" label="是否已婚" name="married"&gt;&lt;/s:radio&gt;</span><br><span class="line">    &lt;s:submit value="注册" name="zc"&gt;&lt;/s:submit&gt;</span><br><span class="line">    &lt;/s:form&gt;</span><br><span class="line">  &lt;hr&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Struts的错误回显以及struts标签&quot;&gt;&lt;a href=&quot;#Struts的错误回显以及struts标签&quot; class=&quot;headerlink&quot; title=&quot;Struts的错误回显以及struts标签&quot;&gt;&lt;/a&gt;Struts的错误回显以及struts标签&lt;/h1&gt;&lt;p&gt;​        本次记录一下 Struts 的错误回显以及 struts 框架前端标签的简单用法&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaEE——Struts2框架" scheme="http://yoursite.com/tags/JavaEE%E2%80%94%E2%80%94Struts2%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Struts2框架——struts.xml文件配置及Action接受参数的方式</title>
    <link href="http://yoursite.com/2019/11/02/Struts2%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94struts-xml%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E5%8F%8AAction%E6%8E%A5%E5%8F%97%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/11/02/Struts2框架——struts-xml文件配置及Action接受参数的方式/</id>
    <published>2019-11-02T02:28:05.000Z</published>
    <updated>2019-11-02T03:39:31.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="struts-xml-文件配置及-Action-接受参数的方式"><a href="#struts-xml-文件配置及-Action-接受参数的方式" class="headerlink" title="struts.xml 文件配置及 Action 接受参数的方式"></a>struts.xml 文件配置及 Action 接受参数的方式</h1><p>​        本次记录一下 struts.xml 文件在多种模块下的配置方法以及 Action 在接受 view 种参数的方式</p><a id="more"></a><h2 id="struts-xml-配置"><a href="#struts-xml-配置" class="headerlink" title="struts.xml 配置"></a>struts.xml 配置</h2><p>​        在有需要多种模块配置要求下的 struts.xml 文件有两种配置方法</p><h3 id="多模块配置-struts-xml"><a href="#多模块配置-struts-xml" class="headerlink" title="多模块配置 struts.xml"></a>多模块配置 struts.xml</h3><p>​        使用 <package> 标签中的 namespace 属性，来对不同的模块进行分类</package></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 用户模块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">name</span>=<span class="string">"/user"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"addUser"</span> <span class="attr">class</span>=<span class="string">"com.lmh.web.action.UserAction"</span> <span class="attr">method</span>=<span class="string">"addUser"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/login.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 角色模块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"role"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">name</span>=<span class="string">"/role"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"addRole"</span> <span class="attr">class</span>=<span class="string">"com.lmh.web.action.RoleAction"</span> <span class="attr">method</span>=<span class="string">"addRole"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/login.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="多文件配置-struts-xml"><a href="#多文件配置-struts-xml" class="headerlink" title="多文件配置 struts.xml"></a>多文件配置 struts.xml</h3><p>​        使用多个 struts.xml 文件进行配置，在主 struts.xml 文件中添加 <include> 标签来进行引用</include></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"struts-order.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"struts-user.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Action-接受-View-种值的几种方式"><a href="#Action-接受-View-种值的几种方式" class="headerlink" title="Action 接受 View 种值的几种方式"></a>Action 接受 View 种值的几种方式</h2><h3 id="通过-Serlvlet-来获取"><a href="#通过-Serlvlet-来获取" class="headerlink" title="通过 Serlvlet 来获取"></a>通过 Serlvlet 来获取</h3><p>register.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"$&#123;pageContext.request.contextPath&#125;/login/register.action"</span>&gt;</span><br><span class="line">    用户名&lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span>&gt;&lt;br&gt;</span><br><span class="line">    密码&lt;input type=<span class="string">"password"</span> name=<span class="string">"password"</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> name=<span class="string">"zc"</span> value=<span class="string">"注册"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>UserAction：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HttpServletRequest req = ServletActionContext.getRequest();</span><br><span class="line">String username = req.getParameter(<span class="string">"username"</span>);</span><br><span class="line">String password = req.getParameter(<span class="string">"password"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(username);</span><br><span class="line">System.out.println(password);</span><br></pre></td></tr></table></figure><p>struts.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">name</span>=<span class="string">"/user"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"register"</span> <span class="attr">class</span>=<span class="string">"com.lmh.web.action.UserAction"</span> <span class="attr">method</span>=<span class="string">"register"</span>&gt;</span><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="通过-Action-的属性的-set-方法注入"><a href="#通过-Action-的属性的-set-方法注入" class="headerlink" title="通过 Action 的属性的 set 方法注入"></a>通过 Action 的属性的 set 方法注入</h3><p>​        struts 会通过表单字段的名称，调用 set 方法，比如 username 字段会调用 setUsername</p><p>UserAction：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"set username"</span>);</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"set password"</span>);</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过-Action-的属性的-set-模型的形式注入"><a href="#通过-Action-的属性的-set-模型的形式注入" class="headerlink" title="通过 Action 的属性的 set 模型的形式注入"></a>通过 Action 的属性的 set 模型的形式注入</h3><p>User：（模型，提供属性的  get/set 方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.web.model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"User [username="</span> + username + <span class="string">", password="</span> + password + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserAction：（把参数封装到一个 User 模型中，在 Action 中提供模型的 get/set 方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"get user"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"set user"</span>);</span><br><span class="line">    <span class="keyword">this</span>.user = user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>register.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"$&#123;pageContext.request.contextPath&#125;/login/register.action"</span>&gt;</span><br><span class="line">    用户名&lt;input type=<span class="string">"text"</span> name=<span class="string">"user.username"</span>&gt;&lt;br&gt;</span><br><span class="line">    密码&lt;input type=<span class="string">"password"</span> name=<span class="string">"user.password"</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> name=<span class="string">"zc"</span> value=<span class="string">"注册"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h3 id="通过-Action-模型驱动封装参数"><a href="#通过-Action-模型驱动封装参数" class="headerlink" title="通过 Action 模型驱动封装参数"></a>通过 Action 模型驱动封装参数</h3><p>register.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"$&#123;pageContext.request.contextPath&#125;/login/register.action"</span>&gt;</span><br><span class="line">    用户名&lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span>&gt;&lt;br&gt;</span><br><span class="line">    密码&lt;input type=<span class="string">"password"</span> name=<span class="string">"password"</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> name=<span class="string">"zc"</span> value=<span class="string">"注册"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>UserAction：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lmh.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmh.model.User;</span><br><span class="line"><span class="keyword">import</span> com.lmh.service.IUserService;</span><br><span class="line"><span class="keyword">import</span> com.lmh.service.impl.UserServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ModelDriven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> <span class="keyword">implements</span> <span class="title">ModelDriven</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> NONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数注入原理"><a href="#参数注入原理" class="headerlink" title="参数注入原理"></a>参数注入原理</h3><p>​        参数会自动注入是因为 struts-default.xml 中有两个拦截器在工作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">"params"</span> <span class="attr">class</span>=<span class="string">"com.opensymphony.xwork2.interceptor.ParametersInterceptor"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">"modelDriven"</span> <span class="attr">class</span>=<span class="string">"com.opensymphony.xwork2.interceptor.ModelDrivenInterceptor"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>​    1.struts 的默认拦截器是由 defaultStack 决定的</p><p>​    2.如果在 package 中不写拦截器，就是 struts-default 中的defaultStack 的拦截器在工作</p><p>​    3.一旦在 package 中写了拦截器，struts-default 中的 defaultStack 的任何拦截器就都不工作了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;struts-xml-文件配置及-Action-接受参数的方式&quot;&gt;&lt;a href=&quot;#struts-xml-文件配置及-Action-接受参数的方式&quot; class=&quot;headerlink&quot; title=&quot;struts.xml 文件配置及 Action 接受参数的方式&quot;&gt;&lt;/a&gt;struts.xml 文件配置及 Action 接受参数的方式&lt;/h1&gt;&lt;p&gt;​        本次记录一下 struts.xml 文件在多种模块下的配置方法以及 Action 在接受 view 种参数的方式&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaEE——Struts2框架" scheme="http://yoursite.com/tags/JavaEE%E2%80%94%E2%80%94Struts2%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Struts2框架——struts.xml文件详解</title>
    <link href="http://yoursite.com/2019/10/27/Struts2%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94struts-xml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/10/27/Struts2框架——struts-xml文件详解/</id>
    <published>2019-10-27T01:16:04.000Z</published>
    <updated>2019-10-27T03:47:08.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="struts-xml-文件"><a href="#struts-xml-文件" class="headerlink" title="struts.xml 文件"></a>struts.xml 文件</h1><p>​        struts.xml 是 Struts2 最核心最常用的配置文件，下面详细介绍一下 struts.xml 中的元素和配置</p><a id="more"></a><h2 id="package-元素"><a href="#package-元素" class="headerlink" title="package 元素"></a>package 元素</h2><p>​        struts2 的配置文件中引入了面向对象的思想，使用了分包管理。易于管理动作类，便于模块化开发动作类</p><h3 id="package-元素的属性"><a href="#package-元素的属性" class="headerlink" title="package 元素的属性"></a>package 元素的属性</h3><p>​        name：包的名称，必须写，并且名称唯一</p><p>​        extends：继承自哪个基础包，通常继承 struts-default 包</p><p>​                          struts-default.xml 中定义着 struts-default 包</p><p>​                          struts-default.xml 是在 struts.xml 之前加载的</p><p>​        abstract：把包声明为抽象包，抽象包就是用来被继承的</p><p>​                          只要没有 <action> 元素的包，就可以声明为抽象包</action></p><p>​        namespace：命名空间。【访问路径 = 命名空间 + 动作名称】</p><h4 id="namespace-详解"><a href="#namespace-详解" class="headerlink" title="namespace 详解"></a>namespace 详解</h4><p>​        namespace 的默认取值是一个“”，不需要写 /</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"p2"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">namespace</span>=<span class="string">"/user"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"add"</span> <span class="attr">class</span>=<span class="string">"com.web.action.UserAction"</span> <span class="attr">method</span>=<span class="string">"add"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/add.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"delete"</span> <span class="attr">class</span>=<span class="string">"com.web.action.UserAction"</span> <span class="attr">method</span>=<span class="string">"delete"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/delete.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"update"</span> <span class="attr">class</span>=<span class="string">"com.web.action.UserAction"</span> <span class="attr">method</span>=<span class="string">"update"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/update.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"find"</span> <span class="attr">class</span>=<span class="string">"com.web.action.UserAction"</span> <span class="attr">method</span>=<span class="string">"find"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/find.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        如果有两层命名空间，查找规则是从后向前查找</p><h2 id="action-元素"><a href="#action-元素" class="headerlink" title="action 元素"></a>action 元素</h2><p>​        配置动作，处理请求路径</p><h3 id="action-元素的属性"><a href="#action-元素的属性" class="headerlink" title="action 元素的属性"></a>action 元素的属性</h3><p>​        name：动作名称，同一个命名空间下要求名称唯一</p><p>​        class：动作类全路径名</p><p>​        method：动作类中的方法名，默认是 public String execute()</p><p>​            方法的要求：</p><p>​                1.public 的</p><p>​                2.返回值必须是 String</p><p>​                3.没有参数</p><h3 id="动作类-Action-的写法"><a href="#动作类-Action-的写法" class="headerlink" title="动作类 Action 的写法"></a>动作类 Action 的写法</h3><p>####动作类的第一种写法</p><p>​        直接写一个 Action 类，不需要继承任何类，然后在 struts.xml 中配置</p><p>Action 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.web.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloAction</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Success"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>struts.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"p1"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">namespace</span>=<span class="string">"/a"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"hello"</span> <span class="attr">class</span>=<span class="string">"com.web.action.HelloAction"</span> <span class="attr">method</span>=<span class="string">"sayHello"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>####动作类的第二种写法</p><p>​        写一个实现 Action 接口的动作类，然后实现 execute 方法</p><p>Action 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.web.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.Action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demoAction</span> <span class="keyword">implements</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>struts.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"p1"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">namespace</span>=<span class="string">"/a"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"demo"</span> <span class="attr">class</span>=<span class="string">"com.web.action.demoAction"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        Action 接口中有一些静态常量：SUCCESS，NONE，ERROR，INPUT，LOGIN，可以直接在返回值中使用</p><h4 id="动作类的第三种写法（推荐）"><a href="#动作类的第三种写法（推荐）" class="headerlink" title="动作类的第三种写法（推荐）"></a>动作类的第三种写法（推荐）</h4><p>​        写一个继承 ActionSupport 类的 Action 类</p><p>​        ActionSupport 是实现 Action 接口定的类</p><p>Action：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.web.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginAction3</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>struts.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"p1"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">namespace</span>=<span class="string">"/a"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"login3"</span> <span class="attr">class</span>=<span class="string">"com.web.action.LoginAction3"</span> <span class="attr">method</span>=<span class="string">"login"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="默认动作类"><a href="#默认动作类" class="headerlink" title="默认动作类"></a>默认动作类</h4><p>​        struts-default.xml 中定义了默认动作类和方法</p><p>​        默认的动作类就是 com.opensymphony.xwork2.ActionSupport 这个类</p><p>struts.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">default-class-ref</span> <span class="attr">class</span>=<span class="string">"com.web.action.HelloAction"</span>&gt;</span><span class="tag">&lt;/<span class="name">default-class-ref</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"hello"</span> <span class="attr">class</span>=<span class="string">"com.web.action.HelloAction"</span> <span class="attr">method</span>=<span class="string">"sayHello"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 没有配置 method 的 action，默认访问 execute 方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="result-元素"><a href="#result-元素" class="headerlink" title="result 元素"></a>result 元素</h2><p>​        为动作指定结果试图</p><h3 id="result-元素的属性"><a href="#result-元素的属性" class="headerlink" title="result 元素的属性"></a>result 元素的属性</h3><p>​        name：逻辑视图的名称，对应着动作方法的返回值，默认值是 success</p><p>​        type：结果类型，指的就是用什么方式转到定义的页面，默认是 dispather 转发</p><p>​            dispatcher：使用请求转发，转向一个页面</p><p>​            redirect：使用重定向，转向一个页面</p><p>​            chain：转发到另一个相同或不同命名空间的动作</p><p>​            redirectAction：重定向到相同或不同命名空间的动作</p><h4 id="result-元素中的-param-子元素"><a href="#result-元素中的-param-子元素" class="headerlink" title="result 元素中的 param 子元素"></a>result 元素中的 param 子元素</h4><p>​        在转发或者重定向到不同包下的动作时，都要用到 result 元素的子元素 param</p><p>​        param 元素的作用：依赖注入</p><p>​        通过 struts-default.xml 中的 resultTypes 元素中配置可以看出，每个结果试图都是靠一个类来实现的</p><p>​        param 元素就是将配置参数注入到该类中</p><p>​        调用的事i对应类的 setter 方法进行注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"p5"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">namespace</span>=<span class="string">"/demo"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"action1"</span> <span class="attr">class</span>=<span class="string">"com.web.action.Demo1Action"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- result 的 name 可以不写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 转发到同一个包下的 action --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"action3"</span> <span class="attr">class</span>=<span class="string">"com.web.action.ChainAction1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span> <span class="attr">type</span>=<span class="string">"chain"</span>&gt;</span>action1<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"action4"</span> <span class="attr">class</span>=<span class="string">"com.web.action.ChainAction1"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span> <span class="attr">type</span>=<span class="string">"redirectAction"</span>&gt;</span>action1<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"action5"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span> <span class="attr">type</span>=<span class="string">"chain"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 依赖注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"namespace"</span>&gt;</span>/a<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"actionName"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">param</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"action6"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span> <span class="attr">type</span>=<span class="string">"redirectAction"</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 依赖注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"namespace"</span>&gt;</span>/a<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"actionName"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">param</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">result</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;struts-xml-文件&quot;&gt;&lt;a href=&quot;#struts-xml-文件&quot; class=&quot;headerlink&quot; title=&quot;struts.xml 文件&quot;&gt;&lt;/a&gt;struts.xml 文件&lt;/h1&gt;&lt;p&gt;​        struts.xml 是 Struts2 最核心最常用的配置文件，下面详细介绍一下 struts.xml 中的元素和配置&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaEE——Struts2框架" scheme="http://yoursite.com/tags/JavaEE%E2%80%94%E2%80%94Struts2%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
</feed>
