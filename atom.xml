<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Step By Step</title>
  
  <subtitle>耀出千分光</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-11-27T11:53:13.606Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LiMinghui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>JAVA基础——JAVA简介和运行原理</title>
    <link href="http://yoursite.com/2019/11/27/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JAVA%E7%AE%80%E4%BB%8B%E5%92%8C%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2019/11/27/JAVA基础——JAVA简介和运行原理/</id>
    <published>2019-11-27T02:12:54.000Z</published>
    <updated>2019-11-27T11:53:13.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><p>​        本系列主要更新 Java 基础相关的知识，最近准备重新复习一遍 Java 基础，主要涉及一些原理上的东西，会持续更新！</p><a id="more"></a><p>##Java 简介</p><p>​        Java 是一种简洁的、面向对象的、分布式的、解释型的、健壮安全的、结构中立的、可移植的、性能优异、多线程的动态语言</p><p>​        看不懂吧，简单来说，Java 就是一种面向对象的编程语言，功能完善、安全、使用广泛，在 WEB</p><p> 程序设计、嵌入式开发、桌面应用开发等开发工作中都占有一席之地</p><p>##Java 平台</p><p>​        当前 Java 技术的平台架构包括三方面：</p><p>​        Java SE：开发部署在桌面、服务器、嵌入式环境和实时环境的 Java 应用程序，包含了 Java Web 服务开发的类，为 Java EE 提供基础</p><p>​        Java EE：帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。Java EE 是在 Java SE 的基础上构建的，提供了 Web 服务、组件模型、管理和通信 API，且可以用来实现企业级的面向服务体系结构和 Web 应用程序</p><p>​        Java ME：为在移动设备和嵌入式设备上运行的应用程序提供了一个健壮且灵活的环境，Java ME 包括灵活的用户界面、健壮的安全模式</p><h2 id="Java-运行流程"><a href="#Java-运行流程" class="headerlink" title="Java 运行流程"></a>Java 运行流程</h2><p>​        1.使用文字编辑软件或集成开发环境编辑 Java 源文件，扩展名为 .java</p><p>​        2.通过编译 .java 文件，生成同名的 .class 字节码文件</p><p>​        3.通过 JVM 解释方式，将 .class 字节码文件转变为由 0 或 1 组成的二进制指令（机器码）运行</p><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>​        JDK 是 Java 开发包（开发工具），JDK 是整个 Java 的核心，包含了 JRE，Java 工具类和 Java 核心类库</p><p>​        JDK 适合编译解释小型 Java 文件，随着项目体积的变大，使用 JDK 来维护各类（class）间的依赖关系将变得十分繁琐和复杂</p><h2 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h2><p>​        JRE 是 Java 运行环境，包含了 JVM（Java 虚拟机）标准实现及 Java 核心类库，但不包含编译器、调试器和其他工具</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>​        JVM 是 Java 虚拟机，是 Java 跨平台性的基础，Java 的 .class 字节码文件因为会在 JVM 中被解释成面型不同系统的机器码文件，所以 Java 才具有了跨平台性</p><h3 id="JVM-的内存模型"><a href="#JVM-的内存模型" class="headerlink" title="JVM 的内存模型"></a>JVM 的内存模型</h3><blockquote><p>运行时数据区</p><blockquote><p>方法区</p><p>虚拟机栈</p><p>本地方法栈</p><p>堆</p><p>程序计数器</p></blockquote><p>执行引擎</p><p>本地接口</p><p>本地方法库</p></blockquote><p>​        JVM 还有很多内容，我还在继续学习！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JAVA&quot;&gt;&lt;a href=&quot;#JAVA&quot; class=&quot;headerlink&quot; title=&quot;JAVA&quot;&gt;&lt;/a&gt;JAVA&lt;/h1&gt;&lt;p&gt;​        本系列主要更新 Java 基础相关的知识，最近准备重新复习一遍 Java 基础，主要涉及一些原理上的东西，会持续更新！&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate——其他查询方法</title>
    <link href="http://yoursite.com/2019/11/25/Hibernate%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/11/25/Hibernate框架——其他查询方法/</id>
    <published>2019-11-25T10:32:30.000Z</published>
    <updated>2019-11-25T12:16:08.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hibernate-框架的查询方法"><a href="#Hibernate-框架的查询方法" class="headerlink" title="Hibernate 框架的查询方法"></a>Hibernate 框架的查询方法</h1><p>​        除了通过 session.get() 方法进行查询外，Hibernate 框架还提供了其他的查询方式</p><a id="more"></a><h2 id="Query-查询对象"><a href="#Query-查询对象" class="headerlink" title="Query 查询对象"></a>Query 查询对象</h2><p>​        query 查询对象可以通过设置查询条件进行查询，使用 HQL 语言（Hibernate Query Language），是 Hibernate 的面向对象查询语言，最终底层要转成面向数据库查询语言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.查询所有用户</span></span><br><span class="line">Query query = session.createQuery(<span class="string">"From User"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.查询符合条件得用户【username 和 password 是 User 对象得属性，而不是表的字段名】</span></span><br><span class="line">Query query = session.createQuery(<span class="string">"From User where username = ? and password = ?"</span>);</span><br><span class="line">query.setParameter(<span class="number">0</span>, <span class="string">"lmh"</span>);</span><br><span class="line">query.setParameter(<span class="number">1</span>, <span class="string">"123"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.分页查询</span></span><br><span class="line">Query query = session.creatQuery(<span class="string">"From User"</span>);</span><br><span class="line">query.setMaxResults(<span class="number">3</span>);</span><br><span class="line">query.setFirstResult(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h2 id="Criteria-查询对象"><a href="#Criteria-查询对象" class="headerlink" title="Criteria 查询对象"></a>Criteria 查询对象</h2><p>​        QBC（query by criteria），是 hibernate 提供纯面向对象查询得语言，提供直接使用 PO 对象进行操作</p><p>​        PO：persistent object，用于与数据库交互数据——dao 层（JavaBean + hbm）</p><p>​        BO：business object，业务数据对象——service 层</p><p>​        VO：value object 值对象——web 层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Criteria：hibernate 独创的查询对象，全程无 hql 语言</span></span><br><span class="line">Criteria criteria = session.createCriteria(User.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等于 =</span></span><br><span class="line">criteria.add(Restriction.eq(<span class="string">"lmh"</span>, <span class="string">"123"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//like</span></span><br><span class="line">criteria.add(Restriction.like(<span class="string">"lmh"</span>, <span class="string">"%123%"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//..........</span></span><br></pre></td></tr></table></figure><h2 id="SQLQuery-查询对象"><a href="#SQLQuery-查询对象" class="headerlink" title="SQLQuery 查询对象"></a>SQLQuery 查询对象</h2><p>​        SQLQuery：使用原生的 SQL 语句查询</p><p>​        并不是所有的 sql 都能转成 hql</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQLQuery query = session.createSQLQuery(<span class="string">"select * from t_user"</span>);</span><br></pre></td></tr></table></figure><h2 id="文件逻辑优化"><a href="#文件逻辑优化" class="headerlink" title="文件逻辑优化"></a>文件逻辑优化</h2><h3 id="使用工具类"><a href="#使用工具类" class="headerlink" title="使用工具类"></a>使用工具类</h3><p>​        将重复代码封装进工具类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.cfg.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateUtils</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SessionFactory sf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"><span class="comment">//1.加载配置</span></span><br><span class="line">Configuration cfg = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建一个sessionFactory</span></span><br><span class="line">sf = cfg.buildSessionFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.在虚拟机关闭时，释放SessionFactory</span></span><br><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sf.close();</span><br><span class="line">System.out.println(<span class="string">"释放资源"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">openSession</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> sf.openSession();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getCurrentSession</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> sf.getCurrentSession();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hibernate-框架的查询方法&quot;&gt;&lt;a href=&quot;#Hibernate-框架的查询方法&quot; class=&quot;headerlink&quot; title=&quot;Hibernate 框架的查询方法&quot;&gt;&lt;/a&gt;Hibernate 框架的查询方法&lt;/h1&gt;&lt;p&gt;​        除了通过 session.get() 方法进行查询外，Hibernate 框架还提供了其他的查询方式&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hibernate框架" scheme="http://yoursite.com/tags/Hibernate%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate框架——框架的使用及简单配置讲解</title>
    <link href="http://yoursite.com/2019/11/18/Hibernate%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8%E5%8F%8A%E7%AE%80%E5%8D%95%E9%85%8D%E7%BD%AE%E8%AE%B2%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/11/18/Hibernate框架——框架的使用及简单配置讲解/</id>
    <published>2019-11-18T04:28:07.000Z</published>
    <updated>2019-11-19T02:32:50.725Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hibernate-框架简介"><a href="#Hibernate-框架简介" class="headerlink" title="Hibernate 框架简介"></a>Hibernate 框架简介</h1><h2 id="ORM-框架"><a href="#ORM-框架" class="headerlink" title="ORM 框架"></a>ORM 框架</h2><p>​        对象关系映射，对象和表字段进行对应，是一种程序技术，用于实现面向对象编程语言里不用类型系统的数据之间的转换</p><h2 id="Hibernate-框架"><a href="#Hibernate-框架" class="headerlink" title="Hibernate 框架"></a>Hibernate 框架</h2><p>​        Hibernate 是一个开放源码的对象关系映射框架，它对 JDBC 进行了非常轻量级的对象封装，它将 POJO（简单的 JAVA 对象）与数据库表建立映射关系，是一个全自动的 ORM 框架</p><p>​        Hibernate 可以自动生成 SQL 语句，自动执行，可以应用在任何使用 JDBC 的场合</p><p>优点：</p><p>​        对 JDBC 访问数据库的代码做了封装，大大简化了数据访问层繁琐重复性代码</p><p>​        是一个基于 jdbc 的主流持久化框架，是一个优秀的 orm 实现，有很大程度的简化了 dao 层编码工作</p><p>​        Hibernate 使用了 JAVA 的反射机制</p><p>​        Hibernate 性能好，是一个轻量级框架，映射灵活性出色，它支持很多关系型数据库，有一对一到多对多的各种复杂关系映射</p><a id="more"></a><h2 id="Hibernate-框架使用"><a href="#Hibernate-框架使用" class="headerlink" title="Hibernate 框架使用"></a>Hibernate 框架使用</h2><h3 id="核心配置文件-hibernate-cfg-xml"><a href="#核心配置文件-hibernate-cfg-xml" class="headerlink" title="核心配置文件 hibernate.cfg.xml"></a>核心配置文件 hibernate.cfg.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-configuration PUBLIC "-//Hibernate/Hibernate Configuration DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-configuration</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 1、配置数据库连接的4个参数 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.driver_class"</span>&gt;</span>com.mysql.cj.jdbc.Driver<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.url"</span>&gt;</span>jdbc:mysql://localhost:3306/hibernate_day1?useSSL=false&amp;amp;serverTimezone=Hongkong&amp;amp;characterEncoding=utf-8&amp;amp;autoReconnect=true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.username"</span>&gt;</span>root<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.password"</span>&gt;</span>lmh12358<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 开启与当前线程绑定 session 的功能 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.current_session_context_class"</span>&gt;</span>thread<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"javax.persistence.validation.mode"</span>&gt;</span>none<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  是否显示sql语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.show_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  是否格式化sql语句 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.format_sql"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!--  是否自动提交事务 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.connection.autocommit"</span>&gt;</span>true<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&lt;!-- 2、配置JavaBean与表的映射文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"com/lmh/hibernate/domain/User.hbm.xml"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">session-factory</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-configuration</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Java-Bean-对象映射文件-Class-hbm-xml"><a href="#Java-Bean-对象映射文件-Class-hbm-xml" class="headerlink" title="Java Bean 对象映射文件 Class.hbm.xml"></a>Java Bean 对象映射文件 Class.hbm.xml</h3><p>User.java：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lmh.hibernate.domain;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> <span class="keyword">int</span> uid;</span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">getUid</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> uid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUid</span><span class="params">(<span class="keyword">int</span> uid)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.uid = uid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>User.hbm.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE hibernate-mapping PUBLIC "-//Hibernate/Hibernate Mapping DTD 3.0//EN"</span></span><br><span class="line"><span class="meta">"http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">hibernate-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">class</span> <span class="attr">name</span>=<span class="string">"com.lmh.hibernate.domain.User"</span> <span class="attr">table</span>=<span class="string">"t_user"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- name：模型中的属性名 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">id</span> <span class="attr">name</span>=<span class="string">"uid"</span> <span class="attr">column</span>=<span class="string">"id"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- id 的生成策略 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">generator</span> <span class="attr">class</span>=<span class="string">"native"</span>&gt;</span><span class="tag">&lt;/<span class="name">generator</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 如果表中类中字段名相同不用写 column --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span>&gt;</span><span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">class</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">hibernate-mapping</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="所用-jar-包"><a href="#所用-jar-包" class="headerlink" title="所用 jar 包"></a>所用 jar 包</h3><blockquote><p>antlr-2.7.6.jar</p><p>commons-collections-3.1.jar</p><p>dom4j-1.6.1.jar</p><p>hibernate-jpa-2.0-api-1.0.1.Final.jar</p><p>hibernate3.jar</p><p>javassist-3.12.0.GA.jar</p><p>jta-1.1.jar</p><p>mysql-connector-java-8.0.16.jar</p><p>slf4j-api-1.6.1.jar</p></blockquote><h3 id="测试类："><a href="#测试类：" class="headerlink" title="测试类："></a>测试类：</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lmh.hibernate.test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.Transaction;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.cfg.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmh.hibernate.domain.User;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">testDemo</span> </span>&#123;</span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test1</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//保存用户数据</span></span><br><span class="line"><span class="comment">//1.获取核心配置文件对象，configure()无参数默认是加载 src 的 hibernate.cfg.xml 文件</span></span><br><span class="line">Configuration cfg = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line">        </span><br><span class="line"><span class="comment">//2.创建会话工厂</span></span><br><span class="line">SessionFactory factory = cfg.buildSessionFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.创建会话【相当于连接 Connect】</span></span><br><span class="line"><span class="comment">//openSession()获取一个全新的 session</span></span><br><span class="line"><span class="comment">//factory.getCurrentSession获取一个与当前线程绑定的 session</span></span><br><span class="line">Session session1 = factory.openSession();</span><br><span class="line"></span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line">Transaction trans = session1.getTransaction();</span><br><span class="line">trans.begin();</span><br><span class="line"></span><br><span class="line"><span class="comment">//保存【直接把对象保存到数据库】</span></span><br><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setUsername(<span class="string">"skw"</span>);</span><br><span class="line">user.setPassword(<span class="string">"123"</span>);</span><br><span class="line">session1.save(user);</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line">trans.commit();</span><br><span class="line"></span><br><span class="line"><span class="comment">//4.关闭会话</span></span><br><span class="line">session1.close();</span><br><span class="line"></span><br><span class="line"><span class="comment">//5.关闭工厂</span></span><br><span class="line">factory.close();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Configuration-配置对象"><a href="#Configuration-配置对象" class="headerlink" title="Configuration 配置对象"></a>Configuration 配置对象</h2><p>​        Configuration 对象用来加载配置文件，new Configuration 构造方法加载的时 hibernate.properties，configure 方法加载的是 hibernate.cfg.xml，通常这两种配置文件都会被放在 src 目录下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//保存用户数据</span></span><br><span class="line"><span class="comment">//1.获取核心配置文件对象，configure()无参数默认是加载 src 的 hibernate.cfg.xml 文件</span></span><br><span class="line"><span class="comment">//2.直接 new 出来的对象默认调用 hibernate.properties</span></span><br><span class="line">Configuration cfg = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line">Configuration cfg = <span class="keyword">new</span> Configuration();</span><br></pre></td></tr></table></figure><h3 id="加载-Class-hbm-xml-映射文件的方式"><a href="#加载-Class-hbm-xml-映射文件的方式" class="headerlink" title="加载 Class.hbm.xml 映射文件的方式"></a>加载 Class.hbm.xml 映射文件的方式</h3><p>hibernate.cfg.xml中：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 1.在 hibernate.cfg.xml 中配置JavaBean与表的映射文件 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">mapping</span> <span class="attr">resource</span>=<span class="string">"com/lmh/hibernate/domain/User.hbm.xml"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>测试类中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//2.调用 Configuration 对象的 addResource</span></span><br><span class="line">cfg.addResource(<span class="string">"com/lmh/hibernate/domain/User.hbm.xml"</span>);</span><br><span class="line"><span class="comment">//3.调用 Configuration 对象的 addClass 方法</span></span><br><span class="line">cfg.addClass(User.class);</span><br></pre></td></tr></table></figure><h2 id="SessionFactory-工厂"><a href="#SessionFactory-工厂" class="headerlink" title="SessionFactory 工厂"></a>SessionFactory 工厂</h2><p>​        SessionFactory 相当于 Java Web 连接池，用于管理所有的 session，通过调用 Configuration 对象的 buildSessionFactory 方法来获得 SessionFactory，它还用于缓存配置信息（数据库配置信息、映射文件、预定义 HQL 语句等），SessionFactory 线程安全，多个线程同时访问时不会出现线程并发访问问题</p><h2 id="Session-会话"><a href="#Session-会话" class="headerlink" title="Session 会话"></a>Session 会话</h2><p>​        创建一个 Session 就相当于建立了一个 Connection，建立后可以通过 Session 来对数据库中的表进行操作</p><h3 id="Session-会话的获取"><a href="#Session-会话的获取" class="headerlink" title="Session 会话的获取"></a>Session 会话的获取</h3><p>​        SessionFactory 提供了两个方法来获取 Session：</p><p>​        1.factory.openSession()：获取一个全新的 Session</p><p>​        2.factory.getCurrentSession()：获取一个与当前线程绑定的 Session</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Session session1 = factory.openSession();</span><br><span class="line">Session session2 = factory.openSession();</span><br><span class="line">System.out.println(session1.hashCode());</span><br><span class="line">System.out.println(session2.hashCode());</span><br><span class="line"></span><br><span class="line">Session session3 = factory.getCurrentSession();</span><br><span class="line">Session session4 = factory.getCurrentSession();</span><br><span class="line">System.out.println(session3.hashCode());</span><br><span class="line">System.out.println(session4.hashCode());</span><br></pre></td></tr></table></figure><p>​        要使用 2 方法，必须在 hibernate.cfg.xml 中配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"hibernate.current_session_context_class"</span>&gt;</span>thread<span class="tag">&lt;/<span class="name">property</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="Session-的-api"><a href="#Session-的-api" class="headerlink" title="Session 的 api"></a>Session 的 api</h3><p>save：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">User user = <span class="keyword">new</span> User();</span><br><span class="line">user.setUsername(<span class="string">"lxq"</span>);</span><br><span class="line">user.setPassword(<span class="string">"123"</span>);</span><br><span class="line">session1.save(user);</span><br></pre></td></tr></table></figure><p>get：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User u1 = (User)session1.get(User.class, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//通过 id 查询，没有事返回 null，获取的是 object 对象，需要强制转换</span></span><br></pre></td></tr></table></figure><p>load：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">User u2 = (User)session1.load(User.class, <span class="number">3</span>);</span><br><span class="line"><span class="comment">//同样通过 id 查修，但没有时报错</span></span><br></pre></td></tr></table></figure><p>delete：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.先获取要删除的对象，再调用 delete 方法</span></span><br><span class="line">User u1 = (User)session1.get(User.class, <span class="number">3</span>);</span><br><span class="line">session1.delete(u1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建一个 user，设置 id，然后调用 delete 方法</span></span><br><span class="line">User u2 = <span class="keyword">new</span> User();</span><br><span class="line">u2.setUid(<span class="number">2</span>);</span><br><span class="line">session1.delete(u2);</span><br></pre></td></tr></table></figure><p>update：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//session 使用 update 更新数据</span></span><br><span class="line"><span class="comment">//1.通过 get 获取数据，调用 set 方法，事务提交自动执行 update 语句</span></span><br><span class="line"><span class="comment">//2.自己封装 User 对象，设置 id，这个时候，需要调用 update 方法</span></span><br><span class="line">u1.setPassword(<span class="string">"abc"</span>);</span><br><span class="line">session1.update(u1);</span><br></pre></td></tr></table></figure><h4 id="get-和-load-方法的区别（面试）："><a href="#get-和-load-方法的区别（面试）：" class="headerlink" title="get 和 load 方法的区别（面试）："></a>get 和 load 方法的区别（面试）：</h4><p>​        get 方法是直接加载数据库</p><p>​        load 方法的设计是懒加载，用到是才会访问数据库，调用 load 方法时返回的是一个代理对象（javassist）</p><h2 id="Transaction-事务"><a href="#Transaction-事务" class="headerlink" title="Transaction 事务"></a>Transaction 事务</h2><p>​        这里不需要仔细看。因为后期的事务会交给 Spring 管理，直接上代码吧</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Transaction trans = session1.getTransaction();</span><br><span class="line"><span class="comment">//开启事务</span></span><br><span class="line">trans.begin();</span><br><span class="line"></span><br><span class="line">User u1 = (User)session1.get(User.class, <span class="number">3</span>);</span><br><span class="line">u1.setPassword(<span class="string">"abc"</span>);</span><br><span class="line">session1.update(u1);</span><br><span class="line"></span><br><span class="line"><span class="comment">//提交事务</span></span><br><span class="line">trans.commit();</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hibernate-框架简介&quot;&gt;&lt;a href=&quot;#Hibernate-框架简介&quot; class=&quot;headerlink&quot; title=&quot;Hibernate 框架简介&quot;&gt;&lt;/a&gt;Hibernate 框架简介&lt;/h1&gt;&lt;h2 id=&quot;ORM-框架&quot;&gt;&lt;a href=&quot;#ORM-框架&quot; class=&quot;headerlink&quot; title=&quot;ORM 框架&quot;&gt;&lt;/a&gt;ORM 框架&lt;/h2&gt;&lt;p&gt;​        对象关系映射，对象和表字段进行对应，是一种程序技术，用于实现面向对象编程语言里不用类型系统的数据之间的转换&lt;/p&gt;
&lt;h2 id=&quot;Hibernate-框架&quot;&gt;&lt;a href=&quot;#Hibernate-框架&quot; class=&quot;headerlink&quot; title=&quot;Hibernate 框架&quot;&gt;&lt;/a&gt;Hibernate 框架&lt;/h2&gt;&lt;p&gt;​        Hibernate 是一个开放源码的对象关系映射框架，它对 JDBC 进行了非常轻量级的对象封装，它将 POJO（简单的 JAVA 对象）与数据库表建立映射关系，是一个全自动的 ORM 框架&lt;/p&gt;
&lt;p&gt;​        Hibernate 可以自动生成 SQL 语句，自动执行，可以应用在任何使用 JDBC 的场合&lt;/p&gt;
&lt;p&gt;优点：&lt;/p&gt;
&lt;p&gt;​        对 JDBC 访问数据库的代码做了封装，大大简化了数据访问层繁琐重复性代码&lt;/p&gt;
&lt;p&gt;​        是一个基于 jdbc 的主流持久化框架，是一个优秀的 orm 实现，有很大程度的简化了 dao 层编码工作&lt;/p&gt;
&lt;p&gt;​        Hibernate 使用了 JAVA 的反射机制&lt;/p&gt;
&lt;p&gt;​        Hibernate 性能好，是一个轻量级框架，映射灵活性出色，它支持很多关系型数据库，有一对一到多对多的各种复杂关系映射&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hibernate框架" scheme="http://yoursite.com/tags/Hibernate%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Struts2框架——Struts的错误回显以及struts标签</title>
    <link href="http://yoursite.com/2019/11/09/Struts2%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94Struts%E7%9A%84%E9%94%99%E8%AF%AF%E5%9B%9E%E6%98%BE%E4%BB%A5%E5%8F%8Astruts%E6%A0%87%E7%AD%BE/"/>
    <id>http://yoursite.com/2019/11/09/Struts2框架——Struts的错误回显以及struts标签/</id>
    <published>2019-11-09T01:37:44.000Z</published>
    <updated>2019-11-09T02:01:27.744Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Struts的错误回显以及struts标签"><a href="#Struts的错误回显以及struts标签" class="headerlink" title="Struts的错误回显以及struts标签"></a>Struts的错误回显以及struts标签</h1><p>​        本次记录一下 Struts 的错误回显以及 struts 框架前端标签的简单用法</p><a id="more"></a><h2 id="Struts-的错误回显"><a href="#Struts-的错误回显" class="headerlink" title="Struts 的错误回显"></a>Struts 的错误回显</h2><p>​        在 struts.xml 中的 result 标签中，把 name 属性的值设置成 input，这样当数据出现异常时，会自动回显到后边声明的 jsp 页面</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"register"</span> <span class="attr">class</span>=<span class="string">"com.lmh.action.UserAction"</span> <span class="attr">method</span>=<span class="string">"register"</span>&gt;</span></span><br><span class="line">    <span class="comment">&lt;!-- 回显，出错后返回注册界面 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"input"</span>&gt;</span>/register2.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="struts-标签"><a href="#struts-标签" class="headerlink" title="struts 标签"></a>struts 标签</h2><p>​        struts 提供了可以在前端页面中使用的标签，使用 struts 标签，可以实现很多 struts 框架支持的高级功能</p><p>​        首先，想要在前端页面中使用 struts 标签，需要在 jsp 页面中声明 struts 标签库</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;%<span class="meta">@taglib</span> uri=<span class="string">"/struts-tags"</span> prefix=<span class="string">"s"</span> %&gt;</span><br></pre></td></tr></table></figure><p>​        下面简单发一下 struts 标签的用法吧</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">&lt;%@ page language=<span class="string">"java"</span> <span class="keyword">import</span>=<span class="string">"java.util.*"</span> pageEncoding=<span class="string">"UTF-8"</span>%&gt;</span><br><span class="line">&lt;%</span><br><span class="line">String path = request.getContextPath();</span><br><span class="line">String basePath = request.getScheme()+<span class="string">"://"</span>+request.getServerName()+<span class="string">":"</span>+request.getServerPort()+path+<span class="string">"/"</span>;</span><br><span class="line">%&gt;</span><br><span class="line">&lt;%<span class="meta">@taglib</span> uri=<span class="string">"/struts-tags"</span> prefix=<span class="string">"s"</span> %&gt;</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE HTML PUBLIC <span class="string">"-//W3C//DTD HTML 4.01 Transitional//EN"</span>&gt;</span><br><span class="line">&lt;html&gt;</span><br><span class="line">  &lt;head&gt;</span><br><span class="line">    &lt;base href=<span class="string">"&lt;%=basePath%&gt;"</span>&gt;</span><br><span class="line">    </span><br><span class="line">    &lt;title&gt;My JSP 'register2.jsp' starting page&lt;/title&gt;</span><br><span class="line">    </span><br><span class="line">&lt;meta http-equiv=<span class="string">"pragma"</span> content=<span class="string">"no-cache"</span>&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"cache-control"</span> content=<span class="string">"no-cache"</span>&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"expires"</span> content=<span class="string">"0"</span>&gt;    </span><br><span class="line">&lt;meta http-equiv=<span class="string">"keywords"</span> content=<span class="string">"keyword1,keyword2,keyword3"</span>&gt;</span><br><span class="line">&lt;meta http-equiv=<span class="string">"description"</span> content=<span class="string">"This is my page"</span>&gt;</span><br><span class="line">&lt;!--</span><br><span class="line">&lt;link rel=<span class="string">"stylesheet"</span> type=<span class="string">"text/css"</span> href=<span class="string">"styles.css"</span>&gt;</span><br><span class="line">--&gt;</span><br><span class="line"></span><br><span class="line">  &lt;/head&gt;</span><br><span class="line">  </span><br><span class="line">  &lt;body&gt;</span><br><span class="line">  &lt;!-- struts 表单的特点</span><br><span class="line">  <span class="number">1</span>.action 不需要写项目名</span><br><span class="line">  <span class="number">2</span>.会给表单里面的内容放在 table 中，并加上样式</span><br><span class="line">  <span class="number">3</span>.struts 标签必须有 name 属性</span><br><span class="line">   --&gt;</span><br><span class="line">    This is my JSP page. &lt;br&gt;</span><br><span class="line">    &lt;s:form action=<span class="string">"/login/register.action"</span>&gt;</span><br><span class="line">    &lt;s:textfield name="username" label="用户名"&gt;&lt;/s:textfield&gt;</span><br><span class="line">    &lt;s:textfield name="password" label="密码"&gt;&lt;/s:textfield&gt;</span><br><span class="line">    &lt;s:textfield name="birthday" label="生日"&gt;&lt;/s:textfield&gt;</span><br><span class="line">&lt;!-- list 使用 OGNL 表达式 --&gt;</span><br><span class="line">    &lt;s:checkboxlist list="#&#123;'coding':'写代码','basketball':'打篮球','soccer':'踢足球'&#125;" label="爱好" name="hobby"&gt;&lt;/s:checkboxlist&gt;</span><br><span class="line">    &lt;s:radio list="#&#123;'true':'已婚','false':'未婚'&#125;" label="是否已婚" name="married"&gt;&lt;/s:radio&gt;</span><br><span class="line">    &lt;s:submit value="注册" name="zc"&gt;&lt;/s:submit&gt;</span><br><span class="line">    &lt;/s:form&gt;</span><br><span class="line">  &lt;hr&gt;</span><br><span class="line">  &lt;/body&gt;</span><br><span class="line">&lt;/html&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Struts的错误回显以及struts标签&quot;&gt;&lt;a href=&quot;#Struts的错误回显以及struts标签&quot; class=&quot;headerlink&quot; title=&quot;Struts的错误回显以及struts标签&quot;&gt;&lt;/a&gt;Struts的错误回显以及struts标签&lt;/h1&gt;&lt;p&gt;​        本次记录一下 Struts 的错误回显以及 struts 框架前端标签的简单用法&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaEE——Struts2框架" scheme="http://yoursite.com/tags/JavaEE%E2%80%94%E2%80%94Struts2%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Struts2框架——struts.xml文件配置及Action接受参数的方式</title>
    <link href="http://yoursite.com/2019/11/02/Struts2%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94struts-xml%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E5%8F%8AAction%E6%8E%A5%E5%8F%97%E5%8F%82%E6%95%B0%E7%9A%84%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2019/11/02/Struts2框架——struts-xml文件配置及Action接受参数的方式/</id>
    <published>2019-11-02T02:28:05.000Z</published>
    <updated>2019-11-02T03:39:31.813Z</updated>
    
    <content type="html"><![CDATA[<h1 id="struts-xml-文件配置及-Action-接受参数的方式"><a href="#struts-xml-文件配置及-Action-接受参数的方式" class="headerlink" title="struts.xml 文件配置及 Action 接受参数的方式"></a>struts.xml 文件配置及 Action 接受参数的方式</h1><p>​        本次记录一下 struts.xml 文件在多种模块下的配置方法以及 Action 在接受 view 种参数的方式</p><a id="more"></a><h2 id="struts-xml-配置"><a href="#struts-xml-配置" class="headerlink" title="struts.xml 配置"></a>struts.xml 配置</h2><p>​        在有需要多种模块配置要求下的 struts.xml 文件有两种配置方法</p><h3 id="多模块配置-struts-xml"><a href="#多模块配置-struts-xml" class="headerlink" title="多模块配置 struts.xml"></a>多模块配置 struts.xml</h3><p>​        使用 <package> 标签中的 namespace 属性，来对不同的模块进行分类</package></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 用户模块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">name</span>=<span class="string">"/user"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"addUser"</span> <span class="attr">class</span>=<span class="string">"com.lmh.web.action.UserAction"</span> <span class="attr">method</span>=<span class="string">"addUser"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/login.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 角色模块 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"role"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">name</span>=<span class="string">"/role"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"addRole"</span> <span class="attr">class</span>=<span class="string">"com.lmh.web.action.RoleAction"</span> <span class="attr">method</span>=<span class="string">"addRole"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/login.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="多文件配置-struts-xml"><a href="#多文件配置-struts-xml" class="headerlink" title="多文件配置 struts.xml"></a>多文件配置 struts.xml</h3><p>​        使用多个 struts.xml 文件进行配置，在主 struts.xml 文件中添加 <include> 标签来进行引用</include></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"struts-order.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">include</span> <span class="attr">name</span>=<span class="string">"struts-user.xml"</span>&gt;</span><span class="tag">&lt;/<span class="name">include</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="Action-接受-View-种值的几种方式"><a href="#Action-接受-View-种值的几种方式" class="headerlink" title="Action 接受 View 种值的几种方式"></a>Action 接受 View 种值的几种方式</h2><h3 id="通过-Serlvlet-来获取"><a href="#通过-Serlvlet-来获取" class="headerlink" title="通过 Serlvlet 来获取"></a>通过 Serlvlet 来获取</h3><p>register.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"$&#123;pageContext.request.contextPath&#125;/login/register.action"</span>&gt;</span><br><span class="line">    用户名&lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span>&gt;&lt;br&gt;</span><br><span class="line">    密码&lt;input type=<span class="string">"password"</span> name=<span class="string">"password"</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> name=<span class="string">"zc"</span> value=<span class="string">"注册"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>UserAction：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">HttpServletRequest req = ServletActionContext.getRequest();</span><br><span class="line">String username = req.getParameter(<span class="string">"username"</span>);</span><br><span class="line">String password = req.getParameter(<span class="string">"password"</span>);</span><br><span class="line"></span><br><span class="line">System.out.println(username);</span><br><span class="line">System.out.println(password);</span><br></pre></td></tr></table></figure><p>struts.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"user"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">name</span>=<span class="string">"/user"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"register"</span> <span class="attr">class</span>=<span class="string">"com.lmh.web.action.UserAction"</span> <span class="attr">method</span>=<span class="string">"register"</span>&gt;</span><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="通过-Action-的属性的-set-方法注入"><a href="#通过-Action-的属性的-set-方法注入" class="headerlink" title="通过 Action 的属性的 set 方法注入"></a>通过 Action 的属性的 set 方法注入</h3><p>​        struts 会通过表单字段的名称，调用 set 方法，比如 username 字段会调用 setUsername</p><p>UserAction：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"set username"</span>);</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"set password"</span>);</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="通过-Action-的属性的-set-模型的形式注入"><a href="#通过-Action-的属性的-set-模型的形式注入" class="headerlink" title="通过 Action 的属性的 set 模型的形式注入"></a>通过 Action 的属性的 set 模型的形式注入</h3><p>User：（模型，提供属性的  get/set 方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.web.model;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> String username;</span><br><span class="line"><span class="keyword">private</span> String password;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getUsername</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUsername</span><span class="params">(String username)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.username = username;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> password;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.password = password;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="string">"User [username="</span> + username + <span class="string">", password="</span> + password + <span class="string">"]"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>UserAction：（把参数封装到一个 User 模型中，在 Action 中提供模型的 get/set 方法）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> User user;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getUser</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"get user"</span>);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setUser</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">    System.out.println(<span class="string">"set user"</span>);</span><br><span class="line">    <span class="keyword">this</span>.user = user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>register.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"$&#123;pageContext.request.contextPath&#125;/login/register.action"</span>&gt;</span><br><span class="line">    用户名&lt;input type=<span class="string">"text"</span> name=<span class="string">"user.username"</span>&gt;&lt;br&gt;</span><br><span class="line">    密码&lt;input type=<span class="string">"password"</span> name=<span class="string">"user.password"</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> name=<span class="string">"zc"</span> value=<span class="string">"注册"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><h3 id="通过-Action-模型驱动封装参数"><a href="#通过-Action-模型驱动封装参数" class="headerlink" title="通过 Action 模型驱动封装参数"></a>通过 Action 模型驱动封装参数</h3><p>register.jsp：</p><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;form action=<span class="string">"$&#123;pageContext.request.contextPath&#125;/login/register.action"</span>&gt;</span><br><span class="line">    用户名&lt;input type=<span class="string">"text"</span> name=<span class="string">"username"</span>&gt;&lt;br&gt;</span><br><span class="line">    密码&lt;input type=<span class="string">"password"</span> name=<span class="string">"password"</span>&gt;&lt;br&gt;</span><br><span class="line">    &lt;input type=<span class="string">"submit"</span> name=<span class="string">"zc"</span> value=<span class="string">"注册"</span>&gt;</span><br><span class="line">&lt;/form&gt;</span><br></pre></td></tr></table></figure><p>UserAction：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.lmh.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.lmh.model.User;</span><br><span class="line"><span class="keyword">import</span> com.lmh.service.IUserService;</span><br><span class="line"><span class="keyword">import</span> com.lmh.service.impl.UserServiceImpl;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ModelDriven;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserAction</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> <span class="keyword">implements</span> <span class="title">ModelDriven</span>&lt;<span class="title">User</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span> User user = <span class="keyword">new</span> User();</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">getModel</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line"><span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">register</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> NONE;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="参数注入原理"><a href="#参数注入原理" class="headerlink" title="参数注入原理"></a>参数注入原理</h3><p>​        参数会自动注入是因为 struts-default.xml 中有两个拦截器在工作</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">"params"</span> <span class="attr">class</span>=<span class="string">"com.opensymphony.xwork2.interceptor.ParametersInterceptor"</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">interceptor</span> <span class="attr">name</span>=<span class="string">"modelDriven"</span> <span class="attr">class</span>=<span class="string">"com.opensymphony.xwork2.interceptor.ModelDrivenInterceptor"</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>​    1.struts 的默认拦截器是由 defaultStack 决定的</p><p>​    2.如果在 package 中不写拦截器，就是 struts-default 中的defaultStack 的拦截器在工作</p><p>​    3.一旦在 package 中写了拦截器，struts-default 中的 defaultStack 的任何拦截器就都不工作了</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;struts-xml-文件配置及-Action-接受参数的方式&quot;&gt;&lt;a href=&quot;#struts-xml-文件配置及-Action-接受参数的方式&quot; class=&quot;headerlink&quot; title=&quot;struts.xml 文件配置及 Action 接受参数的方式&quot;&gt;&lt;/a&gt;struts.xml 文件配置及 Action 接受参数的方式&lt;/h1&gt;&lt;p&gt;​        本次记录一下 struts.xml 文件在多种模块下的配置方法以及 Action 在接受 view 种参数的方式&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaEE——Struts2框架" scheme="http://yoursite.com/tags/JavaEE%E2%80%94%E2%80%94Struts2%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Struts2框架——struts.xml文件详解</title>
    <link href="http://yoursite.com/2019/10/27/Struts2%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94struts-xml%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2019/10/27/Struts2框架——struts-xml文件详解/</id>
    <published>2019-10-27T01:16:04.000Z</published>
    <updated>2019-10-27T03:47:08.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="struts-xml-文件"><a href="#struts-xml-文件" class="headerlink" title="struts.xml 文件"></a>struts.xml 文件</h1><p>​        struts.xml 是 Struts2 最核心最常用的配置文件，下面详细介绍一下 struts.xml 中的元素和配置</p><a id="more"></a><h2 id="package-元素"><a href="#package-元素" class="headerlink" title="package 元素"></a>package 元素</h2><p>​        struts2 的配置文件中引入了面向对象的思想，使用了分包管理。易于管理动作类，便于模块化开发动作类</p><h3 id="package-元素的属性"><a href="#package-元素的属性" class="headerlink" title="package 元素的属性"></a>package 元素的属性</h3><p>​        name：包的名称，必须写，并且名称唯一</p><p>​        extends：继承自哪个基础包，通常继承 struts-default 包</p><p>​                          struts-default.xml 中定义着 struts-default 包</p><p>​                          struts-default.xml 是在 struts.xml 之前加载的</p><p>​        abstract：把包声明为抽象包，抽象包就是用来被继承的</p><p>​                          只要没有 <action> 元素的包，就可以声明为抽象包</action></p><p>​        namespace：命名空间。【访问路径 = 命名空间 + 动作名称】</p><h4 id="namespace-详解"><a href="#namespace-详解" class="headerlink" title="namespace 详解"></a>namespace 详解</h4><p>​        namespace 的默认取值是一个“”，不需要写 /</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"p2"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">namespace</span>=<span class="string">"/user"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"add"</span> <span class="attr">class</span>=<span class="string">"com.web.action.UserAction"</span> <span class="attr">method</span>=<span class="string">"add"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/add.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"delete"</span> <span class="attr">class</span>=<span class="string">"com.web.action.UserAction"</span> <span class="attr">method</span>=<span class="string">"delete"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/delete.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"update"</span> <span class="attr">class</span>=<span class="string">"com.web.action.UserAction"</span> <span class="attr">method</span>=<span class="string">"update"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/update.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"find"</span> <span class="attr">class</span>=<span class="string">"com.web.action.UserAction"</span> <span class="attr">method</span>=<span class="string">"find"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/find.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        如果有两层命名空间，查找规则是从后向前查找</p><h2 id="action-元素"><a href="#action-元素" class="headerlink" title="action 元素"></a>action 元素</h2><p>​        配置动作，处理请求路径</p><h3 id="action-元素的属性"><a href="#action-元素的属性" class="headerlink" title="action 元素的属性"></a>action 元素的属性</h3><p>​        name：动作名称，同一个命名空间下要求名称唯一</p><p>​        class：动作类全路径名</p><p>​        method：动作类中的方法名，默认是 public String execute()</p><p>​            方法的要求：</p><p>​                1.public 的</p><p>​                2.返回值必须是 String</p><p>​                3.没有参数</p><h3 id="动作类-Action-的写法"><a href="#动作类-Action-的写法" class="headerlink" title="动作类 Action 的写法"></a>动作类 Action 的写法</h3><p>####动作类的第一种写法</p><p>​        直接写一个 Action 类，不需要继承任何类，然后在 struts.xml 中配置</p><p>Action 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.web.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloAction</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Success"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>struts.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"p1"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">namespace</span>=<span class="string">"/a"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"hello"</span> <span class="attr">class</span>=<span class="string">"com.web.action.HelloAction"</span> <span class="attr">method</span>=<span class="string">"sayHello"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>####动作类的第二种写法</p><p>​        写一个实现 Action 接口的动作类，然后实现 execute 方法</p><p>Action 类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.web.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.Action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">demoAction</span> <span class="keyword">implements</span> <span class="title">Action</span> </span>&#123;</span><br><span class="line">    <span class="meta">@override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">execute</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>struts.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"p1"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">namespace</span>=<span class="string">"/a"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"demo"</span> <span class="attr">class</span>=<span class="string">"com.web.action.demoAction"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​        Action 接口中有一些静态常量：SUCCESS，NONE，ERROR，INPUT，LOGIN，可以直接在返回值中使用</p><h4 id="动作类的第三种写法（推荐）"><a href="#动作类的第三种写法（推荐）" class="headerlink" title="动作类的第三种写法（推荐）"></a>动作类的第三种写法（推荐）</h4><p>​        写一个继承 ActionSupport 类的 Action 类</p><p>​        ActionSupport 是实现 Action 接口定的类</p><p>Action：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.web.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> com.opensymphony.xwork2.ActionSupport;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginAction3</span> <span class="keyword">extends</span> <span class="title">ActionSupport</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">login</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> SUCCESS;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>struts.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"p1"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">namespace</span>=<span class="string">"/a"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"login3"</span> <span class="attr">class</span>=<span class="string">"com.web.action.LoginAction3"</span> <span class="attr">method</span>=<span class="string">"login"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="默认动作类"><a href="#默认动作类" class="headerlink" title="默认动作类"></a>默认动作类</h4><p>​        struts-default.xml 中定义了默认动作类和方法</p><p>​        默认的动作类就是 com.opensymphony.xwork2.ActionSupport 这个类</p><p>struts.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">default-class-ref</span> <span class="attr">class</span>=<span class="string">"com.web.action.HelloAction"</span>&gt;</span><span class="tag">&lt;/<span class="name">default-class-ref</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"hello"</span> <span class="attr">class</span>=<span class="string">"com.web.action.HelloAction"</span> <span class="attr">method</span>=<span class="string">"sayHello"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 没有配置 method 的 action，默认访问 execute 方法 --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="result-元素"><a href="#result-元素" class="headerlink" title="result 元素"></a>result 元素</h2><p>​        为动作指定结果试图</p><h3 id="result-元素的属性"><a href="#result-元素的属性" class="headerlink" title="result 元素的属性"></a>result 元素的属性</h3><p>​        name：逻辑视图的名称，对应着动作方法的返回值，默认值是 success</p><p>​        type：结果类型，指的就是用什么方式转到定义的页面，默认是 dispather 转发</p><p>​            dispatcher：使用请求转发，转向一个页面</p><p>​            redirect：使用重定向，转向一个页面</p><p>​            chain：转发到另一个相同或不同命名空间的动作</p><p>​            redirectAction：重定向到相同或不同命名空间的动作</p><h4 id="result-元素中的-param-子元素"><a href="#result-元素中的-param-子元素" class="headerlink" title="result 元素中的 param 子元素"></a>result 元素中的 param 子元素</h4><p>​        在转发或者重定向到不同包下的动作时，都要用到 result 元素的子元素 param</p><p>​        param 元素的作用：依赖注入</p><p>​        通过 struts-default.xml 中的 resultTypes 元素中配置可以看出，每个结果试图都是靠一个类来实现的</p><p>​        param 元素就是将配置参数注入到该类中</p><p>​        调用的事i对应类的 setter 方法进行注入</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span>=<span class="string">"p5"</span> <span class="attr">extends</span>=<span class="string">"struts-default"</span> <span class="attr">namespace</span>=<span class="string">"/demo"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"action1"</span> <span class="attr">class</span>=<span class="string">"com.web.action.Demo1Action"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- result 的 name 可以不写 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 转发到同一个包下的 action --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"action3"</span> <span class="attr">class</span>=<span class="string">"com.web.action.ChainAction1"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span> <span class="attr">type</span>=<span class="string">"chain"</span>&gt;</span>action1<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"action4"</span> <span class="attr">class</span>=<span class="string">"com.web.action.ChainAction1"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span> <span class="attr">type</span>=<span class="string">"redirectAction"</span>&gt;</span>action1<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"action5"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span> <span class="attr">type</span>=<span class="string">"chain"</span>&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- 依赖注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"namespace"</span>&gt;</span>/a<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"actionName"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">param</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span>=<span class="string">"action6"</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span>=<span class="string">"success"</span> <span class="attr">type</span>=<span class="string">"redirectAction"</span>&gt;</span></span><br><span class="line"> <span class="comment">&lt;!-- 依赖注入 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"namespace"</span>&gt;</span>/a<span class="tag">&lt;/<span class="name">param</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">param</span> <span class="attr">name</span>=<span class="string">"actionName"</span>&gt;</span>hello<span class="tag">&lt;/<span class="name">param</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">result</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;struts-xml-文件&quot;&gt;&lt;a href=&quot;#struts-xml-文件&quot; class=&quot;headerlink&quot; title=&quot;struts.xml 文件&quot;&gt;&lt;/a&gt;struts.xml 文件&lt;/h1&gt;&lt;p&gt;​        struts.xml 是 Struts2 最核心最常用的配置文件，下面详细介绍一下 struts.xml 中的元素和配置&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaEE——Struts2框架" scheme="http://yoursite.com/tags/JavaEE%E2%80%94%E2%80%94Struts2%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>Struts2框架—— MyEclipse搭建项目以及运行流程（一）</title>
    <link href="http://yoursite.com/2019/10/18/Struts2%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%20MyEclipse%E6%90%AD%E5%BB%BA%E9%A1%B9%E7%9B%AE%E4%BB%A5%E5%8F%8A%E8%BF%90%E8%A1%8C%E6%B5%81%E7%A8%8B%EF%BC%88%E4%B8%80%EF%BC%89/"/>
    <id>http://yoursite.com/2019/10/18/Struts2框架—— MyEclipse搭建项目以及运行流程（一）/</id>
    <published>2019-10-18T02:16:33.000Z</published>
    <updated>2019-10-18T09:29:14.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Struts-框架"><a href="#Struts-框架" class="headerlink" title="Struts 框架"></a>Struts 框架</h1><p>​        Struts2 框架是 Apache 发行的 MVC 开源框架，是表现层 web 框架</p><a id="more"></a><h2 id="Struts-文件包"><a href="#Struts-文件包" class="headerlink" title="Struts 文件包"></a>Struts 文件包</h2><blockquote><p>apps</p><p>docs</p><p>lib</p><p>src</p></blockquote><p>apps：官方提供的 Demo</p><p>docs：官方提供的文档</p><p>lib：官方提供的 jar 包，需要用到哪个才导入哪个</p><p>src：源码</p><h2 id="使用-MyEclipse2017-配置-Struts2-项目"><a href="#使用-MyEclipse2017-配置-Struts2-项目" class="headerlink" title="使用 MyEclipse2017 配置 Struts2 项目"></a>使用 MyEclipse2017 配置 Struts2 项目</h2><ol><li><p>创建 Web Project（配置 tomcat 服务器）</p></li><li><p>将 Struts2 lib 目录下的 jar 包复制到项目中</p></li><li><p>创建 struts.xml 文件在项目中 src 目录下</p></li><li><p>配置 struts 过滤器（配置 web.xml）</p></li><li><p>运行</p></li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">web-app</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span> <span class="attr">xmlns</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee"</span> <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_3_1.xsd"</span> <span class="attr">id</span>=<span class="string">"WebApp_ID"</span> <span class="attr">version</span>=<span class="string">"3.1"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">display-name</span>&gt;</span>lmhStruts2<span class="tag">&lt;/<span class="name">display-name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-class</span>&gt;</span>org.apache.struts2.dispatcher.ng.filter.StrutsPrepareAndExecuteFilter<span class="tag">&lt;/<span class="name">filter-class</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">filter-name</span>&gt;</span>struts2<span class="tag">&lt;/<span class="name">filter-name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url-pattern</span>&gt;</span>/*<span class="tag">&lt;/<span class="name">url-pattern</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">filter-mapping</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">web-app</span>&gt;</span></span><br></pre></td></tr></table></figure><p>（web.xml 文件配置）</p><h2 id="配置-struts-xml-文件及-Action"><a href="#配置-struts-xml-文件及-Action" class="headerlink" title="配置 struts.xml 文件及 Action"></a>配置 struts.xml 文件及 Action</h2><h3 id="struts-xml-文件"><a href="#struts-xml-文件" class="headerlink" title="struts.xml 文件"></a>struts.xml 文件</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8" ?&gt;</span></span><br><span class="line"><span class="meta">&lt;!DOCTYPE struts PUBLIC</span></span><br><span class="line"><span class="meta">"-//Apache Software Foundation//DTD Struts Configuration 2.3//EN"</span></span><br><span class="line"><span class="meta">"http://struts.apache.org/dtds/struts-2.3.dtd"&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">struts</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">package</span> <span class="attr">name</span> = <span class="string">"p1"</span> <span class="attr">extends</span> = <span class="string">"struts-default"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">action</span> <span class="attr">name</span> = <span class="string">"hello"</span> <span class="attr">class</span> = <span class="string">"com.web.action.HelloAction"</span> <span class="attr">method</span> = <span class="string">"sayHello"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">result</span> <span class="attr">name</span> = <span class="string">"success"</span>&gt;</span>/success.jsp<span class="tag">&lt;/<span class="name">result</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">action</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">package</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">struts</span>&gt;</span></span><br></pre></td></tr></table></figure><p>​    package：表示包<br>​        name：包名，struts.xml 文件中不能有相同的包名，包名是唯一的<br>​        extends：继承，默认 struts-default<br>​    action：动作<br>​        name：相当于 Servlet 的映射路径<br>​        class：处理请求的类，相当于 Servlet<br>​        method：处理请求的方法<br>​    result：结果，返回的 jsp 页面</p><h3 id="Action-编写"><a href="#Action-编写" class="headerlink" title="Action 编写"></a>Action 编写</h3><p>​        在 src 中创建包并创建 Action 类，并创建准备使用的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.web.action;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">sayHello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">System.out.println(<span class="string">"Success"</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="string">"success"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        根据类名和方法名在 struts.xml 中配好相应的名字，配置完成后启动 tomcat 服务即可访问</p><h2 id="Struts2-执行流程"><a href="#Struts2-执行流程" class="headerlink" title="Struts2 执行流程"></a>Struts2 执行流程</h2><ol><li>tomcat 启动服务，加载 web.xml</li><li>web.xml 实例化并初始化过滤器</li><li>加载 struts.xml</li><li>客户端发送请求</li><li>请求到达过滤器</li><li>截取请求 Action 名称，在 struts.xml 中寻找 Action</li><li>找到 Action 后实例化对应的动作类</li><li>调用对应的方法，获取返回值</li><li>根据返回值，找到 name 取值对应的结果视图</li><li>找到 web 页面</li><li>响应浏览器，展示结果</li></ol><h2 id="Struts2-文件加载顺序"><a href="#Struts2-文件加载顺序" class="headerlink" title="Struts2 文件加载顺序"></a>Struts2 文件加载顺序</h2><ol><li>default.properties  //不可修改</li><li>struts-default.xml  //不可修改</li><li>struts-plugin.xml  //不可修改</li><li>struts.xml  //可以修改（推荐）</li><li>struts.properties  //可以修改</li><li>web.xml  //可以修改，可以给过滤器配置参数</li></ol><p>注：如果不同的文件中对相同的属性给予不同的属性值，最终结果会以后加载的文件为准，因为后加载的文件会更新之前加载的属性配置</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Struts-框架&quot;&gt;&lt;a href=&quot;#Struts-框架&quot; class=&quot;headerlink&quot; title=&quot;Struts 框架&quot;&gt;&lt;/a&gt;Struts 框架&lt;/h1&gt;&lt;p&gt;​        Struts2 框架是 Apache 发行的 MVC 开源框架，是表现层 web 框架&lt;/p&gt;
    
    </summary>
    
    
      <category term="JavaEE——Struts2框架" scheme="http://yoursite.com/tags/JavaEE%E2%80%94%E2%80%94Struts2%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
  <entry>
    <title>JavaEE——网络留言板（未完）</title>
    <link href="http://yoursite.com/2019/09/16/JavaEE%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E7%95%99%E8%A8%80%E6%9D%BF%EF%BC%88%E6%9C%AA%E5%AE%8C%EF%BC%89/"/>
    <id>http://yoursite.com/2019/09/16/JavaEE——网络留言板（未完）/</id>
    <published>2019-09-16T14:22:06.000Z</published>
    <updated>2019-10-18T03:12:26.607Z</updated>
    
    <content type="html"><![CDATA[<h1 id="初学-JavaEE"><a href="#初学-JavaEE" class="headerlink" title="初学 JavaEE"></a>初学 JavaEE</h1><p>​        之前学过一点点 Servlet，现在学校开了 JavaEE，正好复习了一下之前的知识</p><h2 id="什么是-JavaEE"><a href="#什么是-JavaEE" class="headerlink" title="什么是 JavaEE"></a>什么是 JavaEE</h2><p>​        JavaEE 可以理解为一套使用 java 为主体的、课跨平台的、快速设计并进行企业级 Web 应用开发的标准</p><p>​        JavaEE 开发应用程序有两种主要方式——JavaWeb 开发和 Java 框架开发</p><a id="more"></a><h3 id="Java-Web-开发"><a href="#Java-Web-开发" class="headerlink" title="Java Web 开发"></a>Java Web 开发</h3><p>​        这是传统的开发方式，核心技术是 JSP、Servlet、JavaBean。这种开发模式的缺点是：没有一套有效的开发规范来约束 JSP 程序员，整个应用系统结构不清晰，项目规模越大越难维护</p><p>###Java 框架开发</p><p>​        在开发中使用现成的的框架可减少代码量、大大降低编程难度，同时也使开发出来的应用系统结构清晰、易于维护</p><h2 id="JavaEE-初体验——留言板"><a href="#JavaEE-初体验——留言板" class="headerlink" title="JavaEE 初体验——留言板"></a>JavaEE 初体验——留言板</h2><p>​        采用 Java Web 开发，使用 JSP + Servlet + JavaBean 完成</p><h3 id="MVC-模式"><a href="#MVC-模式" class="headerlink" title="MVC 模式"></a>MVC 模式</h3><p>​        MVC 模式中，应用程序被划分成：模型层（Model）、视图层（View）、控制层（Controller）三部分，MVC 模型就是把一个应用程序的开发按照业务逻辑、数据、视图进行分离分层并组织代码，在这种模式下，Servlet 负责处理用户请求，JSP 负责显示数据和界面、JavaBean 负责封装数据</p><p>​        在这种架构模式下，模型层（Model）定义了数据模型和业务逻辑，为了将数据访问与业务逻辑分离，模型层又具体划分为 DAO 层和业务层，DAO 即 Data Access Object，主要作用是把数据封装起来变成 JavaBean；业务层是整个系统的核心，几乎所有的数据处理、获取到的原始数据都在这一层发生</p><h3 id="项目目录结构"><a href="#项目目录结构" class="headerlink" title="项目目录结构"></a>项目目录结构</h3><blockquote><p>Project</p><blockquote><p>.idea</p><p>out</p><p>src</p><blockquote><p>JDBC</p><blockquote><p>jdbcConn.java</p></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>MainServlet</p><blockquote><p>LybServlet</p><p>ServletTest01</p><p>ZcServlet</p></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>UserDao</p><blockquote><p>UserDao</p></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>Users</p><blockquote><p>Users</p></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><p>web</p><blockquote><p>WEB-INF</p><blockquote><p>lib</p><blockquote><p>mysql-connector-java-8.0.16.jar</p></blockquote></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><blockquote><p>web.xml</p></blockquote></blockquote></blockquote></blockquote><blockquote><blockquote><blockquote><p>index.jsp</p><p>LYB.jsp</p><p>MAIN.jsp</p><p>ZC.jsp</p></blockquote></blockquote></blockquote><blockquote><blockquote><p>FirstServlet.iml</p></blockquote></blockquote><h3 id="项目介绍"><a href="#项目介绍" class="headerlink" title="项目介绍"></a>项目介绍</h3><p>​        JDBC 类中为 mysql JDBC 驱动，所有需要连接数据库的代码都从此处获得连接</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> JDBC;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.Connection;</span><br><span class="line"><span class="keyword">import</span> java.sql.DriverManager;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConn</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String JDBC_DRIVER = <span class="string">"com.mysql.cj.jdbc.Driver"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String DB_URL = <span class="string">"jdbc:mysql://localhost:3306/servletdemo?serverTimezone=UTC"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 数据库的用户名与密码，需要根据自己的设置</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String USER = <span class="string">"root"</span>;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">final</span> String PASS = <span class="string">"lmh12358"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Connection <span class="title">GetConn</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        Connection conn;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            System.out.println(<span class="string">"开始尝试连接数据库"</span>);</span><br><span class="line">            Class.forName(JDBC_DRIVER);</span><br><span class="line">            System.out.println(<span class="string">"注册驱动成功"</span>);</span><br><span class="line">            conn = DriverManager.getConnection(DB_URL, USER, PASS);</span><br><span class="line">            System.out.println(<span class="string">"连接数据库成功"</span>);</span><br><span class="line">            <span class="keyword">return</span> conn;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        MainServlet 包下为所有用到的 Servlet，在这些 Servlet 负责控制调度后台 DAO 层的方法</p><p>​        ServletTest01 负责控制登陆界面，调用 UserDao 中的 check 方法来检验用户名密码是否匹配</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> MainServlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.sql.rowset.serial.SerialException;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.io.PrintWriter;</span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"><span class="keyword">import</span> Users.Users;</span><br><span class="line"><span class="keyword">import</span> UserDao.UserDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ServletTest01</span> <span class="keyword">extends</span> <span class="title">javax</span>.<span class="title">servlet</span>.<span class="title">http</span>.<span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String message = <span class="string">"hello this is Servlet"</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response)</span> <span class="keyword">throws</span> javax.servlet.ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response)</span> <span class="keyword">throws</span> javax.servlet.ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">        String index01 = request.getParameter(<span class="string">"dl"</span>);</span><br><span class="line">        String index02 = request.getParameter(<span class="string">"zc"</span>);</span><br><span class="line">        String username=request.getParameter(<span class="string">"name"</span>);</span><br><span class="line">        String password=request.getParameter(<span class="string">"password"</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index02 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            Users u = <span class="keyword">new</span> Users();</span><br><span class="line">            u.setName(username);</span><br><span class="line">            u.setPassword(password);</span><br><span class="line">            UserDao us = <span class="keyword">new</span> UserDao();</span><br><span class="line">            <span class="keyword">boolean</span> t = us.check(u);</span><br><span class="line">            <span class="keyword">if</span>(t == <span class="keyword">true</span>)&#123;</span><br><span class="line">                System.out.println(<span class="string">"检验成功"</span>);</span><br><span class="line">                response.sendRedirect(<span class="string">"MAIN.jsp"</span>);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"失败"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (index01 == <span class="keyword">null</span>) &#123;</span><br><span class="line">            response.sendRedirect(<span class="string">"ZC.jsp"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        LybServlet 用来控制留言板页面，留言提交功能通过调用 CommitLY 方法来控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> MainServlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> UserDao.UserDao;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(name = <span class="string">"LybServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LybServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String name=request.getParameter(<span class="string">"username"</span>);</span><br><span class="line">        String ly=request.getParameter(<span class="string">"content"</span>);</span><br><span class="line">        UserDao us = <span class="keyword">new</span> UserDao();</span><br><span class="line">        <span class="keyword">boolean</span> t = us.CommitLY(name, ly);</span><br><span class="line">        <span class="keyword">if</span> (t = <span class="keyword">true</span>)&#123;</span><br><span class="line">            System.out.println(<span class="string">"留言成功！"</span>);</span><br><span class="line">            response.sendRedirect(<span class="string">"MAIN.jsp"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"servlet失败！"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        ZcServlet 用来控制注册界面中，提交用户名密码由 ZcUser 方法来控制</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> MainServlet;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> UserDao.UserDao;</span><br><span class="line"><span class="keyword">import</span> Users.Users;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> javax.servlet.ServletException;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.annotation.WebServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServlet;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletRequest;</span><br><span class="line"><span class="keyword">import</span> javax.servlet.http.HttpServletResponse;</span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="meta">@WebServlet</span>(name = <span class="string">"ZcServlet"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZcServlet</span> <span class="keyword">extends</span> <span class="title">HttpServlet</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doPost</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doGet</span><span class="params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="keyword">throws</span> ServletException, IOException </span>&#123;</span><br><span class="line">        String username=request.getParameter(<span class="string">"name"</span>);</span><br><span class="line">        String password=request.getParameter(<span class="string">"password"</span>);</span><br><span class="line">        Users u = <span class="keyword">new</span> Users();</span><br><span class="line">        u.setName(username);</span><br><span class="line">        u.setPassword(password);</span><br><span class="line">        UserDao us = <span class="keyword">new</span> UserDao();</span><br><span class="line">        <span class="keyword">boolean</span> t = us.ZcUser(u);</span><br><span class="line">        <span class="keyword">if</span> (t == <span class="keyword">true</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"注册成功"</span>);</span><br><span class="line">            response.sendRedirect(<span class="string">"index.jsp"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            System.out.println(<span class="string">"注册失败"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        DAO 层定义了 UserDao 类用来定义所有 Servlet 调用的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> UserDao;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.sql.*;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Users.Users;</span><br><span class="line"><span class="keyword">import</span> JDBC.JdbcConn;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserDao</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> JdbcConn NewConn = <span class="keyword">new</span> JdbcConn();</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">check</span><span class="params">(Users user)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection conn = NewConn.GetConn();</span><br><span class="line">            Statement stmt = conn.createStatement();</span><br><span class="line">            String sql = <span class="string">"select name,password from user"</span>;</span><br><span class="line">            ResultSet rs = stmt.executeQuery(sql);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(rs.next())&#123;</span><br><span class="line">                System.out.println(user.getName()+rs.getString(<span class="number">1</span>));</span><br><span class="line">                <span class="keyword">if</span>(user.getName().equals(rs.getString(<span class="number">1</span>)))&#123;</span><br><span class="line">                    System.out.println(<span class="string">"能比较用户名了"</span>);</span><br><span class="line">                    <span class="keyword">if</span>(user.getPassword().equals(rs.getString(<span class="number">2</span>)))&#123;</span><br><span class="line">                        System.out.println(<span class="string">"匹配成功了"</span>);</span><br><span class="line">                        x=<span class="number">1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(x==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">CommitLY</span><span class="params">(String name, String ly)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection conn = NewConn.GetConn();</span><br><span class="line">            String sql = <span class="string">"insert into ly values ('"</span> + name + <span class="string">"' ,'"</span> + ly + <span class="string">"');"</span>;</span><br><span class="line">            PreparedStatement ps;</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            ps.executeUpdate();</span><br><span class="line">            System.out.println(<span class="string">"留言成功"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"留言失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">ZcUser</span><span class="params">(Users u)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Connection conn = NewConn.GetConn();</span><br><span class="line">            String sql = <span class="string">"insert into USER (NAME, PASSWORD) values ('"</span> + u.getName() + <span class="string">"' ,'"</span> + u.getPassword() + <span class="string">"');"</span>;</span><br><span class="line">            PreparedStatement ps;</span><br><span class="line">            ps = conn.prepareStatement(sql);</span><br><span class="line">            ps.executeUpdate();</span><br><span class="line">            System.out.println(<span class="string">"注册成功"</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(<span class="string">"注册失败"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        Model 层定义了 Users 类，把用户信息封装成 JavaBean</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Users;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Users</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String UserName;</span><br><span class="line">    <span class="keyword">private</span> String PassWord;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> UserName;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setName</span><span class="params">(String name)</span> </span>&#123;</span><br><span class="line">        UserName = name;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getPassword</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> PassWord;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setPassword</span><span class="params">(String password)</span> </span>&#123;</span><br><span class="line">        PassWord = password;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;初学-JavaEE&quot;&gt;&lt;a href=&quot;#初学-JavaEE&quot; class=&quot;headerlink&quot; title=&quot;初学 JavaEE&quot;&gt;&lt;/a&gt;初学 JavaEE&lt;/h1&gt;&lt;p&gt;​        之前学过一点点 Servlet，现在学校开了 JavaEE，正好复习了一下之前的知识&lt;/p&gt;
&lt;h2 id=&quot;什么是-JavaEE&quot;&gt;&lt;a href=&quot;#什么是-JavaEE&quot; class=&quot;headerlink&quot; title=&quot;什么是 JavaEE&quot;&gt;&lt;/a&gt;什么是 JavaEE&lt;/h2&gt;&lt;p&gt;​        JavaEE 可以理解为一套使用 java 为主体的、课跨平台的、快速设计并进行企业级 Web 应用开发的标准&lt;/p&gt;
&lt;p&gt;​        JavaEE 开发应用程序有两种主要方式——JavaWeb 开发和 Java 框架开发&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的 javaEE" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84-javaEE/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-1160——拼写单词</title>
    <link href="http://yoursite.com/2019/08/23/LeetCode-1160%E2%80%94%E2%80%94%E6%8B%BC%E5%86%99%E5%8D%95%E8%AF%8D/"/>
    <id>http://yoursite.com/2019/08/23/LeetCode-1160——拼写单词/</id>
    <published>2019-08-23T03:00:40.000Z</published>
    <updated>2019-08-23T03:16:27.243Z</updated>
    
    <content type="html"><![CDATA[<h1 id="拼写单词（简单）"><a href="#拼写单词（简单）" class="headerlink" title="拼写单词（简单）"></a>拼写单词（简单）</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。</p><p>假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。</p><p>​    注意：每次拼写时，chars 中的每个字母都只能用一次。</p><p>​                返回词汇表 words 中你掌握的所有单词的 长度之和。</p><p>​    示例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">输入：words = [&quot;cat&quot;,&quot;bt&quot;,&quot;hat&quot;,&quot;tree&quot;], chars = &quot;atach&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释： </span><br><span class="line">可以形成字符串 &quot;cat&quot; 和 &quot;hat&quot;，所以答案是 3 + 3 = 6。</span><br><span class="line"></span><br><span class="line">输入：words = [&quot;hello&quot;,&quot;world&quot;,&quot;leetcode&quot;], chars = &quot;welldonehoneyr&quot;</span><br><span class="line">输出：10</span><br><span class="line">解释：</span><br><span class="line">可以形成字符串 &quot;hello&quot; 和 &quot;world&quot;，所以答案是 5 + 5 = 10。</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="通过数组计数"><a href="#通过数组计数" class="headerlink" title="通过数组计数"></a>通过数组计数</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​        通过记录每个字符出现的次数，在遍历两个字符串后即可确定结果</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">countCharacters</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;&amp; words, <span class="built_in">string</span> chars)</span> </span>&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a(<span class="number">26</span>, <span class="number">0</span>);</span><br><span class="line">            <span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; chars.length(); i++)</span><br><span class="line">                a[chars[i] - <span class="string">'a'</span>]++;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; words.size(); i++) &#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a1 = a;</span><br><span class="line">                <span class="keyword">int</span> j;</span><br><span class="line">                <span class="keyword">for</span> (j = <span class="number">0</span>; j &lt; words[i].length(); j++) &#123;</span><br><span class="line">                    a1[words[i][j] - <span class="string">'a'</span>]--;</span><br><span class="line">                    <span class="keyword">if</span> (a1[words[i][j] - <span class="string">'a'</span>] == <span class="number">-1</span>)</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                <span class="keyword">if</span>(j==words[i].length())ans+=words[i].length();</span><br><span class="line">                &#125;</span><br><span class="line">            <span class="keyword">return</span> ans;</span><br><span class="line">        &#125;       </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h3><p>​        先遍历一遍字母表字符串，用长度为 26 的数组来记录每个字母出现的次数，再通过遍历单词表中的每一个字母，出现一次就在数组中的数量上 -1，如果数量出现 -1，就不能组成这个单词，否则就可以继续寻找下去，最后返回结果</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;拼写单词（简单）&quot;&gt;&lt;a href=&quot;#拼写单词（简单）&quot; class=&quot;headerlink&quot; title=&quot;拼写单词（简单）&quot;&gt;&lt;/a&gt;拼写单词（简单）&lt;/h1&gt;&lt;h2 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h2&gt;&lt;p&gt;给你一份『词汇表』（字符串数组） words 和一张『字母表』（字符串） chars。&lt;/p&gt;
&lt;p&gt;假如你可以用 chars 中的『字母』（字符）拼写出 words 中的某个『单词』（字符串），那么我们就认为你掌握了这个单词。&lt;/p&gt;
&lt;p&gt;​    注意：每次拼写时，chars 中的每个字母都只能用一次。&lt;/p&gt;
&lt;p&gt;​                返回词汇表 words 中你掌握的所有单词的 长度之和。&lt;/p&gt;
&lt;p&gt;​    示例&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：words = [&amp;quot;cat&amp;quot;,&amp;quot;bt&amp;quot;,&amp;quot;hat&amp;quot;,&amp;quot;tree&amp;quot;], chars = &amp;quot;atach&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释： &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可以形成字符串 &amp;quot;cat&amp;quot; 和 &amp;quot;hat&amp;quot;，所以答案是 3 + 3 = 6。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：words = [&amp;quot;hello&amp;quot;,&amp;quot;world&amp;quot;,&amp;quot;leetcode&amp;quot;], chars = &amp;quot;welldonehoneyr&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;可以形成字符串 &amp;quot;hello&amp;quot; 和 &amp;quot;world&amp;quot;，所以答案是 5 + 5 = 10。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="李明徽的 LeetCode" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84-LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-125——验证回文串</title>
    <link href="http://yoursite.com/2019/08/23/LeetCode-125%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81%E5%9B%9E%E6%96%87%E4%B8%B2/"/>
    <id>http://yoursite.com/2019/08/23/LeetCode-125——验证回文串/</id>
    <published>2019-08-23T01:27:05.000Z</published>
    <updated>2019-08-23T02:04:16.820Z</updated>
    
    <content type="html"><![CDATA[<h1 id="验证回文串（简单）"><a href="#验证回文串（简单）" class="headerlink" title="验证回文串（简单）"></a>验证回文串（简单）</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。</p><p>​    说明：本题中，我们将空字符串定义为有效的回文串。</p><p>​    示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;A man, a plan, a canal: Panama&quot;</span><br><span class="line">输出: true</span><br><span class="line">输入: &quot;race a car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="C-双指针法解决"><a href="#C-双指针法解决" class="headerlink" title="C++双指针法解决"></a>C++双指针法解决</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​        首先，验证一个普通的标准字符串是不是回文串就是看前后对应位置的字符是不是相同，这明显时要用到双指针前后并行着对照呀</p><p>​        不过根据题目的要求，空格应不计算在内，所以这里要在每次检测元素是否对称前先排除掉中间的空格，并且统一将对应元素转换成小写或者大写来进行比较</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> i = <span class="number">0</span>, j = s.size() - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">if</span> (s.size() &lt;= <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; !<span class="built_in">isalnum</span>(s[i]))</span><br><span class="line">          i++;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j &amp;&amp; !<span class="built_in">isalnum</span>(s[j]))</span><br><span class="line">          j--;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">tolower</span>(s[i++]) != <span class="built_in">tolower</span>(s[j--]))</span><br><span class="line">          <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>​        使用 i 和 j 表示字符串的头尾索引，之后通过一个大循环遍历字符串，在大循环中，要通过两个小循环分别检测当前首位位置是否存在空格，使用循环的目的是防止连续空格，最后通过将对应位置呃赐福全部转换为小写，比较是否相等</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;验证回文串（简单）&quot;&gt;&lt;a href=&quot;#验证回文串（简单）&quot; class=&quot;headerlink&quot; title=&quot;验证回文串（简单）&quot;&gt;&lt;/a&gt;验证回文串（简单）&lt;/h1&gt;&lt;h2 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h2&gt;&lt;p&gt;给定一个字符串，验证它是否是回文串，只考虑字母和数字字符，可以忽略字母的大小写。&lt;/p&gt;
&lt;p&gt;​    说明：本题中，我们将空字符串定义为有效的回文串。&lt;/p&gt;
&lt;p&gt;​    示例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;A man, a plan, a canal: Panama&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;race a car&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="李明徽的LeetCode" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>数据结构（七）——树与二叉树</title>
    <link href="http://yoursite.com/2019/08/19/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%83%EF%BC%89%E2%80%94%E2%80%94%E6%A0%91%E4%B8%8E%E4%BA%8C%E5%8F%89%E6%A0%91/"/>
    <id>http://yoursite.com/2019/08/19/数据结构（七）——树与二叉树/</id>
    <published>2019-08-19T01:30:08.000Z</published>
    <updated>2019-08-22T02:57:13.157Z</updated>
    
    <content type="html"><![CDATA[<h1 id="树"><a href="#树" class="headerlink" title="树"></a>树</h1><p>​        树是数据结构中的一种非线性结构，树形结构节点间的关系是除了头节点（根 root）外，每个节点都存在唯一的前驱，但不唯一的后继，也就是说树形结构中节点的关系是一对多的关系，这篇文章主要说一下代码方面实现的过程，理论上设计的比较少</p><a id="more"></a><h3 id="普通树的定义"><a href="#普通树的定义" class="headerlink" title="普通树的定义"></a>普通树的定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//双亲存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line"><span class="keyword">int</span> parent;<span class="comment">//指向双亲位置</span></span><br><span class="line">&#125;PTree[MAXSIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">//孩子链存储指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">node* sons[MAXSIZE];<span class="comment">//指向孩子节点</span></span><br><span class="line">&#125;TSonNode;</span><br><span class="line"></span><br><span class="line"><span class="comment">//孩子兄弟链存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">tnode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">tnode *hp;<span class="comment">//指向兄弟</span></span><br><span class="line">tnode *vp;<span class="comment">//指向孩子节点</span></span><br><span class="line">&#125;TSBNode;</span><br></pre></td></tr></table></figure><p>​        另外树的操作，我将通过二叉树实现并说明实现原理</p><h2 id="树——二叉树"><a href="#树——二叉树" class="headerlink" title="树——二叉树"></a>树——二叉树</h2><p>​        二叉树是一种十分常用的特殊的树状存储结构，由一个根节点（root）和根节点左右两侧的左子树和右子树组成，一棵二叉树的每个节点最多只能含有两个子节点，且要区分开左孩子和右孩子</p><p>​        满二叉树和完全二叉树是二叉树中的两种状态，满二叉树即除最底层的节点外，每个节点都拥有自己的左孩子和右孩子，完全二叉树的特点则是最多只有下面两层的节点度数小于二，并且最下面一层的叶节点都依次排在该层最左边的位置上</p><p>​        同样也是因为二叉树树状存储结构的特性，在各种操作的实现算法中会经常使用递归操作</p><h3 id="二叉树的存储结构"><a href="#二叉树的存储结构" class="headerlink" title="二叉树的存储结构"></a>二叉树的存储结构</h3><p>​        二叉树的存储结构分为顺序存储和链式存储</p><p>​        在二叉树的顺序存储结构中，想要查找一个结点的双亲和孩子节点都很容易，但是对于一般的二叉树来说，空间的浪费十分惊人，所以这里我们主要讨论二叉树的链式存储结构</p><h3 id="二叉树的链式存储结构"><a href="#二叉树的链式存储结构" class="headerlink" title="二叉树的链式存储结构"></a>二叉树的链式存储结构</h3><p>​        除了定义必要的指针外，二叉链比较节省存储空间；在二叉链中，查找一个节点的孩子很容易，但是查找双亲不方便</p><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//二叉链，二叉树的链式存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DTnode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">DTnode *lchild, *rchild;</span><br><span class="line">&#125;DTnode;</span><br><span class="line"></span><br><span class="line"><span class="built_in">stack</span>&lt;DTnode*&gt; s;</span><br><span class="line"><span class="comment">//栈在初始化二叉树时使用</span></span><br></pre></td></tr></table></figure><h4 id="创建二叉链"><a href="#创建二叉链" class="headerlink" title="创建二叉链"></a>创建二叉链</h4><p>​        创建二叉链，是比较复杂的操作，这个操作的思想是，通过一个 “1(2(3(,4)),5(6,7))” 这种可以表示二叉树中每个节点的值的字符串，在遍历这个字符串的过程中，通过不同位置字符的不同来运行不同的代码实现创建二叉树</p><p>​        ch 是用来记录当前遍历位置字符的变量，从 str 的第一个字符开始遍历，当前根节点；一定是为空的，所以把第一个元素的值设置成头节点的值，使用栈的原理，如果遇到 ‘(’ 就先将当前的节点 p 进栈，之后根据 k 的值，来决定将数据赋给栈顶元素的左孩子还是右孩子，最后在遇到 ‘)’ 时就代表当前栈的双亲结点已经定义完，就弹出他</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DTnode *<span class="title">CreateDTnode</span><span class="params">(<span class="built_in">string</span> str)</span> </span>&#123;</span><br><span class="line">DTnode *b ;</span><br><span class="line">DTnode *p;</span><br><span class="line"><span class="keyword">int</span> k, j = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span> ch;</span><br><span class="line">b = <span class="literal">NULL</span>;</span><br><span class="line">ch = str[j];</span><br><span class="line"><span class="keyword">while</span> (ch != <span class="string">'\0'</span>) &#123;</span><br><span class="line"><span class="keyword">switch</span> (ch) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="string">'('</span>: s.push(p); k = <span class="number">1</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">')'</span>: s.pop(); <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="string">','</span>: k = <span class="number">2</span>; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">default</span>:</span><br><span class="line">p = (DTnode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DTnode));</span><br><span class="line">p-&gt;data = ch - <span class="string">'0'</span>;</span><br><span class="line">p-&gt;lchild = p-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line">b = p;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">switch</span> (k) &#123;</span><br><span class="line"><span class="keyword">case</span> <span class="number">1</span>: s.top()-&gt;lchild = p; <span class="keyword">break</span>;</span><br><span class="line"><span class="keyword">case</span> <span class="number">2</span>: s.top()-&gt;rchild = p; <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">j++;</span><br><span class="line">ch = str[j];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="二叉树深度"><a href="#二叉树深度" class="headerlink" title="二叉树深度"></a>二叉树深度</h4><p>​        通过递归操作来计算二叉树的深度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DTnodeDepth</span><span class="params">(DTnode *b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> lchilddep, rchilddep;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">lchilddep = DTnodeDepth(b-&gt;lchild);</span><br><span class="line">rchilddep = DTnodeDepth(b-&gt;rchild);</span><br><span class="line"><span class="keyword">return</span> (lchilddep &gt; rchilddep) ? (lchilddep + <span class="number">1</span>) : (rchilddep + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="打印二叉树"><a href="#打印二叉树" class="headerlink" title="打印二叉树"></a>打印二叉树</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PTree</span><span class="params">(DTnode *dt)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (dt == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dt-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">PTree(dt-&gt;lchild);</span><br><span class="line">PTree(dt-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="查找节点"><a href="#查找节点" class="headerlink" title="查找节点"></a>查找节点</h4><p>​        同样是通过递归算法，查找符合给定值的节点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DTnode *<span class="title">FindNode</span><span class="params">(DTnode *b, <span class="keyword">int</span> x)</span> </span>&#123;</span><br><span class="line">DTnode *p;</span><br><span class="line"><span class="keyword">if</span> (b == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span> (b-&gt;data == x)</span><br><span class="line"><span class="keyword">return</span> b;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">p = FindNode(b-&gt;lchild, x);</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> FindNode(b-&gt;rchild, x);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="headerlink" title="二叉树的遍历"></a>二叉树的遍历</h3><p>​        图片加不上去实在是太难受了！口述吧！</p><p>​        先给一个二叉树</p><p>​        A(B(D,F(E,)),C(G(,H),I))</p><h4 id="先序遍历"><a href="#先序遍历" class="headerlink" title="先序遍历"></a>先序遍历</h4><p>​        先序遍历的顺序是先遍历根节点，再遍历左子树，最后遍历右子树</p><p>​        例子中给的二叉树，按照先序遍历排列得到的就是</p><p>​        ABDFECGHI</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">FOrder</span><span class="params">(DTnode *dt)</span> </span>&#123;</span><br><span class="line"><span class="comment">//先序遍历</span></span><br><span class="line"><span class="keyword">if</span> (dt == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dt-&gt;data &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">FOrder(dt-&gt;lchild);</span><br><span class="line">FOrder(dt-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>​        中序遍历的顺序是先遍历左子树，访问根节点，再遍历右子树</p><p>​        结果为：DBEFAGHCI</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">COrder</span><span class="params">(DTnode *dt)</span> </span>&#123;</span><br><span class="line"><span class="comment">//中序遍历</span></span><br><span class="line">    <span class="keyword">if</span>(dt == <span class="literal">NULL</span>) </span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">COrder(dt-&gt;lchild);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dt-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">COrder(dt-&gt;rchild);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="后序遍历"><a href="#后序遍历" class="headerlink" title="后序遍历"></a>后序遍历</h4><p>​        后序遍历的顺序是先遍历左子树，再遍历右子树，最后访问根节点</p><p>​        结果为：DEFBHGICA</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LPerOrder</span><span class="params">(DTnode *dt)</span> </span>&#123;</span><br><span class="line"><span class="comment">//后序遍历</span></span><br><span class="line"><span class="keyword">if</span> (dt == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">LPerOrder(dt-&gt;lchild);</span><br><span class="line">LPerOrder(dt-&gt;rchild);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; dt-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;树&quot;&gt;&lt;a href=&quot;#树&quot; class=&quot;headerlink&quot; title=&quot;树&quot;&gt;&lt;/a&gt;树&lt;/h1&gt;&lt;p&gt;​        树是数据结构中的一种非线性结构，树形结构节点间的关系是除了头节点（根 root）外，每个节点都存在唯一的前驱，但不唯一的后继，也就是说树形结构中节点的关系是一对多的关系，这篇文章主要说一下代码方面实现的过程，理论上设计的比较少&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的树" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E6%A0%91/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-1、167——两数相加</title>
    <link href="http://yoursite.com/2019/08/16/LeetCode-1%E3%80%81167%E2%80%94%E2%80%94%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0/"/>
    <id>http://yoursite.com/2019/08/16/LeetCode-1、167——两数相加/</id>
    <published>2019-08-16T00:39:37.000Z</published>
    <updated>2019-08-23T01:36:39.675Z</updated>
    
    <content type="html"><![CDATA[<h1 id="两数之和（一、二）"><a href="#两数之和（一、二）" class="headerlink" title="两数之和（一、二）"></a>两数之和（一、二）</h1><p>​        LeetCode 上的两个两数之和问题，一个是输入的有序数组，一个无序，解法稍有偏差，这里在何涛大佬的帮助下多放几种解法！</p><a id="more"></a><h2 id="两数之和（输入有序数组）"><a href="#两数之和（输入有序数组）" class="headerlink" title="两数之和（输入有序数组）"></a>两数之和（输入有序数组）</h2><h3 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h3><p>​        给定一个已按照升序排列 的有序数组，找到两个数使得它们相加之和等于目标数。</p><p>​        函数应该返回这两个下标值 index1 和 index2，其中 index1 必须小于 index2。</p><p>说明:</p><p>​        返回的下标值（index1 和 index2）不是从零开始的。<br>​        你可以假设每个输入只对应唯一的答案，而且你不可以重复使用相同的元素。<br>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: numbers = [2, 7, 11, 15], target = 9</span><br><span class="line">输出: [1,2]</span><br><span class="line">解释: 2 与 7 之和等于目标数 9 。因此 index1 = 1, index2 = 2</span><br></pre></td></tr></table></figure><h3 id="暴力解决"><a href="#暴力解决" class="headerlink" title="暴力解决"></a>暴力解决</h3><p>​        嵌套 for 循环，时间复杂度 O(n²)，慢就完事了</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i + <span class="number">1</span>; j &lt; nums.size(); j++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[i] + nums[j] == target)</span><br><span class="line">                    <span class="keyword">return</span> &#123;i, j&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="双指针解决"><a href="#双指针解决" class="headerlink" title="双指针解决"></a>双指针解决</h3><h4 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h4><p>​        双指针解法，定义头尾两个指针分别代表输入数组的首末元素，定义 while 循环检测两元素相加与 target 对比大小，小的话就头指针后移，大的话就尾指针前移（因为数组是有序的！），这样折半查找来找到这两个数</p><h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; numbers, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="keyword">int</span> l = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">int</span> r = numbers.size() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[l] + numbers[r] &gt; target)</span><br><span class="line">                r--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (numbers[l] + numbers[r] &lt; target)</span><br><span class="line">                l++;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> &#123;l + <span class="number">1</span>, r + <span class="number">1</span>&#125;;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="两数之和（输入无序数组）"><a href="#两数之和（输入无序数组）" class="headerlink" title="两数之和（输入无序数组）"></a>两数之和（输入无序数组）</h2><h3 id="题目要求-1"><a href="#题目要求-1" class="headerlink" title="题目要求"></a>题目要求</h3><p>​        给定一个整数数组 nums 和一个目标值 target，请你在该数组中找出和为目标值的那 两个 整数，并返回他们的数组下标。</p><p>​        你可以假设每种输入只会对应一个答案。但是，你不能重复利用这个数组中同样的元素。</p><p>示例:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定 nums = [2, 7, 11, 15], target = 9</span><br><span class="line"></span><br><span class="line">因为 nums[0] + nums[1] = 2 + 7 = 9</span><br><span class="line">所以返回 [0, 1]</span><br></pre></td></tr></table></figure><h3 id="使用-unordered-map-解决"><a href="#使用-unordered-map-解决" class="headerlink" title="使用 unordered_map 解决"></a>使用 unordered_map 解决</h3><h4 id="思路-1"><a href="#思路-1" class="headerlink" title="思路"></a>思路</h4><p>​        首先因为输入的数组是无序的，不可以直接使用双指针的解法来作答，但是既然不能两个元素两个元素查，那就一个元素一个元素查吧！先定义一个 unordered_map（使用无序 map 是因为要比普通 map 更快），然后使用 for 循环来遍历整个数组，流程是：两个数相加遍历时两个加数总要有一个先被遍历到，这时候因为 map 中没有与之匹配的另一个加数，这时候就把当前遍历到这个加数放进 map 中，等到循环遍历到另一个加数时，就可检测到之前放入 map 中的加数，这样这道题就解决了</p><h4 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target) &#123;</span><br><span class="line">        <span class="built_in">unordered_map</span>&lt;<span class="keyword">int</span>, <span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> another = target - nums[i];</span><br><span class="line">            <span class="keyword">if</span>(m.count(another))</span><br><span class="line">                <span class="keyword">return</span> &#123;m[another], i&#125;;</span><br><span class="line">            m[nums[i]] = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="先排序再用双指针"><a href="#先排序再用双指针" class="headerlink" title="先排序再用双指针"></a>先排序再用双指针</h3><h4 id="思路-2"><a href="#思路-2" class="headerlink" title="思路"></a>思路</h4><p>​        既然输入的数组无序！那就给他排序！排序后就可以按照有序数组的解法来解决啦，不过这里需要注意数组下标的问题，因为重新排序后，原数组的下标就被打乱了，所以需要使用另一个数组先记录原数组的个元素位置，最后再另一个数组里找到元素组对应元素的下标值返回就好了</p><h4 id="代码-2"><a href="#代码-2" class="headerlink" title="代码"></a>代码</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; twoSum(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; n, <span class="keyword">int</span> t) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; m;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; ans;</span><br><span class="line">        m=n;</span><br><span class="line">        sort(n.begin(),n.end());</span><br><span class="line">        <span class="keyword">int</span> l=<span class="number">0</span>,r=n.size()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(r&gt;l)&#123;</span><br><span class="line">            <span class="keyword">if</span>(n[l]+n[r]&gt;t)r--;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(n[l]+n[r]&lt;t)l++;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(r&lt;l)<span class="keyword">return</span> ans;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;m.size();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(m[i]==n[l]||m[i]==n[r])ans.push_back(i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;两数之和（一、二）&quot;&gt;&lt;a href=&quot;#两数之和（一、二）&quot; class=&quot;headerlink&quot; title=&quot;两数之和（一、二）&quot;&gt;&lt;/a&gt;两数之和（一、二）&lt;/h1&gt;&lt;p&gt;​        LeetCode 上的两个两数之和问题，一个是输入的有序数组，一个无序，解法稍有偏差，这里在何涛大佬的帮助下多放几种解法！&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的LeetCode" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>神奇的动态数组——vector</title>
    <link href="http://yoursite.com/2019/08/14/%E7%A5%9E%E5%A5%87%E7%9A%84%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84%E2%80%94%E2%80%94vector/"/>
    <id>http://yoursite.com/2019/08/14/神奇的动态数组——vector/</id>
    <published>2019-08-14T15:01:18.000Z</published>
    <updated>2019-08-15T12:20:08.289Z</updated>
    
    <content type="html"><![CDATA[<h1 id="神奇的-Vector-动态数组"><a href="#神奇的-Vector-动态数组" class="headerlink" title="神奇的 Vector 动态数组"></a>神奇的 Vector 动态数组</h1><h2 id="什么是-Vector"><a href="#什么是-Vector" class="headerlink" title="什么是 Vector"></a>什么是 Vector</h2><p>​        Vector 是一个动态数组（dynamic array），提供了很多操作的接口，使用 Vector 需要引入头文件 #include<vector> 并且一定要声明命名空间 std，因为 Vector 是定义在 std 里 template 中的</vector></p><p>​        Vector 是一种动态的顺序表结构，可以像数组一样访问、随机访问、只用迭代器访问其中的元素</p><a id="more"></a><h2 id="Vector-的属性"><a href="#Vector-的属性" class="headerlink" title="Vector 的属性"></a>Vector 的属性</h2><h3 id="大小和容量"><a href="#大小和容量" class="headerlink" title="大小和容量"></a>大小和容量</h3><p>​        对于常规数组来说，最大的限制就是其大小必须事先定义好，而 Vector 中通过 size() 和 capacity() 分别来表示其大小和容量，其中 size() 用来表示大小，即 Vector 中当前存放了多少数据；capacity() 用来表示容量，即 Vector 中最大存放的数据是多少，而当 size() 将要超过 capacity() 时，Vector 会自动扩充其容量，这就是 Vector 是动态数组的原因</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; a;<span class="comment">//定义 int 类型的 Vector</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">50</span>; i++) &#123;</span><br><span class="line">a.push_back(i);<span class="comment">//在 Vector 尾部添加元素</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"a = "</span> &lt;&lt; a[i] &lt;&lt; <span class="string">" size = "</span> &lt;&lt; a.size() &lt;&lt; <span class="string">" capacity = "</span> &lt;&lt; a.capacity() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        以上代码可以很好的反应 capacity() 可以自行扩大的特性</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;DataType&gt; item;<span class="comment">//定义 Vector</span></span><br><span class="line"><span class="built_in">vector</span>&lt;DataType&gt; item(n);<span class="comment">//初始化 Vector 的容量</span></span><br><span class="line"><span class="built_in">vector</span>&lt;DataType&gt; item(<span class="keyword">int</span>, DataType);<span class="comment">//初始化 Vector 的容量并且使其内容全部为 Datatype</span></span><br><span class="line"><span class="built_in">vector</span>&lt;DataType&gt; item(it.begin(), it.end());<span class="comment">//传进一个迭代器区间用来为 Vector 赋值</span></span><br><span class="line"><span class="built_in">vector</span>&lt;DataType&gt; item(Class);<span class="comment">//传进一个对象，执行其构造函数</span></span><br></pre></td></tr></table></figure><p>​        Vector 动态数组里可以存放任何类型的变量，但前提是一个 Vector 只能存放同一种类型的数据，并且 Vector 中有很多定义方法，可以根据需求使用不同的方法来定义你的 Vector</p><h3 id="一些方法"><a href="#一些方法" class="headerlink" title="一些方法"></a>一些方法</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; item;</span><br><span class="line">item.empty();<span class="comment">//布尔型函数，空返回 true，非空返回 false</span></span><br><span class="line">item.size();<span class="comment">//返回当前 Vector 的元素数量</span></span><br><span class="line">item.max_size();<span class="comment">//返回当前 Vector 可容纳的最大元素数量</span></span><br><span class="line">item.capacity();<span class="comment">//返回当前 Vector 的容量</span></span><br><span class="line">item.reserve(n);<span class="comment">//重新设定当前 Vector 的容量，若新值小于当前值，则语句无效</span></span><br><span class="line">item.shrink_to_fit();<span class="comment">//修改当前 Vector 的容量为其 size() 值</span></span><br><span class="line">item.assign(n, data);<span class="comment">//将n个数据 data 添加进 Vector 中</span></span><br><span class="line">item.assign(begin(), end());<span class="comment">//复制迭代器中 begin 到 end 的内容并赋值给 Vector</span></span><br><span class="line">item.swap(Vector);</span><br><span class="line">swap(item, Vector);<span class="comment">//以上两个方法都是用来交换两个 Vector 中的元素的</span></span><br><span class="line">item.push_back(data);<span class="comment">//在 Vector 末尾插入新元素 data</span></span><br><span class="line">item.pop_back();<span class="comment">//移除 Vector 的最后一个元素</span></span><br><span class="line">item.insert(pos, data);<span class="comment">//在 pos 的位置插入 data，并返回这个 data 的 pos（int 类型）</span></span><br><span class="line">item.insert(pos, n, data);<span class="comment">//在 pos 的位置上插入 n 个 data，并返回第一个 data 的位置</span></span><br><span class="line">item.insert(pos, begin(), end());<span class="comment">//在 pos 的位置上，添加一段迭代器返回的值</span></span><br></pre></td></tr></table></figure><h3 id="迭代器！"><a href="#迭代器！" class="headerlink" title="迭代器！"></a>迭代器！</h3><p>​        迭代器用来访问 Vector 中的数据元素，这也是 Vector 特有的功能，使用迭代器可以实现一种十分简便的遍历方法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::iterator it1 = item.begin();</span><br><span class="line"><span class="comment">//指向首个元素的迭代器</span></span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">char</span>&gt;::iterator it1 = item.begin();</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="built_in">string</span>&gt;::iterator it1 = item.end();</span><br></pre></td></tr></table></figure><p>​        迭代器可以正反迭代</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">auto</span> it = a.cbegin(); it != a.cend(); it++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *it &lt;&lt; <span class="string">" "</span>;</span><br></pre></td></tr></table></figure><p>​        auto 在 C++ 11 中的作用是自动推断变量类型，但是必须在定义时就初始化该变量，类似于 const</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        Vector 的本质就是一个动态数组，因为基本操作上是一个有序容器，所以也可以当作栈或者表来使用</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;神奇的-Vector-动态数组&quot;&gt;&lt;a href=&quot;#神奇的-Vector-动态数组&quot; class=&quot;headerlink&quot; title=&quot;神奇的 Vector 动态数组&quot;&gt;&lt;/a&gt;神奇的 Vector 动态数组&lt;/h1&gt;&lt;h2 id=&quot;什么是-Vector&quot;&gt;&lt;a href=&quot;#什么是-Vector&quot; class=&quot;headerlink&quot; title=&quot;什么是 Vector&quot;&gt;&lt;/a&gt;什么是 Vector&lt;/h2&gt;&lt;p&gt;​        Vector 是一个动态数组（dynamic array），提供了很多操作的接口，使用 Vector 需要引入头文件 #include&lt;vector&gt; 并且一定要声明命名空间 std，因为 Vector 是定义在 std 里 template 中的&lt;/vector&gt;&lt;/p&gt;
&lt;p&gt;​        Vector 是一种动态的顺序表结构，可以像数组一样访问、随机访问、只用迭代器访问其中的元素&lt;/p&gt;
    
    </summary>
    
    
      <category term="Vector动态数组" scheme="http://yoursite.com/tags/Vector%E5%8A%A8%E6%80%81%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构（六）——顺序队列、链队列</title>
    <link href="http://yoursite.com/2019/08/12/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%85%AD%EF%BC%89%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E9%98%9F%E5%88%97%E3%80%81%E9%93%BE%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/08/12/数据结构（六）——顺序队列、链队列/</id>
    <published>2019-08-12T02:30:38.000Z</published>
    <updated>2019-08-13T13:21:21.252Z</updated>
    
    <content type="html"><![CDATA[<h1 id="队列——顺序队列、链队列"><a href="#队列——顺序队列、链队列" class="headerlink" title="队列——顺序队列、链队列"></a>队列——顺序队列、链队列</h1><h2 id="队列概念"><a href="#队列概念" class="headerlink" title="队列概念"></a>队列概念</h2><p>​        队列是一种特殊的、只允许在一端进行数据的输入，在另一端进行数据的删除、具有先进先出（FIFO）特性的线性表，进行插入操作的一端称为队尾，进行删除操作的一端称为队头</p><h2 id="顺序队列"><a href="#顺序队列" class="headerlink" title="顺序队列"></a>顺序队列</h2><p>​        顺序队列就是限制只能在队列两端分别进行插入和删除操作的线性表</p><a id="more"></a><h3 id="顺序队列定义"><a href="#顺序队列定义" class="headerlink" title="顺序队列定义"></a>顺序队列定义</h3><p>​        顺序队列的定义就是在顺序表的基础上加上代表队头 front 和队尾 rear 的头尾”指针“，用来对队列的其他操作服务</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> front, rear;</span><br><span class="line"><span class="keyword">int</span> QueueSize;</span><br><span class="line">&#125;SeQueue;</span><br></pre></td></tr></table></figure><h3 id="初始化队列"><a href="#初始化队列" class="headerlink" title="初始化队列"></a>初始化队列</h3><p>​        所谓初始化就是一个分配资源，再让变量值都合法并符合最初时的状态，队列的初始状态和栈很像，需要将队头 front 和队尾 rear 都为 -1，并让队列的长度归 0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SeQueue* <span class="title">InitQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SeQueue* sq;</span><br><span class="line">sq = (SeQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeQueue));</span><br><span class="line">sq-&gt;front = sq-&gt;rear = <span class="number">-1</span>;</span><br><span class="line">sq-&gt;QueueSize = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> sq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判空"><a href="#判空" class="headerlink" title="判空"></a>判空</h3><p>​        既然已经定义了队列的大小这一属性 QueueSize，就直接检测其值来判断队列是否为空即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">EmptyQueue</span><span class="params">(SeQueue* sq)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sq-&gt;QueueSize == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入队"><a href="#入队" class="headerlink" title="入队"></a>入队</h3><p>​        入队操作是在队尾 rear 的后一个位置上向队内插入新的数据元素，所以需要先检验队列是否已满，而后为该位置赋值，再改变相应属性的值即可</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">InQueue</span><span class="params">(SeQueue* sq, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sq-&gt;QueueSize == MAXSIZE)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">sq-&gt;rear = (sq-&gt;rear + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">sq-&gt;data[sq-&gt;rear] = d;</span><br><span class="line">sq-&gt;QueueSize++;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出队"><a href="#出队" class="headerlink" title="出队"></a>出队</h3><p>​        队列的出队有两种方法，一种是直接移动队头 front 指针，这样的出队方法十分简单快速，但缺点就是这样的出队方式会造成队列实际长度的减少，从而造成假溢出（顺序队列因多次入队列和出队列操作后出现的尚有存储空间但不能进行入队列操作的溢出）</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">OutQueue1</span><span class="params">(SeQueue* sq, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sq-&gt;QueueSize == <span class="number">0</span>) </span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">sq-&gt;front = (sq-&gt;front + <span class="number">1</span>) % MAXSIZE;</span><br><span class="line">d = sq-&gt;data[sq-&gt;front];</span><br><span class="line">sq-&gt;QueueSize--;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        第二种方法是不改变队头 front 的位置，在删除掉队头元素后，将整个队列中的所有元素都前移，再将队尾 rear 前移，这样做虽然不存在假溢出的问题，但是操作时间明显增加，每次操作都需要移动大量的元素</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">OutQueue2</span><span class="params">(SeQueue* sq, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (sq-&gt;QueueSize == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">d = sq-&gt;data[sq-&gt;front];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; sq-&gt;QueueSize - <span class="number">1</span>; i++) </span><br><span class="line">sq-&gt;data[i] = sq-&gt;data[i + <span class="number">1</span>];</span><br><span class="line">sq-&gt;rear--;</span><br><span class="line">sq-&gt;QueueSize--;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="链队"><a href="#链队" class="headerlink" title="链队"></a>链队</h2><p>​        链队同样是一种先进先出（FIFO）表，只不过使用了链式存储结构，在普通的顺序队列中增加了 front、rear 来表示队头和队尾指针</p><h3 id="链队定义"><a href="#链队定义" class="headerlink" title="链队定义"></a>链队定义</h3><p>​        链队的定义需要使用两个结构体，QNode 用来表示链队中的每一个单个节点，LinkQueue 用来表示整个队列，其中需要定义链队特有的队头队尾指针</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">QNode* next;</span><br><span class="line">&#125;QNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkQueue</span> &#123;</span></span><br><span class="line">QNode *front, *rear;</span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><h3 id="初始化链队"><a href="#初始化链队" class="headerlink" title="初始化链队"></a>初始化链队</h3><p>​        与链表一样，链队的定义就是请求内存，并将队头、队尾指针置空的过程，最后返回这个队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkQueue* <span class="title">InitLQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LinkQueue* Q = (LinkQueue*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkQueue));</span><br><span class="line">Q-&gt;front = Q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> Q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="链队判空"><a href="#链队判空" class="headerlink" title="链队判空"></a>链队判空</h3><p>​        如果链队的队头指针以及队尾指针均为空或其中之一为空即可判定该链队为空</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(LinkQueue* q)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (q-&gt;front == q-&gt;rear &amp;&amp; q-&gt;front == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="销毁链队"><a href="#销毁链队" class="headerlink" title="销毁链队"></a>销毁链队</h3><p>​        销毁链队需要使用循环，遍历整个链队，一个节点一个节点的释放资源，最后释放掉整个队列</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DestroyQueue</span><span class="params">(LinkQueue *q)</span> </span>&#123;</span><br><span class="line">QNode* r;</span><br><span class="line">QNode* p = q-&gt;front;</span><br><span class="line"><span class="keyword">if</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">r = p-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (r != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line">p = r;</span><br><span class="line">r = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">delete</span> p;</span><br><span class="line"><span class="keyword">delete</span> q;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入队-1"><a href="#入队-1" class="headerlink" title="入队"></a>入队</h3><p>​        链队的入队，先完成要入对的节点的定义和赋值，之后入队分成原队列是否为空两种情况。若原队列为空，将队头和队尾指针都指向该节点即可；若原队列为非空，设定队尾为加入数据的一端，连接队头和原队尾节点即完成入队</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InQueue</span><span class="params">(LinkQueue *q, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">QNode* r;</span><br><span class="line">r = (QNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(QNode));</span><br><span class="line">r-&gt;data = d;</span><br><span class="line">r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">if</span> (q-&gt;rear == <span class="literal">NULL</span>)</span><br><span class="line">q-&gt;front = q-&gt;rear = r;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">q-&gt;rear-&gt;next = r;</span><br><span class="line">q-&gt;rear = r;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出队-1"><a href="#出队-1" class="headerlink" title="出队"></a>出队</h3><p>​        出队先判断队列是否本就为空，再检测是否只含有一个节点，是的话就将队头队尾指针置空，最后是普通情况，因为队尾是插入段，所以队头为删除端，只需要将队头指针后移即可，随后释放 r 节点的资源</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutQueue</span><span class="params">(LinkQueue* q)</span> </span>&#123;</span><br><span class="line">QNode* r;</span><br><span class="line"><span class="keyword">if</span> (q-&gt;rear == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">r = q-&gt;front;</span><br><span class="line"><span class="keyword">if</span> (q-&gt;front == q-&gt;rear)</span><br><span class="line">q-&gt;front = q-&gt;rear = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">q-&gt;front = q-&gt;front-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        （1）链队相比顺序队列，元素出队时不需要大量的移动现有节点，移动队头指针即可</p><p>​        （2）链队相比需要增加一些额外的存储空间</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;队列——顺序队列、链队列&quot;&gt;&lt;a href=&quot;#队列——顺序队列、链队列&quot; class=&quot;headerlink&quot; title=&quot;队列——顺序队列、链队列&quot;&gt;&lt;/a&gt;队列——顺序队列、链队列&lt;/h1&gt;&lt;h2 id=&quot;队列概念&quot;&gt;&lt;a href=&quot;#队列概念&quot; class=&quot;headerlink&quot; title=&quot;队列概念&quot;&gt;&lt;/a&gt;队列概念&lt;/h2&gt;&lt;p&gt;​        队列是一种特殊的、只允许在一端进行数据的输入，在另一端进行数据的删除、具有先进先出（FIFO）特性的线性表，进行插入操作的一端称为队尾，进行删除操作的一端称为队头&lt;/p&gt;
&lt;h2 id=&quot;顺序队列&quot;&gt;&lt;a href=&quot;#顺序队列&quot; class=&quot;headerlink&quot; title=&quot;顺序队列&quot;&gt;&lt;/a&gt;顺序队列&lt;/h2&gt;&lt;p&gt;​        顺序队列就是限制只能在队列两端分别进行插入和删除操作的线性表&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的队列" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-20——有效的括号</title>
    <link href="http://yoursite.com/2019/08/08/LeetCode-20%E2%80%94%E2%80%94%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7/"/>
    <id>http://yoursite.com/2019/08/08/LeetCode-20——有效的括号/</id>
    <published>2019-08-08T05:28:17.000Z</published>
    <updated>2019-08-23T01:36:31.790Z</updated>
    
    <content type="html"><![CDATA[<h1 id="有效的括号（简单）"><a href="#有效的括号（简单）" class="headerlink" title="有效的括号（简单）"></a>有效的括号（简单）</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。</p><p>​        有效字符串需满足：</p><p>​            1.左括号必须用相同类型的右括号闭合。<br>​            2.左括号必须以正确的顺序闭合。<br>​            3.注意空字符串可被认为是有效字符串。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">输入: &quot;()&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">输入: &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">输入: &quot;(]&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">输入: &quot;([)]&quot;</span><br><span class="line">输出: false</span><br><span class="line"></span><br><span class="line">输入: &quot;&#123;[]&#125;&quot;</span><br><span class="line">输出: true</span><br></pre></td></tr></table></figure><p>第一次做，执行了 n 次，执行用时 4ms，内存消耗 9.4MB 菜的一批，先放第一次提交的代码，优化之后再发上来</p><a id="more"></a><h2 id="使用C-栈解决"><a href="#使用C-栈解决" class="headerlink" title="使用C++栈解决"></a>使用C++栈解决</h2><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​        根据题意进行分析， 可以参考编译器中识别 ()、[]、{} 是否成对出现的功能。</p><p>​        理解题目意思后，简单的构思一下问题，这里说的直接一点，当 ’(‘、‘[’、‘{’ 其中一个出现时，就意味着剩下的字符串中必须要存在与之对应的 ’)‘、‘]’、‘}’，这里先不提栈的概念，我们想要检测后边的字符中是否含有与该左字符配对的右字符，就要先把这个左字符存起来，假设一个用例为 ‘([{}])’，这样把前一半 ‘([{’ 都存好后，要先把 ‘{’ 拿出来与后边的右字符相比较，而 ‘{’ 恰好是最后一个存放的左字符，这下思路应该清晰了，后存放的左字符要先取出来拿去比较，后进先出，这不是典型的栈嘛</p><p>​        发现这点后以此为中心设计解题方法，即每次遇到一个新的左字符，就将他压入栈中，遇到右字符，就检测他是否可以与当前的栈顶数据配对，如果可以，就将栈顶数据出栈，然后继续检查后续的字符。只要有没能匹配成功或者栈已经空了，就说明当前检测的字符串是非法的，反之用这个方法遍历了整个字符串后就说明字符串是合法的</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 10240</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">char</span> data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line">&#125;SeqStack;</span><br><span class="line"></span><br><span class="line"><span class="function">SeqStack *<span class="title">InitSeqStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SeqStack *s;</span><br><span class="line">s = (SeqStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeqStack));</span><br><span class="line">s-&gt;top = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push_SeqStack</span><span class="params">(SeqStack *s, <span class="keyword">char</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s-&gt;top == MAXSIZE - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">s-&gt;top++;</span><br><span class="line">s-&gt;data[s-&gt;top] = d;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Empty_SeqStack</span><span class="params">(SeqStack *s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s-&gt;top == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop_SeqStack</span><span class="params">(SeqStack *s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Empty_SeqStack(s))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123; </span><br><span class="line">s-&gt;top--;</span><br><span class="line"><span class="keyword">return</span> <span class="number">2</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    SeqStack *<span class="built_in">stack</span>;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">char</span> now;</span><br><span class="line">        <span class="built_in">stack</span> = InitSeqStack();</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'('</span> || s[i] == <span class="string">'['</span> || s[i] == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">                <span class="keyword">int</span> a = Push_SeqStack(<span class="built_in">stack</span>, s[i]);</span><br><span class="line">                <span class="built_in">cout</span> &lt;&lt; a;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (Empty_SeqStack(<span class="built_in">stack</span>) == <span class="number">1</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">')'</span>)</span><br><span class="line">                    now = <span class="string">'('</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'&#125;'</span>)</span><br><span class="line">                    now = <span class="string">'&#123;'</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">']'</span>)</span><br><span class="line">                    now = <span class="string">'['</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    now = <span class="string">'a'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top] == now) &#123;</span><br><span class="line">                    <span class="keyword">int</span> b = Pop_SeqStack(<span class="built_in">stack</span>);</span><br><span class="line">                    <span class="built_in">cout</span> &lt;&lt; b &lt;&lt; <span class="built_in">endl</span>; </span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(Empty_SeqStack(<span class="built_in">stack</span>) == <span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="经过何涛大佬指点后"><a href="#经过何涛大佬指点后" class="headerlink" title="经过何涛大佬指点后"></a>经过何涛大佬指点后</h3><p>​        傻吊的我并不知道要用封装好的栈，并把我的几个检测变量删掉了，内存消耗一下子就降下来啦，别人的代码就是不一样！</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">stack</span>&lt;<span class="keyword">char</span>&gt; st;</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isValid</span><span class="params">(<span class="built_in">string</span> s)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> i;</span><br><span class="line">        <span class="keyword">char</span> now;</span><br><span class="line">        <span class="keyword">for</span>(i = <span class="number">0</span>; s[i]; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">'('</span> || s[i] == <span class="string">'['</span> || s[i] == <span class="string">'&#123;'</span>) &#123;</span><br><span class="line">               st.push(s[i]);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (st.empty())</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">')'</span>)</span><br><span class="line">                    now = <span class="string">'('</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">'&#125;'</span>)</span><br><span class="line">                    now = <span class="string">'&#123;'</span>;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (s[i] == <span class="string">']'</span>)</span><br><span class="line">                    now = <span class="string">'['</span>;</span><br><span class="line">                <span class="keyword">else</span> &#123;</span><br><span class="line">                    now = <span class="string">'a'</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span>(st.top() == now) &#123;</span><br><span class="line">                    st.pop();</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(st.empty())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;有效的括号（简单）&quot;&gt;&lt;a href=&quot;#有效的括号（简单）&quot; class=&quot;headerlink&quot; title=&quot;有效的括号（简单）&quot;&gt;&lt;/a&gt;有效的括号（简单）&lt;/h1&gt;&lt;h2 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h2&gt;&lt;p&gt;给定一个只包括 ‘(‘，’)’，’{‘，’}’，’[‘，’]’ 的字符串，判断字符串是否有效。&lt;/p&gt;
&lt;p&gt;​        有效字符串需满足：&lt;/p&gt;
&lt;p&gt;​            1.左括号必须用相同类型的右括号闭合。&lt;br&gt;​            2.左括号必须以正确的顺序闭合。&lt;br&gt;​            3.注意空字符串可被认为是有效字符串。&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;()&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;()[]&amp;#123;&amp;#125;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;(]&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;([)]&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: &amp;quot;&amp;#123;[]&amp;#125;&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;第一次做，执行了 n 次，执行用时 4ms，内存消耗 9.4MB 菜的一批，先放第一次提交的代码，优化之后再发上来&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的LeetCode" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>数据结构（五）——链栈</title>
    <link href="http://yoursite.com/2019/08/08/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%94%EF%BC%89%E2%80%94%E2%80%94%E9%93%BE%E6%A0%88/"/>
    <id>http://yoursite.com/2019/08/08/数据结构（五）——链栈/</id>
    <published>2019-08-08T00:12:58.000Z</published>
    <updated>2019-08-08T00:34:08.091Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈——链栈"><a href="#栈——链栈" class="headerlink" title="栈——链栈"></a>栈——链栈</h1><h2 id="链栈"><a href="#链栈" class="headerlink" title="链栈"></a>链栈</h2><p>​        链栈是一种特殊的线性链表，使使用链式存储结构的栈，链栈也有栈顶栈底，同样是一种后进先出（LIFO）的数据结构</p><a id="more"></a><h3 id="链栈定义"><a href="#链栈定义" class="headerlink" title="链栈定义"></a>链栈定义</h3><p>​        链栈需要定义两个结构体，LinkStackNode 用来定义链栈节点的类型，存放节点的数据和下一节点的 next 指针</p><p>​        LinkStack 结构体用来定义链栈的结构，存放 top 栈顶指针和链栈的总长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkStackNode</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">LinkStackNode *next;</span><br><span class="line">&#125;LinkStackNode;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LinkStack</span> &#123;</span></span><br><span class="line">LinkStackNode *top;</span><br><span class="line"><span class="keyword">int</span> length;</span><br><span class="line">&#125;LinkStack;</span><br></pre></td></tr></table></figure><h3 id="创建链栈"><a href="#创建链栈" class="headerlink" title="创建链栈"></a>创建链栈</h3><p>​        创建链栈的过程就是定义 LinkStack 变量并为其分配内存，再让栈顶指针指空，栈的长度归 0</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkStack * <span class="title">CreateStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LinkStack *p;</span><br><span class="line">p = (LinkStack *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStack));</span><br><span class="line">p-&gt;length = <span class="number">0</span>;</span><br><span class="line">p-&gt;top = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断栈是否为空"><a href="#判断栈是否为空" class="headerlink" title="判断栈是否为空"></a>判断栈是否为空</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">IsEmpty</span><span class="params">(LinkStack *p)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;length == <span class="number">0</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="入栈"><a href="#入栈" class="headerlink" title="入栈"></a>入栈</h3><p>​        因为栈的本质是一种后入先出的数据结构，所以所有的操作都要在栈顶进行。入栈操作即定义新的 LinkStackNode 并为其分配内存，给他的数据域赋值，使新节点的 next 指向原栈顶处的节点，在使新入节点成为新的栈顶结点，栈的长度 +1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkStack *<span class="title">PushStack</span><span class="params">(LinkStack *p, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">LinkStackNode *temp;</span><br><span class="line">temp = (LinkStackNode *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LinkStackNode));</span><br><span class="line">temp-&gt;data = d;</span><br><span class="line">temp-&gt;next = p-&gt;top;</span><br><span class="line">p-&gt;top = temp;</span><br><span class="line">p-&gt;length++;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="出栈"><a href="#出栈" class="headerlink" title="出栈"></a>出栈</h3><p>​        出栈需要先判断栈是否为空，再将栈顶指针指向原栈顶节点的 next，释放原栈顶节点的内存，栈的长度 -1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">LinkStack *<span class="title">PopStack</span><span class="params">(LinkStack *p)</span> </span>&#123;</span><br><span class="line">LinkStackNode *temp;</span><br><span class="line">temp = p-&gt;top;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;top == <span class="literal">NULL</span> || IsEmpty(p) == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"this stack is EMPTY !"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">p-&gt;top = p-&gt;top-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(temp);</span><br><span class="line">p-&gt;length--;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="打印栈"><a href="#打印栈" class="headerlink" title="打印栈"></a>打印栈</h3><p>​        打印栈同样先检测栈是否为空，然后在遍历栈的同时打印每个节点的数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ShowStack</span><span class="params">(LinkStack *p)</span> </span>&#123;</span><br><span class="line">LinkStackNode *temp;</span><br><span class="line">temp = p-&gt;top;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;top == <span class="literal">NULL</span> || IsEmpty(p) == <span class="number">1</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"this stack is EMPTY !"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (temp != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; temp-&gt;data &lt;&lt; <span class="string">' '</span>;</span><br><span class="line">temp = temp-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;栈——链栈&quot;&gt;&lt;a href=&quot;#栈——链栈&quot; class=&quot;headerlink&quot; title=&quot;栈——链栈&quot;&gt;&lt;/a&gt;栈——链栈&lt;/h1&gt;&lt;h2 id=&quot;链栈&quot;&gt;&lt;a href=&quot;#链栈&quot; class=&quot;headerlink&quot; title=&quot;链栈&quot;&gt;&lt;/a&gt;链栈&lt;/h2&gt;&lt;p&gt;​        链栈是一种特殊的线性链表，使使用链式存储结构的栈，链栈也有栈顶栈底，同样是一种后进先出（LIFO）的数据结构&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的栈" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-21——合并两个有序链表</title>
    <link href="http://yoursite.com/2019/08/07/LeetCode-21%E2%80%94%E2%80%94%E5%90%88%E5%B9%B6%E4%B8%A4%E4%B8%AA%E6%9C%89%E5%BA%8F%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/08/07/LeetCode-21——合并两个有序链表/</id>
    <published>2019-08-07T07:21:19.000Z</published>
    <updated>2019-08-23T01:36:11.371Z</updated>
    
    <content type="html"><![CDATA[<h1 id="合并两个有序链表（简单）"><a href="#合并两个有序链表（简单）" class="headerlink" title="合并两个有序链表（简单）"></a>合并两个有序链表（简单）</h1><h2 id="题目要求"><a href="#题目要求" class="headerlink" title="题目要求"></a>题目要求</h2><p>将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：1-&gt;2-&gt;4, 1-&gt;3-&gt;4</span><br><span class="line">输出：1-&gt;1-&gt;2-&gt;3-&gt;4-&gt;4</span><br></pre></td></tr></table></figure><p>一个小菜鸡的菜鸡 c++ 解法，执行用时 16ms，内存消耗 9MB，还会继续探索更优化的方法和 java 语言的解法！</p><a id="more"></a><h2 id="C-递归解法"><a href="#C-递归解法" class="headerlink" title="C++递归解法"></a>C++递归解法</h2><p>​        下面是题目给出的 C++ 链表定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * Definition for singly-linked list.</span></span><br><span class="line"><span class="comment"> * struct ListNode &#123;</span></span><br><span class="line"><span class="comment"> *     int val;</span></span><br><span class="line"><span class="comment"> *     ListNode *next;</span></span><br><span class="line"><span class="comment"> *     ListNode(int x) : val(x), next(NULL) &#123;&#125;</span></span><br><span class="line"><span class="comment"> * &#125;;</span></span><br><span class="line"><span class="comment"> */</span></span><br></pre></td></tr></table></figure><h3 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h3><p>​        根据给出的题干要求，想到用递归的方法，逐个同时检测链表 l1 和 l2 中每一个数据值的大小，通过判断大小后对链表的重新排序，来得到合并后的有序链表</p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeTwoLists</span><span class="params">(ListNode* l1, ListNode* l2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l1 == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l2 == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (l1-&gt;val &lt; l2-&gt;val) &#123;</span><br><span class="line">            l1-&gt;next = mergeTwoLists(l1-&gt;next, l2);</span><br><span class="line">            <span class="keyword">return</span> l1;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            l2-&gt;next = mergeTwoLists(l1, l2-&gt;next);</span><br><span class="line">            <span class="keyword">return</span> l2;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><p>​        先分别判断两个链表是否为空，如果有一个链表为空，直接返回另一个链表就可以了。接着就到了关键的递归环节，这里对于刚传进来的 l1 和 l2 来说，都代表两个链表的第一个节点，保留含有较小的值得节点，再对该节点的 next 节点和另一个链表使用 mergeTwoLists() 函数，这样，函数就会通过不断地递归，来检测出两个链表的剩余节点中值较小的那个，最后在当一个链表已经被取空之后，函数的递归调用就会停止，从而将两个有序链表合并为一个有序链表</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;合并两个有序链表（简单）&quot;&gt;&lt;a href=&quot;#合并两个有序链表（简单）&quot; class=&quot;headerlink&quot; title=&quot;合并两个有序链表（简单）&quot;&gt;&lt;/a&gt;合并两个有序链表（简单）&lt;/h1&gt;&lt;h2 id=&quot;题目要求&quot;&gt;&lt;a href=&quot;#题目要求&quot; class=&quot;headerlink&quot; title=&quot;题目要求&quot;&gt;&lt;/a&gt;题目要求&lt;/h2&gt;&lt;p&gt;将两个有序链表合并为一个新的有序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：1-&amp;gt;2-&amp;gt;4, 1-&amp;gt;3-&amp;gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：1-&amp;gt;1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;

&lt;p&gt;一个小菜鸡的菜鸡 c++ 解法，执行用时 16ms，内存消耗 9MB，还会继续探索更优化的方法和 java 语言的解法！&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的LeetCode" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>数据结构（四）——顺序栈</title>
    <link href="http://yoursite.com/2019/08/05/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E5%9B%9B%EF%BC%89%E2%80%94%E2%80%94%E9%A1%BA%E5%BA%8F%E6%A0%88/"/>
    <id>http://yoursite.com/2019/08/05/数据结构（四）——顺序栈/</id>
    <published>2019-08-05T11:45:15.000Z</published>
    <updated>2019-08-07T06:40:32.187Z</updated>
    
    <content type="html"><![CDATA[<h1 id="栈——顺序栈"><a href="#栈——顺序栈" class="headerlink" title="栈——顺序栈"></a>栈——顺序栈</h1><h2 id="栈的概念"><a href="#栈的概念" class="headerlink" title="栈的概念"></a>栈的概念</h2><p>​        栈是只能在一端进行操作的线性表，栈顶（top）是可以进行插入（压栈）、删除（出栈）的一端，另一端则称为栈底，栈是 LIFO（后进先出）的存储结构</p><h2 id="顺序栈"><a href="#顺序栈" class="headerlink" title="顺序栈"></a>顺序栈</h2><p>​        顺序栈是通过顺序存储方式，利用一组连续的存储单元依次存放栈底到栈顶的数据元素的数据结构</p><a id="more"></a><h3 id="顺序栈的定义"><a href="#顺序栈的定义" class="headerlink" title="顺序栈的定义"></a>顺序栈的定义</h3><p>​        和顺序表的定义相似，顺序栈也通过一个数组进行数据元素的存储，不同的是顺序栈还需存放一个 top 来表示栈顶的位置</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data[MAXSIZE];</span><br><span class="line"><span class="keyword">int</span> top;</span><br><span class="line">&#125;SeqStack;</span><br></pre></td></tr></table></figure><h3 id="顺序栈的初始化"><a href="#顺序栈的初始化" class="headerlink" title="顺序栈的初始化"></a>顺序栈的初始化</h3><p>​        顺序栈的初始化实际上就是为栈分配内存，并将栈顶位置（top）赋值为 -1 的过程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">SeqStack *<span class="title">InitSeqStack</span><span class="params">()</span> </span>&#123;</span><br><span class="line">SeqStack *s;</span><br><span class="line">s = (SeqStack*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(SeqStack));</span><br><span class="line">s-&gt;top = <span class="number">-1</span>;</span><br><span class="line"><span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="判断顺序栈是否为空"><a href="#判断顺序栈是否为空" class="headerlink" title="判断顺序栈是否为空"></a>判断顺序栈是否为空</h3><p>​        判断顺序栈是否为空，只需要检测栈顶位置（top）是否为 -1</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Empty_SeqStack</span><span class="params">(SeqStack *s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s-&gt;top == <span class="number">-1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序栈入栈"><a href="#顺序栈入栈" class="headerlink" title="顺序栈入栈"></a>顺序栈入栈</h3><p>​        入栈又称压栈，顾名思义就是将数据压入栈中，原理是先检测栈是否已满，之后让栈顶指针自加 1，再令栈顶元素等于要压入的数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Push_SeqStack</span><span class="params">(SeqStack *s, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (s-&gt;top == MAXSIZE - <span class="number">1</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">s-&gt;top++;</span><br><span class="line">s-&gt;data[s-&gt;top] = d;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"压入 "</span> &lt;&lt; d &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="顺序栈出栈"><a href="#顺序栈出栈" class="headerlink" title="顺序栈出栈"></a>顺序栈出栈</h3><p>​        出栈又叫弹出，即将栈顶元素移除，可以把顺序栈想成一摞盘子，放盘子时需要把新放的盘子放在之前的盘子上，而取盘子时也要先取走后方上来的盘子，这就是 LIFO 后进先出存储结构的模型，同样的原理，出栈只需要令栈顶指针自减 1 即可，这里可以不用管原栈顶元素的值，因为在下一次压栈时，由于栈顶位置（top）已经前移，所以这个值就会被覆盖</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Pop_SeqStack</span><span class="params">(SeqStack *s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Empty_SeqStack(s))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"弹出 "</span> &lt;&lt; s-&gt;data[s-&gt;top] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">s-&gt;top--;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取栈顶元素"><a href="#获取栈顶元素" class="headerlink" title="获取栈顶元素"></a>获取栈顶元素</h3><p>​        获取栈顶元素也很好理解，就是返回当前栈顶位置（top）锁对应的数据元素的值</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Top_SeqStack</span><span class="params">(SeqStack *s)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (Empty_SeqStack(s))</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line"><span class="keyword">return</span> (s-&gt;data[s-&gt;top]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        栈就是一个只能在一端进行操作的线性表，栈的这种特性也使他具有记忆的功能</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;栈——顺序栈&quot;&gt;&lt;a href=&quot;#栈——顺序栈&quot; class=&quot;headerlink&quot; title=&quot;栈——顺序栈&quot;&gt;&lt;/a&gt;栈——顺序栈&lt;/h1&gt;&lt;h2 id=&quot;栈的概念&quot;&gt;&lt;a href=&quot;#栈的概念&quot; class=&quot;headerlink&quot; title=&quot;栈的概念&quot;&gt;&lt;/a&gt;栈的概念&lt;/h2&gt;&lt;p&gt;​        栈是只能在一端进行操作的线性表，栈顶（top）是可以进行插入（压栈）、删除（出栈）的一端，另一端则称为栈底，栈是 LIFO（后进先出）的存储结构&lt;/p&gt;
&lt;h2 id=&quot;顺序栈&quot;&gt;&lt;a href=&quot;#顺序栈&quot; class=&quot;headerlink&quot; title=&quot;顺序栈&quot;&gt;&lt;/a&gt;顺序栈&lt;/h2&gt;&lt;p&gt;​        顺序栈是通过顺序存储方式，利用一组连续的存储单元依次存放栈底到栈顶的数据元素的数据结构&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的栈" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E6%A0%88/"/>
    
  </entry>
  
  <entry>
    <title>数据结构（三）——双链表、循环链表</title>
    <link href="http://yoursite.com/2019/08/01/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%B8%89%EF%BC%89%E2%80%94%E2%80%94%E5%8F%8C%E9%93%BE%E8%A1%A8%E3%80%81%E5%BE%AA%E7%8E%AF%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/08/01/数据结构（三）——双链表、循环链表/</id>
    <published>2019-08-01T12:02:31.000Z</published>
    <updated>2019-08-07T06:40:16.768Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性表——双链表、循环链表"><a href="#线性表——双链表、循环链表" class="headerlink" title="线性表——双链表、循环链表"></a>线性表——双链表、循环链表</h1><h2 id="双链表概念"><a href="#双链表概念" class="headerlink" title="双链表概念"></a>双链表概念</h2><p>​        双链表是链表的一种，也叫双向链表，因为双链表的每个物理节点增加一个指向后继节点的指针域和一个指向前驱节点的指针域</p><h2 id="循环链表概念"><a href="#循环链表概念" class="headerlink" title="循环链表概念"></a>循环链表概念</h2><p>​        循环链表也是链表的一种，他与单链表唯一的区别就是，循环链表的最后一个节点将指向头节点</p><a id="more"></a><h3 id="双链表定义"><a href="#双链表定义" class="headerlink" title="双链表定义"></a>双链表定义</h3><p>​        根据概念不难理解，双链表即在单链表的基础上，增加一个指向前驱节点的指针域，这里用 prior 表示</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DLinkList</span>&#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">DLinkList *prior;<span class="comment">//指向前驱节点</span></span><br><span class="line">DLinkList *next;<span class="comment">//指向后继节点</span></span><br><span class="line">&#125;DLinkList;</span><br></pre></td></tr></table></figure><h3 id="头插法创建双链表"><a href="#头插法创建双链表" class="headerlink" title="头插法创建双链表"></a>头插法创建双链表</h3><p>​        头插法创建双链表的思路很简单，和单链表的思路几乎一致，不同在于除了需要不停的修改头节点的 next 指针以外，还要不断让新加入节点的前驱节点 prior 指向头节点，通过 while 循环来实现这一过程，就实现了头插法创建双链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DLinkList *<span class="title">CreateListF</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//头插法创建双链表</span></span><br><span class="line">DLinkList *L;</span><br><span class="line">L = (DLinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLinkList));</span><br><span class="line">L-&gt;prior = <span class="literal">NULL</span>;</span><br><span class="line">L-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">DLinkList *s;</span><br><span class="line"><span class="keyword">int</span> d;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入整形数据，以 0 结束"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; d;</span><br><span class="line"><span class="keyword">while</span> (d != <span class="number">0</span>) &#123;</span><br><span class="line">s = (DLinkList*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLinkList));</span><br><span class="line">s-&gt;data = d;</span><br><span class="line">s-&gt;next = L-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">L-&gt;next-&gt;prior = s;</span><br><span class="line">L-&gt;next = s;</span><br><span class="line">s-&gt;prior = L;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入下一个数据"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; d;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尾插法创建双链表"><a href="#尾插法创建双链表" class="headerlink" title="尾插法创建双链表"></a>尾插法创建双链表</h3><p>​        尾插法创建双链表也和单链表尾插法创建时的思路很像，先定义双链表的头尾两个指针，这里如果理解了单链表的尾插法，就不难理解之后通过尾指针不断“前移”（其实是通过这种方法来让新插入的节点被插入在老节点之前），实现尾插法创建双链表，并能与头节点相连</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">DLinkList *<span class="title">CreateListT</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//尾插法创建双链表</span></span><br><span class="line">DLinkList *s, *r, *L;</span><br><span class="line"><span class="keyword">int</span> d;</span><br><span class="line">L = (DLinkList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLinkList));</span><br><span class="line">r = L;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入整形数据，以 0 结束"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; d;</span><br><span class="line"><span class="keyword">while</span> (d != <span class="number">0</span>) &#123;</span><br><span class="line">s = (DLinkList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLinkList));</span><br><span class="line">s-&gt;data = d;</span><br><span class="line">r-&gt;next = s;</span><br><span class="line">s-&gt;prior = r;</span><br><span class="line">r = s;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入下一个数据"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; d;</span><br><span class="line">&#125;</span><br><span class="line">r-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">return</span> L;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双链表的插入"><a href="#双链表的插入" class="headerlink" title="双链表的插入"></a>双链表的插入</h3><p>​        双链表的插入方法要定义一个 p 节点用来查找插入位置的前一个节点，即他的直接前驱节点，再定义一个 s 节点用来存放新加的数据，通过改变 p 节点的 next 和 p-&gt;next 的 prior 来将 s 节点插入在 p 节点之后</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListInsert</span><span class="params">(DLinkList *L, <span class="keyword">int</span> pos, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">DLinkList *p = L;</span><br><span class="line">DLinkList *s;</span><br><span class="line"><span class="keyword">while</span> (i &lt; pos - <span class="number">1</span> &amp;&amp; p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">s = (DLinkList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(DLinkList));</span><br><span class="line">s-&gt;data = d;</span><br><span class="line">s-&gt;next = p-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">p-&gt;next-&gt;prior = s;</span><br><span class="line">s-&gt;prior = p;</span><br><span class="line">p-&gt;next = s;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双链表的删除"><a href="#双链表的删除" class="headerlink" title="双链表的删除"></a>双链表的删除</h3><p>​        删除操作大体上和插入操作十分相似，先查找到删除位置的直接前驱节点，先改变直接前驱节点的 next 和要删除节点的 next 的 prior 来将要删除的节点隔离，再释放掉他的资源，就删除了这个节点，这里插入和删除操作都需要注意表头和表尾的处理</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">ListDelete</span><span class="params">(DLinkList *L, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line">DLinkList *p = L;</span><br><span class="line">DLinkList *q;</span><br><span class="line"><span class="keyword">while</span> (i &lt; pos - <span class="number">1</span> &amp;&amp; p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">q = p-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (q == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">p-&gt;next = q-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;next != <span class="literal">NULL</span>)</span><br><span class="line">p-&gt;next-&gt;prior = p;</span><br><span class="line"><span class="built_in">free</span>(q);</span><br><span class="line"><span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="双链表遍历"><a href="#双链表遍历" class="headerlink" title="双链表遍历"></a>双链表遍历</h3><p>​        通过循环直接遍历双链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(DLinkList *L)</span> </span>&#123;</span><br><span class="line">DLinkList *p;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">p = L-&gt;next;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="循环链表的定义、创建、增、删、查等操作"><a href="#循环链表的定义、创建、增、删、查等操作" class="headerlink" title="循环链表的定义、创建、增、删、查等操作"></a>循环链表的定义、创建、增、删、查等操作</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LoopLinkList</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">LoopLinkList *next;</span><br><span class="line">&#125;LoopLinkList;</span><br><span class="line"><span class="comment">//创建（头插）</span></span><br><span class="line"><span class="function">LoopLinkList *<span class="title">CreateLoopList</span><span class="params">()</span> </span>&#123;</span><br><span class="line">LoopLinkList *head, *p;</span><br><span class="line"><span class="keyword">int</span> d;</span><br><span class="line">head = (LoopLinkList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LoopLinkList));</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入数据，0结束"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; d;</span><br><span class="line"><span class="keyword">while</span> (d != <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (head-&gt;next == <span class="literal">NULL</span>) &#123;</span><br><span class="line">p = (LoopLinkList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LoopLinkList));</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">p-&gt;data = d;</span><br><span class="line">head-&gt;next = p;</span><br><span class="line">p-&gt;next = head;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">p = (LoopLinkList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LoopLinkList));</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">p-&gt;data = d;</span><br><span class="line">p-&gt;next = head-&gt;next;</span><br><span class="line">head-&gt;next = p;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; d;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//插入节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertList</span><span class="params">(LoopLinkList *head, <span class="keyword">int</span> pos, <span class="keyword">int</span> d)</span> </span>&#123;</span><br><span class="line">LoopLinkList *p = head;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; pos - <span class="number">1</span> &amp;&amp; p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">LoopLinkList *r;</span><br><span class="line">r = (LoopLinkList *)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(LoopLinkList));</span><br><span class="line">r-&gt;data = d;</span><br><span class="line">r-&gt;next = p-&gt;next;</span><br><span class="line">p-&gt;next = r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//删除节点</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DeleteList</span><span class="params">(LoopLinkList *head, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">LoopLinkList *p = head;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; pos - <span class="number">1</span> &amp;&amp; p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">LoopLinkList *r;</span><br><span class="line">r = p-&gt;next;</span><br><span class="line">p-&gt;next = r-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(r);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//查找节点</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">SearchList</span><span class="params">(LoopLinkList *head, <span class="keyword">int</span> pos)</span> </span>&#123;</span><br><span class="line">LoopLinkList *p = head;</span><br><span class="line"><span class="keyword">int</span> i = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; pos - <span class="number">1</span> &amp;&amp; p != <span class="literal">NULL</span>) &#123;</span><br><span class="line">i++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"><span class="keyword">return</span> p-&gt;next-&gt;data;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//输出循环链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PrintList</span><span class="params">(LoopLinkList *L)</span> </span>&#123;</span><br><span class="line">LoopLinkList *p;</span><br><span class="line"><span class="keyword">if</span> (L-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">p = L-&gt;next;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"数据如下"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;data == <span class="number">-842150451</span>)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线性表——双链表、循环链表&quot;&gt;&lt;a href=&quot;#线性表——双链表、循环链表&quot; class=&quot;headerlink&quot; title=&quot;线性表——双链表、循环链表&quot;&gt;&lt;/a&gt;线性表——双链表、循环链表&lt;/h1&gt;&lt;h2 id=&quot;双链表概念&quot;&gt;&lt;a href=&quot;#双链表概念&quot; class=&quot;headerlink&quot; title=&quot;双链表概念&quot;&gt;&lt;/a&gt;双链表概念&lt;/h2&gt;&lt;p&gt;​        双链表是链表的一种，也叫双向链表，因为双链表的每个物理节点增加一个指向后继节点的指针域和一个指向前驱节点的指针域&lt;/p&gt;
&lt;h2 id=&quot;循环链表概念&quot;&gt;&lt;a href=&quot;#循环链表概念&quot; class=&quot;headerlink&quot; title=&quot;循环链表概念&quot;&gt;&lt;/a&gt;循环链表概念&lt;/h2&gt;&lt;p&gt;​        循环链表也是链表的一种，他与单链表唯一的区别就是，循环链表的最后一个节点将指向头节点&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的线性表" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>数据结构（二）——单链表</title>
    <link href="http://yoursite.com/2019/07/25/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%EF%BC%88%E4%BA%8C%EF%BC%89%E2%80%94%E2%80%94%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2019/07/25/数据结构（二）——单链表/</id>
    <published>2019-07-25T07:33:21.000Z</published>
    <updated>2019-08-07T06:43:06.872Z</updated>
    
    <content type="html"><![CDATA[<h1 id="线性表——单链表"><a href="#线性表——单链表" class="headerlink" title="线性表——单链表"></a>线性表——单链表</h1><h2 id="单链表概念"><a href="#单链表概念" class="headerlink" title="单链表概念"></a>单链表概念</h2><p>​        单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。链式存储不仅需要存储元素本身，还要存储一个指向其后继元素的地址，这种存储结构也被称为 node，存储数据的叫数据域，存储地址的叫指针域。</p><a id="more"></a><h3 id="单链表定义"><a href="#单链表定义" class="headerlink" title="单链表定义"></a>单链表定义</h3><p>​        链式存储结构需要存放数据的数据域和存放后继节点地址的指针域，所以在定义单链表时需要如下定义</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">Node</span> &#123;</span></span><br><span class="line"><span class="keyword">int</span> data;</span><br><span class="line">Node* next;</span><br><span class="line">&#125;ListNode, LinkList;</span><br></pre></td></tr></table></figure><h3 id="单链表的创建"><a href="#单链表的创建" class="headerlink" title="单链表的创建"></a>单链表的创建</h3><p>​        单链表的创建从新插入的元素位置的不同分为头插法和尾插法</p><h4 id="头插法创建单链表"><a href="#头插法创建单链表" class="headerlink" title="头插法创建单链表"></a>头插法创建单链表</h4><p>​        头插法创建单链表即新插入的元素每次都会作为头指针 head 的后继节点，这样创建单链表时，每次插入新元素只需要修改 head 的指针，再让新节点的 next 指向原 head 指向的节点便可</p><p>​        具体的过程为：先为 head 节点和即将作为下一节点的 p 节点分配内存，再为 p 节点的数据域赋值，将 head 原本的 next 指针的值赋值给 p 的 next，再让 head 的 next 指向 p，这样就实现了在 head 后和上一次插入的节点前插入新节点的操作，使用 while 循环循环执行为 p 分配存储空间及其之后的代码，就实现了头插法创建单链表的过程</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">Creat_LinkList</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//头插法建立单链表</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">ListNode *head, *p;</span><br><span class="line">head = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入要录入的数以0结尾"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">index++;</span><br><span class="line"><span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">p = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br><span class="line">p-&gt;data = x;</span><br><span class="line">p-&gt;next = head-&gt;next;</span><br><span class="line">head-&gt;next = p;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"第% "</span> &lt;&lt; index &lt;&lt; <span class="string">" %次输入："</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="尾插法创建单链表"><a href="#尾插法创建单链表" class="headerlink" title="尾插法创建单链表"></a>尾插法创建单链表</h4><p>​        尾插法创建单链表实际上就是头插法的反向方法，即每次新插入的节点都会被上一次插入的节点的 next 所指向，节点会按照输入的顺序一个一个添加在上一个结点之后</p><p>​        具体的过程为：先为头节点分配存储空间，然后将头节点的地址赋值给尾节点，这样在没进行其他操作之前，可以说头节点和尾节点是相同的，然后定义 p 节点并为其赋值，令当前的尾节点（第一次循环时尾节点就是头节点，之后的每次循环尾节点都会进行后移，所以每次插入新节点都可以想象成在头节点之后的最新节点和尾节点前添加）指向新节点，再将新节点赋值给尾节点，这里就是尾节点的后移，再令尾节点的 next 指向空，循环这部分的操作就实现了尾插法创建单链表</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">Creat_LinkList_R</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="comment">//尾插法建立单链表</span></span><br><span class="line"><span class="keyword">int</span> x;</span><br><span class="line">ListNode *head, *p, *tail;</span><br><span class="line">head = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line"><span class="keyword">if</span> (head == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">head-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">tail = head;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"输入要录入的数以0结尾"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="keyword">while</span> (x != <span class="number">0</span>) &#123;</span><br><span class="line">p = (ListNode*)<span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(ListNode));</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>)</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">p-&gt;data = x;</span><br><span class="line">tail-&gt;next = p;</span><br><span class="line">tail = p;</span><br><span class="line">tail-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###打印单链表</p><p>​        打印单链表的操作十分简单，传入头节点地址，定义一个当前节点位置的 p 节点，通过循环让 p 不停后移来获取每个节点中存放的数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Print_List</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">1</span>;</span><br><span class="line">ListNode *p = head-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (p == <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"第% "</span> &lt;&lt; index &lt;&lt; <span class="string">" %个元素是："</span>  &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###获取单链表长度</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Length_List</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line">ListNode *p = head;</span><br><span class="line"><span class="keyword">while</span> (p-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">num++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> num;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###按照索引查找元素</p><p>​        原理同获取单链表长度的原理接近，先通过计数器 num 将当前节点 p 移动到索引 i 的位置，再获取当前节点 p 中存放的数据</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">ListNode *<span class="title">GetD_index</span><span class="params">(ListNode *head, <span class="keyword">int</span> i)</span> </span>&#123;</span><br><span class="line"><span class="comment">//按照索引查找链表元素</span></span><br><span class="line">ListNode *p = head;</span><br><span class="line"><span class="keyword">int</span> num = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">if</span> (i &lt; <span class="number">0</span>) &#123;</span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> ((p-&gt;next != <span class="literal">NULL</span>) &amp;&amp; (num &lt; i)) &#123;</span><br><span class="line">num++;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">if</span> (num == i) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"查找的元素是："</span> &lt;&lt; p-&gt;data &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> p;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line"><span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###按照元素值查找元素</p><p>​        通过元素值查找链表中的数据也是需要通过当前节点 p 的不断后移，不停的取出每一个节点中的数据与目标值进行比较，直到找到值或者移动到了链表的结束</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">GetD_data</span><span class="params">(ListNode *head, <span class="keyword">int</span> data)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//按照元素值查找链表元素</span></span><br><span class="line">ListNode *p = head;</span><br><span class="line"><span class="keyword">int</span> index = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">while</span> (p != <span class="literal">NULL</span>) &#123;</span><br><span class="line"><span class="keyword">if</span> (p-&gt;data == data) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"查询到该元素，位置为% "</span> &lt;&lt; index &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">p = p-&gt;next;</span><br><span class="line">index++;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>###删除后继节点</p><p>​        先令 r = p-&gt;next，再让 p-&gt;next 指向 r-&gt;next，这样就已经将 p 的后继节点从链表中摘除了，最后释放 r 的资源就完成了后继节点的删除操作</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">DeleteAfter_LinkList</span><span class="params">(ListNode *p)</span> </span>&#123;</span><br><span class="line"><span class="comment">//删除后继节点</span></span><br><span class="line">ListNode *r;</span><br><span class="line"><span class="keyword">if</span> (!p)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">r = p-&gt;next;</span><br><span class="line"><span class="keyword">if</span> (!r)</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">p-&gt;next = r-&gt;next;</span><br><span class="line"><span class="built_in">free</span>(r);</span><br><span class="line"><span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>（一）从存储结构上来说，顺序表存放在一串连续的地址中，而链表的每个节点的存储位置都是随机的，所以对链表进行插入、删除操作时的时间复杂度为 O(1)，但是查找时需要 O(n)，相反的，顺序表需要平均遍历一半的数据才能完成相同的插入、删除操作，复杂度为 O(n)，但是查找却为 O(1)</p><p>（二）从存储空间上说，顺序表需要预先分配好全部的存储空间，这样会造成资源的浪费或者不足等问题，而链表可以随用随分配，便捷的增删操作可以快速的为新节点分配存储空间</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;线性表——单链表&quot;&gt;&lt;a href=&quot;#线性表——单链表&quot; class=&quot;headerlink&quot; title=&quot;线性表——单链表&quot;&gt;&lt;/a&gt;线性表——单链表&lt;/h1&gt;&lt;h2 id=&quot;单链表概念&quot;&gt;&lt;a href=&quot;#单链表概念&quot; class=&quot;headerlink&quot; title=&quot;单链表概念&quot;&gt;&lt;/a&gt;单链表概念&lt;/h2&gt;&lt;p&gt;​        单链表是一种链式存取的数据结构，用一组地址任意的存储单元存放线性表中的数据元素。链式存储不仅需要存储元素本身，还要存储一个指向其后继元素的地址，这种存储结构也被称为 node，存储数据的叫数据域，存储地址的叫指针域。&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的线性表" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%BA%BF%E6%80%A7%E8%A1%A8/"/>
    
  </entry>
  
</feed>
