<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Step By Step</title>
  
  <subtitle>耀出千分光</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-06T15:31:58.236Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LiMinghui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Python——NumPy安装、NdArray对象的简单使用、NumPy的数据类型</title>
    <link href="http://yoursite.com/2020/02/06/Python%E2%80%94%E2%80%94NumPy%E5%AE%89%E8%A3%85%E3%80%81NdArray%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E3%80%81NumPy%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/02/06/Python——NumPy安装、NdArray对象的简单使用、NumPy的数据类型/</id>
    <published>2020-02-06T15:30:33.000Z</published>
    <updated>2020-02-06T15:31:58.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-NumPy"><a href="#什么是-NumPy" class="headerlink" title="什么是 NumPy"></a>什么是 NumPy</h1><blockquote><p>NumPy 是一个用 python 实现的科学计算，包括：1、一个强大的 N 维数组对象 Array；2、比较成熟的（广播）函数库；3、用于整合 C/C++ 和 Fortran 代码的工具包；4、实用的线性代数、傅里叶变换和随机数生成函数，numpy 和稀疏矩阵运算包scipy配合使用更加方便</p><p>​        NumPy（Numeric Python）提供了许多高级的数值编程工具，如：矩阵数据类型、矢量处理，以及精密的运算库，专为进行严格的数字处理而产生，多为很多大型金融公司使用，以及核心的科学计算组织如：Lawrence Livermore， NASA 用其处理一些本来使用 C++，Fortran 或 MatLab 等所做的任务</p></blockquote><a id="more"></a><h2 id="安装-NumPy"><a href="#安装-NumPy" class="headerlink" title="安装 NumPy"></a>安装 NumPy</h2><p>​        在 windows 下，推荐使用下载 Python 发行版的方式，它会包含很多关键的包，比如<code>NumPy</code>、<code>Pandas</code>等</p><p>​        我选择的是<code>ANACONDA</code>，可以直接百度搜索到官网下载，但是会很慢，可以在清华大学开源镜像站下载，连接是</p><blockquote><p><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a></p></blockquote><p>​        下载安装后，系统就已经拥有 NumPy 包了</p><p>​        也可以使用 PIP 命令直接安装</p><h3 id="导入-NumPy"><a href="#导入-NumPy" class="headerlink" title="导入 NumPy"></a>导入 NumPy</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><p>​        上边的代码是向程序中导入 NumPy 库，如果导入成功，也就说明 NumPy 库安装成功了</p><h2 id="NumPy-中的-NdArray-对象"><a href="#NumPy-中的-NdArray-对象" class="headerlink" title="NumPy 中的 NdArray 对象"></a>NumPy 中的 NdArray 对象</h2><p>​        NumPy 最最最重要的特点就是它所包含的多维数组对象：<code>ndarray</code>，它是用于存放同类元素的多维数组</p><h3 id="NdArray-的使用"><a href="#NdArray-的使用" class="headerlink" title="NdArray 的使用"></a>NdArray 的使用</h3><h4 id="创建一个-NdArray-对象"><a href="#创建一个-NdArray-对象" class="headerlink" title="创建一个 NdArray 对象"></a>创建一个 NdArray 对象</h4><p>​        <code>ndarray</code>数组可以直接通过<code>numpy.array(object, dtype = None, copy = True, order = None, subok = False, nfmin = 0)</code>方法来创建，下面说一下<code>ndarray</code>的重要参数</p><ul><li>object：数组或嵌套数列</li><li>dtype：数组元素的数据类型，可选</li><li>copy：对象是否需要复制，可选</li><li>order：创建数组呃样式，C 为行方向，F 为列方向，A 为任意方向（默认）</li><li>subok：默认返回一个与基类类型一致的数组</li><li>ndmin：指定生成数组的最小维度</li></ul><p>​        下面是一个创建多维数组的简单示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array(</span><br><span class="line">    [</span><br><span class="line">        [</span><br><span class="line">            [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">            [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">            [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">        ],</span><br><span class="line">        [</span><br><span class="line">            [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">            [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">            [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">        ]</span><br><span class="line">    ]，</span><br><span class="line">    dtype=np.int</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="NumPy-中的数据类型"><a href="#NumPy-中的数据类型" class="headerlink" title="NumPy 中的数据类型"></a>NumPy 中的数据类型</h2><p>​        <code>numpy</code>支持的数据类型比<code>Python</code>内置的数据类型多得多，如下表：</p><table><thead><tr><th align="center">数据类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">bool_</td><td align="center">布尔型数据类型（True 或 False）</td></tr><tr><td align="center">int_</td><td align="center">默认的整数类型（类似于 C 语言中的 long）</td></tr><tr><td align="center">intc</td><td align="center">同 C 语言中的 int 类型一样</td></tr><tr><td align="center">intp</td><td align="center">用于索引的整数类型</td></tr><tr><td align="center">int8</td><td align="center">字节（-128 to 127）</td></tr><tr><td align="center">int16</td><td align="center">整数（-32768 to 32767）</td></tr><tr><td align="center">int32</td><td align="center">整数（-2147483648 to 2147483647）</td></tr><tr><td align="center">int64</td><td align="center">整数（-9223372036854775808 to 9223372036854775807）</td></tr><tr><td align="center">uint8</td><td align="center">无符号整数（0 to 255）</td></tr><tr><td align="center">uint16</td><td align="center">无符号整数（0 to 65535）</td></tr><tr><td align="center">uint32</td><td align="center">无符号整数（0 to 4294967295）</td></tr><tr><td align="center">uint64</td><td align="center">无符号整数（0 to 18446744073709551615）</td></tr><tr><td align="center">float_</td><td align="center">float64 类型的简写</td></tr><tr><td align="center">float16</td><td align="center">半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位</td></tr><tr><td align="center">float32</td><td align="center">单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位</td></tr><tr><td align="center">float64</td><td align="center">双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位</td></tr><tr><td align="center">complex_</td><td align="center">complex128 类型的简写，即 128 位复数</td></tr><tr><td align="center">complex64</td><td align="center">复数，表示双 32 位浮点数（实数部分和虚数部分）</td></tr><tr><td align="center">complex128</td><td align="center">复数，表示双 64 位浮点数（实数部分和虚数部分）</td></tr></tbody></table><p>​        并且，在<code>numpy</code>中，每个内建类型都有一个唯一定义的字符代码：</p><table><thead><tr><th align="center">字符</th><th align="center">对应类型</th></tr></thead><tbody><tr><td align="center">b</td><td align="center">布尔型</td></tr><tr><td align="center">i</td><td align="center">(有符号) 整型</td></tr><tr><td align="center">u</td><td align="center">无符号整型 integer</td></tr><tr><td align="center">f</td><td align="center">浮点型</td></tr><tr><td align="center">c</td><td align="center">复数浮点型</td></tr><tr><td align="center">m</td><td align="center">timedelta（时间间隔）</td></tr><tr><td align="center">M</td><td align="center">datetime（日期时间）</td></tr><tr><td align="center">O</td><td align="center">(Python) 对象</td></tr><tr><td align="center">S, a</td><td align="center">(byte-)字符串</td></tr><tr><td align="center">U</td><td align="center">Unicode</td></tr><tr><td align="center">V</td><td align="center">原始数据 (void)</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是-NumPy&quot;&gt;&lt;a href=&quot;#什么是-NumPy&quot; class=&quot;headerlink&quot; title=&quot;什么是 NumPy&quot;&gt;&lt;/a&gt;什么是 NumPy&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;NumPy 是一个用 python 实现的科学计算，包括：1、一个强大的 N 维数组对象 Array；2、比较成熟的（广播）函数库；3、用于整合 C/C++ 和 Fortran 代码的工具包；4、实用的线性代数、傅里叶变换和随机数生成函数，numpy 和稀疏矩阵运算包scipy配合使用更加方便&lt;/p&gt;
&lt;p&gt;​        NumPy（Numeric Python）提供了许多高级的数值编程工具，如：矩阵数据类型、矢量处理，以及精密的运算库，专为进行严格的数字处理而产生，多为很多大型金融公司使用，以及核心的科学计算组织如：Lawrence Livermore， NASA 用其处理一些本来使用 C++，Fortran 或 MatLab 等所做的任务&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="李明徽的Python" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84Python/"/>
    
  </entry>
  
  <entry>
    <title>Python——生产者消费者问题、死锁、同步和异步</title>
    <link href="http://yoursite.com/2020/02/05/Python%E2%80%94%E2%80%94%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E3%80%81%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5/"/>
    <id>http://yoursite.com/2020/02/05/Python——生产者消费者问题、同步和异步/</id>
    <published>2020-02-05T09:07:58.000Z</published>
    <updated>2020-02-05T10:39:17.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程产生的问题"><a href="#多线程产生的问题" class="headerlink" title="多线程产生的问题"></a>多线程产生的问题</h1><p>​        并发编程由于需要很多线程、进程之间的协作，所以很容易出现问题，下面主要介绍生产者与消费者问题、死锁问题、同步和异步问题</p><a id="more"></a><h2 id="生产者与消费者问题"><a href="#生产者与消费者问题" class="headerlink" title="生产者与消费者问题"></a>生产者与消费者问题</h2><p>​        当我们进行一个任务，需要两个线程不断地获取和操作数据时，可能会产生一个问题，如果数据获取很快，而操作很慢，那么获取数据的线程就必须等待操作数据的线程处理完毕，反之如果数据获取的很慢而操作的很快，那么操作数据的线程就必须等待获取数据的线程，这种问题可以看作是一种生产消费能力的不平衡，称之为生产者与消费者问题</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>​        解决这种生产消费能力不平衡的方法就是，在在生产者和消费者中间设立一个缓冲机制，生产者将生产的数据放入缓冲池中，消费者从缓冲池中取出数据进行处理，当缓冲池中的数据量小于一定的值时，生产者就会向缓冲池中添加数据，而当缓冲池中数据大于一个值时，消费者就会从缓冲池中取出数据，使生产者和消费者达到一种动态的平衡</p><p>​        实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> Queue</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> queue.qsize() &lt; <span class="number">1000</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    msg = <span class="string">'Pro '</span> + str(count)</span><br><span class="line">                    queue.put(msg)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> queue</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> queue.qsize() &gt; <span class="number">100</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                    msg = self.name + <span class="string">'Spend '</span> + queue.get()</span><br><span class="line">                    print(msg)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    queue = Queue()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">500</span>):</span><br><span class="line">        queue.put(<span class="string">'Start Pro '</span> + str(i))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        p = Producer()</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        c = Consumer()</span><br><span class="line">        c.start()</span><br></pre></td></tr></table></figure><p>​        运行结果（截取）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread-7Spend Start Pro 494</span><br><span class="line">Thread-3Spend Start Pro 495</span><br><span class="line">Thread-5Spend Start Pro 496</span><br><span class="line">Thread-5Spend Start Pro 498</span><br><span class="line">Thread-5Spend Start Pro 499</span><br><span class="line">Thread-3Spend Start Pro 497</span><br><span class="line">Thread-3Spend Pro 1</span><br><span class="line">Thread-4Spend Pro 2</span><br><span class="line">Thread-4Spend Pro 3</span><br><span class="line">Thread-4Spend Pro 4</span><br><span class="line">Thread-6Spend Pro 5</span><br><span class="line">Thread-6Spend Pro 6</span><br></pre></td></tr></table></figure><h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><p>​        在多线程中，线程可以通过互斥锁来保证对同一资源的唯一占有，但当程序变得复杂后，可能会出现线程 A 对资源 A 上了锁，而线程 A 后边需要用到资源 B，使用完毕后才会对资源 A解锁，而线程 B 对资源 B 上了锁，它后边选要用到资源 A，用过后才会给 B 解锁，如果线程 A 和线程 B 同时运行，就可能会造成一种情况：线程 A 在等待线程 B 解锁，线程 B 也在等待线程 A 解锁，这就是死锁问题</p><h3 id="死锁模拟"><a href="#死锁模拟" class="headerlink" title="死锁模拟"></a>死锁模拟</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThraed1</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> mutexA.acquire():</span><br><span class="line">            print(self.name + <span class="string">'----do 1----up----'</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> mutexB.acquire():</span><br><span class="line">                print(self.name + <span class="string">'----do 1----down----'</span>)</span><br><span class="line">                mutexB.release()</span><br><span class="line">            mutexA.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> mutexB.acquire():</span><br><span class="line">            print(self.name + <span class="string">'----d0 2----up----'</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> mutexA.acquire():</span><br><span class="line">                print(<span class="string">'----do 2----down----'</span>)</span><br><span class="line">                mutexA.release()</span><br><span class="line">            mutexB.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mutexA = threading.Lock()</span><br><span class="line">mutexB = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t1 = MyThraed1()</span><br><span class="line">    t2 = MyThread2()</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure><p>​        以上代码运行后，毫无疑问会产生死锁问题，结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread-1----do 1----up----</span><br><span class="line">Thread-2----d0 2----up----</span><br></pre></td></tr></table></figure><p>​        程序由于三个线程都在等待对方释放资源而卡住了</p><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p>​        死锁问题应该尽量在设计程序时避免，或添加等待超时时间，从而检测程序是否产生了死锁，另一种就是通过银行家算法也可以避免死锁问题</p><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p>​        银行家算法的思想就是，假设银行有 10 元，这个时候有三个人提出贷款，A 要贷款 9 元，B 要贷款 3 元，C 要贷款 8 元，这时，银行肯定不够将所有人都满足，银行家算法就诞生了</p><p>​        这时银行为了留住所有客户并且保证自己的钱不会不足，便分批贷款给客户，先借给 A 2 元、B 2 元、C 4 元，银行还剩 2 元，此时 B 直需要再借 1 元就满足了他自己的需求，银行便借给他 1 元，自己剩 1 元，当 B 用完，将 3 元还给银行后，银行再将这 4 元借给 C，C 也就满足了，等 C 还款后，再将 8 元中的 7 元借给 A，这样便动态的满足了三个客户的需求</p><p>​        银行家算法在程序中实际上也是模拟了银行贷款的过程，操作系统会动态的向各个线程分配资源，在分配前，系统会判断分配后会不会导致系统进入不安全状态，不会就分配资源给线程，会则令线程等待</p><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>​        同步和异步是并发编程下的两种重要的状态</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>​        同步是指当程序 A 调用程序 B 时，程序 A 停下不动，等待程序 B 完成后再继续运行</p><p>​        举个例子就是，假设 A 喊 B 出去吃饭，B 说等我写完代码再去，A 就一直在原地等着 B，这就是同步</p><p>​        归根结底，同步实现的就是一种顺序的运行</p><h4 id="使用互斥锁实现线程同步"><a href="#使用互斥锁实现线程同步" class="headerlink" title="使用互斥锁实现线程同步"></a>使用互斥锁实现线程同步</h4><p>​        代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task1</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> lock1.acquire():</span><br><span class="line">                print(<span class="string">'-----Task 1-----'</span>)</span><br><span class="line">                sleep(<span class="number">0.5</span>)</span><br><span class="line">                lock2.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task2</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> lock2.acquire():</span><br><span class="line">                print(<span class="string">'-----Task 2-----'</span>)</span><br><span class="line">                sleep(<span class="number">0.5</span>)</span><br><span class="line">                lock3.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task3</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> lock3.acquire():</span><br><span class="line">                print(<span class="string">'-----Task 3-----'</span>)</span><br><span class="line">                sleep(<span class="number">0.5</span>)</span><br><span class="line">                lock1.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lock1 = Lock()</span><br><span class="line"></span><br><span class="line">lock2 = Lock()</span><br><span class="line">lock2.acquire()</span><br><span class="line"></span><br><span class="line">lock3 = Lock()</span><br><span class="line">lock3.acquire()</span><br><span class="line"></span><br><span class="line">t1 = Task1()</span><br><span class="line">t2 = Task2()</span><br><span class="line">t3 = Task3()</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t3.start()</span><br></pre></td></tr></table></figure><p>​        运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-----Task 1-----</span><br><span class="line">-----Task 2-----</span><br><span class="line">-----Task 3-----</span><br><span class="line">-----Task 1-----</span><br><span class="line">-----Task 2-----</span><br><span class="line">-----Task 3-----</span><br></pre></td></tr></table></figure><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>​        反之，异步是指当程序 A 调用程序 B 后，A 不会等到 B 执行完再运行，而是继续向下运行自己的程序</p><p>​        举个例子就是，A 还是叫 B 去吃饭，B 依然说敲完代码再去，这时 A 没有等 B，而是去做自己的事情，等 B 敲完代码，两个再一起去吃饭</p><h4 id="使用进程池实现进程异步"><a href="#使用进程池实现进程异步" class="headerlink" title="使用进程池实现进程异步"></a>使用进程池实现进程异步</h4><p>​        代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'-----Process in Pool----- pid = %d, ppid = %d'</span> % (os.getpid(), os.getppid()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        print(<span class="string">'----%d----'</span> % i)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hahah'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">(args)</span>:</span></span><br><span class="line">    print(<span class="string">'---callback func---- pid = %d'</span> % os.getpid())</span><br><span class="line">    print(<span class="string">'---callback func---- args = %s'</span> % args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pool = Pool(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">pool.apply_async(func=test, callback=test2)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'----mainProcess pid = %d----'</span> % os.getpid())</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-----Process in Pool----- pid = 6027, ppid = 6025</span><br><span class="line">----0----</span><br><span class="line">----1----</span><br><span class="line">----2----</span><br><span class="line">---callback func---- pid = 6025</span><br><span class="line">---callback func---- args = hahah</span><br><span class="line">----mainProcess pid = 6025----</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;多线程产生的问题&quot;&gt;&lt;a href=&quot;#多线程产生的问题&quot; class=&quot;headerlink&quot; title=&quot;多线程产生的问题&quot;&gt;&lt;/a&gt;多线程产生的问题&lt;/h1&gt;&lt;p&gt;​        并发编程由于需要很多线程、进程之间的协作，所以很容易出现问题，下面主要介绍生产者与消费者问题、死锁问题、同步和异步问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的Python" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84Python/"/>
    
  </entry>
  
  <entry>
    <title>Python——多线程以及多线程会产生的一些问题</title>
    <link href="http://yoursite.com/2020/02/04/Python%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%9A%E4%BA%A7%E7%94%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/02/04/Python——多线程以及多线程会产生的一些问题/</id>
    <published>2020-02-04T13:35:59.000Z</published>
    <updated>2020-02-04T14:39:45.183Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-中的多线程"><a href="#Python-中的多线程" class="headerlink" title="Python 中的多线程"></a>Python 中的多线程</h1><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>​        一个进程中包括多个线程，线程是 CPU 调度和分派的基本单位，是进程中执行运算的最小单位，真正在 CPU 上运行的是线程，可以与同一个进程中的其他线程共享进程的全部资源</p><a id="more"></a><h2 id="Python-中实现多线程"><a href="#Python-中实现多线程" class="headerlink" title="Python 中实现多线程"></a>Python 中实现多线程</h2><p>​        Python 中有两种方式床架多线程，一种是调用底层的 <code>thread</code>模块（Python3 中已弃用），另一种是使用<code>threading</code>模块，下面我说的也是使用这个模块实现多线程的方法</p><p>​        从形式上将，多线程的实现和多进程的实现十分类似，<code>threading</code>模块提供了<code>Thread</code>类来创建线程，同<code>Process</code>类一样，我们可以通过直接调用或创建子类来继承这两种方式来创建线程</p><h3 id="使用-Thread-实现多线程"><a href="#使用-Thread-实现多线程" class="headerlink" title="使用 Thread 实现多线程"></a>使用 Thread 实现多线程</h3><p>​        直接调用<code>threading</code>，模块的<code>Thread</code>类来创建线程十分简单，使用<code>threading.Thread([target], [(item1, item2, ...)])</code>方法，<code>target</code>为目标函数名称（如果有目标函数的话），后边为参数元组，用来传递函数参数</p><p>​        线程创建好后，调用<code>Thread.start()</code>方法，就可以运行线程，如果没有目标函数，<code>start()</code>会自动执行<code>Thread</code>类中的<code>run()</code>方法，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saySorry</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">'I am sorry'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(<span class="string">'create %i Thread'</span> % i)</span><br><span class="line">        t = threading.Thread(target=saySorry)</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create 0 Thread</span><br><span class="line">create 1 Thread</span><br><span class="line">create 2 Thread</span><br><span class="line">create 3 Thread</span><br><span class="line">create 4 Thread</span><br><span class="line">I am sorry</span><br><span class="line">I am sorry</span><br><span class="line">I am sorry</span><br><span class="line">I am sorry</span><br><span class="line">I am sorry</span><br></pre></td></tr></table></figure><p>​        上边的程序也证明了，程序在创建了子线程后，不会等待线程执行完毕，而是会继续向下执行，而当主程序全部执行完毕后，却会等待所有子线程执行完毕再结束，这点和进程有些区别</p><h3 id="继承-Thread-实现多线程"><a href="#继承-Thread-实现多线程" class="headerlink" title="继承 Thread 实现多线程"></a>继承 Thread 实现多线程</h3><p>​        另外一种方式是通过创建继承<code>Thread</code>类的子类来实现多线程，这样做的好处就是可以将线程要运行的代码全部放入<code>run</code>函数中，用起来更方便，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            msg = <span class="string">'I am '</span> + self.name + <span class="string">' @ '</span> + str(i)</span><br><span class="line">            print(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t = MyThread()</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I am Thread-1 @ 0</span><br><span class="line">I am Thread-1 @ 1</span><br><span class="line">I am Thread-1 @ 2</span><br></pre></td></tr></table></figure><h2 id="Python-多线程中全局变量和非全局变量的使用问题"><a href="#Python-多线程中全局变量和非全局变量的使用问题" class="headerlink" title="Python 多线程中全局变量和非全局变量的使用问题"></a>Python 多线程中全局变量和非全局变量的使用问题</h2><p>​        开始就说过，线程可以和同一个进程中的其他线程共享进程的全部资源，那么在多线程程序中，各线程对全局变量和非全局变量的使用到底是怎样的呢</p><h3 id="非全局变量"><a href="#非全局变量" class="headerlink" title="非全局变量"></a>非全局变量</h3><p>​        非全局变量在多线程中是不会被共享的，这就像是假设有一个存在局部变量<code>a</code>的函数，当程序调用两次这个函数时，每次调用所产生的局部变量<code>a</code>都是一个新的变量，不会受另一个函数执行的干扰，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    str = threading.current_thread().name</span><br><span class="line">    g_num = <span class="number">100</span></span><br><span class="line">    <span class="keyword">if</span> str == <span class="string">'Thread-1'</span>:</span><br><span class="line">        print(str)</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(str)</span><br><span class="line">        g_num -= <span class="number">1</span></span><br><span class="line">    print(<span class="string">'-----test1----- g_num = %d'</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = Thread(target=test1)</span><br><span class="line">p1.start()</span><br><span class="line"></span><br><span class="line">p2 = Thread(target=test1)</span><br><span class="line">p2.start()</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread-1</span><br><span class="line">-----test1----- g_num = 101</span><br><span class="line">Thread-2</span><br><span class="line">-----test1----- g_num = 99</span><br></pre></td></tr></table></figure><p>​        可以看到，局部变量<code>g_num</code>并不会因为另一个线程中的同名函数而收到影响</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>​        在多线程中，全局变量是可以在各线程间共享的，这也就是说，线程间通信不需要通过管道、内存映射等方法，只需要使用一个全局变量（同一个进程中的共享资源）便可以，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">g_flag = <span class="number">0</span></span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"---test1--- g_num = %d"</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"---test2--- g_num = %d "</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = Thread(target=test1)</span><br><span class="line">p1.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p2 = Thread(target=test2)</span><br><span class="line">p2.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"---g_num= %d ---"</span> % g_num)</span><br></pre></td></tr></table></figure><p>​        运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---g_num= 372639 ---</span><br><span class="line">---test1--- g_num = 1456098</span><br><span class="line">---test2--- g_num = 1596586</span><br></pre></td></tr></table></figure><p>​        到这里，我们可以发现一个问题，正常来讲，<code>g_num</code>最后的值不应给是<code>2000000</code>吗，为什么不是呢？这就是多线程使用全局变量时有可能出现的 bug，请继续阅读！</p><h2 id="Python-多线程中如何防止使用全局变量出现-bug（轮询和互斥锁）"><a href="#Python-多线程中如何防止使用全局变量出现-bug（轮询和互斥锁）" class="headerlink" title="Python 多线程中如何防止使用全局变量出现 bug（轮询和互斥锁）"></a>Python 多线程中如何防止使用全局变量出现 bug（轮询和互斥锁）</h2><p>​        通过刚才在多线程中使用全局变量我们发现，当代码逻辑稍微复杂一些时，在两个线程中同时使用一个全局变量会出现问题，是什么导致了这个问题呢？</p><p>​        从代码中我们可以发现<code>g_num += 1</code>这句代码，实际上是<code>g_num + 1</code>和将其结果赋给<code>g_num</code>两步，正是因为这连续的两次对全局变量的操作造成了这个问题</p><p>​        当一个线程执行到<code>g_num + 1</code>这步后，cpu 有可能会转头去处理另一个线程，另一个线程也运行了<code>g_num + 1</code>，当 cpu 再回头执行第一个线程时，<code>g_num</code> 已经不止被运算过一次了</p><p>​        那么怎么避免这样的情况发生呢，只能是如果存在对全局变量变量值的修改时，我们要优先运行一个线程，当它结束修改后，再允许另一个线程去访问这个局部变量，下面提供两种方式，轮询和互斥锁</p><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>​        顾名思义，轮询的意思就是反复询问，抽象起来理解就是，我们可以设置另一个用来作为目标值的全局变量，两个线程执行的条件根据目标值的不同而不同，当目标值满足一个线程执行时，其他线程就会一直处在一个堵塞的过程，它会一直询问目标值是否符合自己，当上一个线程结束时，这个线程会将目标值修改，这样下一个符合目标值的线程就会运行，示例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">g_flag = <span class="number">0</span></span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">global</span> g_flag</span><br><span class="line">    <span class="keyword">if</span> g_flag == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">            g_num += <span class="number">1</span></span><br><span class="line">        g_flag = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"---test1--- g_num = %d"</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">global</span> g_flag</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> g_flag != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">                g_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"---test2--- g_num = %d "</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = Thread(target=test1)</span><br><span class="line">p1.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p2 = Thread(target=test2)</span><br><span class="line">p2.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"---g_num= %d ---"</span> % g_num)</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---g_num= <span class="number">181893</span> ---</span><br><span class="line">---test1--- g_num = <span class="number">1000000</span></span><br><span class="line">---test2--- g_num = <span class="number">2000000</span></span><br></pre></td></tr></table></figure><p>​        如结果所示，线程之间使用全局变量的 bug 已经解决，但是轮询的方法十分消耗资源，堵塞的线程其实一直都处在一个死循环的状态占用系统资源</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>​        相比而言，互斥锁就是一种比较优化的方法，互斥锁会使用<code>threading</code>模块的<code>Lock</code>类</p><p>​        互斥锁的思想是，当一个线程运行时，它会给它需要的这部分资源上锁，这样同样使用这把锁的其他线程全部都会被堵塞，但被互斥锁所堵塞的线程不会占用系统资源，它们会处在睡眠状态，当运行的线程用完被锁的这部分资源后，它会解锁，这时其他线程就会被唤醒来抢占 cpu 资源，得到资源的线程会再次上锁，达到多线程下全局变量的访问安全，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line">mutex = Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    mutex.acquire()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    mutex.release()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"---test1--- g_num = %d"</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    mutex.acquire()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    mutex.release()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"---test2--- g_num = %d "</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = Thread(target=test1)</span><br><span class="line">p1.start()</span><br><span class="line"></span><br><span class="line">p2 = Thread(target=test2)</span><br><span class="line">p2.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"---g_num= %d ---"</span> % g_num)</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---g_num= <span class="number">200009</span> ---</span><br><span class="line">---test1--- g_num = <span class="number">1000000</span></span><br><span class="line">---test2--- g_num = <span class="number">2000000</span></span><br></pre></td></tr></table></figure><p>​        互斥锁的方法说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建锁</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"><span class="comment"># 上锁，blocking 为 True 表示堵塞</span></span><br><span class="line">mutex.acquire([blocking])</span><br><span class="line"><span class="comment"># 解锁，只要开了锁，那么接下来会让所有因为这个锁而被阻塞的线程抢着上锁</span></span><br><span class="line">mutex.release()</span><br></pre></td></tr></table></figure><p>​        使用互斥锁时要注意，为了提高运算效率，上锁的资源越少，运算的效率越高</p><p>​        另外，线程等待解锁的方式不是通过轮询，二十通过通知，线程会睡眠，等待唤醒的通知，所以互斥锁较轮询来讲更为优化</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-中的多线程&quot;&gt;&lt;a href=&quot;#Python-中的多线程&quot; class=&quot;headerlink&quot; title=&quot;Python 中的多线程&quot;&gt;&lt;/a&gt;Python 中的多线程&lt;/h1&gt;&lt;h2 id=&quot;什么是线程&quot;&gt;&lt;a href=&quot;#什么是线程&quot; class=&quot;headerlink&quot; title=&quot;什么是线程&quot;&gt;&lt;/a&gt;什么是线程&lt;/h2&gt;&lt;p&gt;​        一个进程中包括多个线程，线程是 CPU 调度和分派的基本单位，是进程中执行运算的最小单位，真正在 CPU 上运行的是线程，可以与同一个进程中的其他线程共享进程的全部资源&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的Python" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84Python/"/>
    
  </entry>
  
  <entry>
    <title>Python——多进程、进程池、进程间通信（还有一个复制文件的小程序）</title>
    <link href="http://yoursite.com/2020/02/03/Python%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E6%B1%A0%E3%80%81%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88%E8%BF%98%E6%9C%89%E4%B8%80%E4%B8%AA%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%89/"/>
    <id>http://yoursite.com/2020/02/03/Python——进程、进程池、进程间通信（还有一个复制文件的小程序）/</id>
    <published>2020-02-03T12:00:50.000Z</published>
    <updated>2020-02-03T13:06:42.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-中的进程"><a href="#Python-中的进程" class="headerlink" title="Python 中的进程"></a>Python 中的进程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p>​        当一段代码被运行，或者一个应用程序被运行，就会创建一个进程，以下内容来自百度百科：</p><p>​        <code>“进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体”</code></p><a id="more"></a><h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><p>​        每台计算机，cpu 是计算机的运算核心，多核计算机的意思就是，这台计算机上可以同时运行数量等于其核数的进程</p><p>​        并发执行，即 cpu 核数 &lt; 进程数，这个时候这些进程需要操作系统中的调度算法（时间片轮转算法、优先级调度算法等）来协调</p><p>​        并行执行，即 cpu 核数 &gt; 进程数，这个时候所有的进程都能得到执行，就是并行</p><h2 id="Python-中实现多进程的三种方法"><a href="#Python-中实现多进程的三种方法" class="headerlink" title="Python 中实现多进程的三种方法"></a>Python 中实现多进程的三种方法</h2><p>​        在 Python 中，想要实现多进程有三种方式：使用<code>os</code>模块中的<code>fork()</code>函数、使用<code>multiProcessing</code>模块的<code>Process</code>类、使用<code>multiProcessing</code>模块中的<code>Pool</code>（进程池），下面分别介绍这三种方法及他们之间的比较</p><h3 id="使用-os-fork-实现多进程"><a href="#使用-os-fork-实现多进程" class="headerlink" title="使用 os.fork() 实现多进程"></a>使用 os.fork() 实现多进程</h3><p>​        首先，<code>fork()</code>函数只有在 Linux 或者是 类 Linux 系统中才能使用</p><p>​        当程序运行到这个函数时，会新创建一个进程，新的进程会从这个函数的返回值处开始执行，<code>fork()</code>函数很特殊，在父进程里，<code>fork()</code>的返回值为<code>&gt; 0</code>，并且这个返回值就是主进程的<code>pid</code>，而在子进程中<code>fork()</code>的返回值是<code>== 0</code>的</p><p>​        在有<code>fork()</code>函数的程序中，若主程序在子程序结束之前运行完，那么系统不会等待子进程结束，而是会直接结束主进程，但这并不代表子进程也会被结束，子进程此时已经是一个独立的进程，它会自己运行到结束为止</p><p>​        示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">ret = os.fork()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ret == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">'Dad:%d : %d'</span> % (ret, os.getpid()))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">'Son:%d : %d : %d'</span> % (ret, os.getpid(), os.getppid()))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Son:6081 : 6079 : 5917</span><br><span class="line">Dad:0 : 6081</span><br><span class="line">Son:6081 : 6079 : 5917</span><br><span class="line">Dad:0 : 6081</span><br><span class="line">Son:6081 : 6079 : 5917</span><br><span class="line">Dad:0 : 6081</span><br><span class="line">Son:6081 : 6079 : 5917</span><br><span class="line">Dad:0 : 6081</span><br><span class="line">Son:6081 : 6079 : 5917</span><br><span class="line">Dad:0 : 6081</span><br><span class="line">Son:6081 : 6079 : 5917</span><br><span class="line">Dad:0 : 6081</span><br><span class="line">Son:6081 : 6079 : 5917</span><br><span class="line">Dad:0 : 6081</span><br></pre></td></tr></table></figure><p>​        <code>os</code>模块的其他常用方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取当前进程的 pid（进程号）</span></span><br><span class="line">os.getpid()：</span><br><span class="line"><span class="comment"># 获取当前进程父进程的 pid</span></span><br><span class="line">os.getppid()：</span><br></pre></td></tr></table></figure><h3 id="使用-Process-实现多进程"><a href="#使用-Process-实现多进程" class="headerlink" title="使用 Process 实现多进程"></a>使用 Process 实现多进程</h3><p>​        <code>multiProcessing</code>模块是一个在 Windows 中也可以使用的模块，它包含<code>Process</code>，使用 Process 创建的进程，主进程会等待所有的子进程结束后才结束</p><p>​        并且，<code>Process</code>可以被继承，这样也使得<code>Process</code>可以被更灵活的运用，以及封装功能性代码</p><p>​        使用<code>Process</code>创建进程的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">'----test----'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Process(target=test)</span><br><span class="line"></span><br><span class="line">p.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    print(<span class="string">'----main----'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">----main----</span><br><span class="line">----test----</span><br><span class="line">----main----</span><br><span class="line">----test----</span><br><span class="line">----main----</span><br><span class="line">----test----</span><br><span class="line">----main----</span><br><span class="line">----test----</span><br><span class="line">----main----</span><br></pre></td></tr></table></figure><p>​        创建一个类继承<code>Process</code>来实现多进程的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Process_Class</span><span class="params">(Process)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, interval)</span>:</span></span><br><span class="line">        Process.__init__(self)</span><br><span class="line">        self.interval = interval</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'son(%s) start, dad is (%s)'</span> % (os.getpid(), os.getppid()))</span><br><span class="line">        t_start = time.time()</span><br><span class="line">        time.sleep(self.interval)</span><br><span class="line">        t_stop = time.time()</span><br><span class="line">        print(<span class="string">'(%s) is over, Is %0.2f seconds'</span> % (os.getpid(), t_stop - t_start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t_start = time.time()</span><br><span class="line">    print(<span class="string">'now Process is (%s)'</span> % os.getpid())</span><br><span class="line">    p1 = Process_Class(<span class="number">2</span>)</span><br><span class="line">    p1.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    t_stop = time.time()</span><br><span class="line">    print(<span class="string">'(%s) is over, spend %0.2f seconds'</span> % (os.getpid(), t_stop - t_start))</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">now Process is (6155)</span><br><span class="line">son(6157) start, dad is (6155)</span><br><span class="line">(6157) is over, Is 2.00 seconds</span><br><span class="line">(6155) is over, spend 2.01 seconds</span><br></pre></td></tr></table></figure><p>​        <code>os.Process</code>的其他常用方法及属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常用方法：</span></span><br><span class="line"><span class="comment"># 判断进程实例是否还在执行</span></span><br><span class="line">Process.is_alive()</span><br><span class="line"><span class="comment"># 是否等待进程实例执行结束，或等待多少秒</span></span><br><span class="line">Process.join([timeout])</span><br><span class="line"><span class="comment"># 启动进程实例（创建子进程）</span></span><br><span class="line">Process.start()</span><br><span class="line"><span class="comment"># 如果没有给定 target 参数，这个对象调用 start() 方法时，就将执行对象中的 run() 方法</span></span><br><span class="line">Process.run()</span><br><span class="line"><span class="comment"># 不管任务是否完成，立即终止</span></span><br><span class="line">Process.terminate()</span><br><span class="line"><span class="comment"># 属性：</span></span><br><span class="line"><span class="comment"># 当前进程实例别名，默认为 Process-N，N 为从 1 开始递增的整数</span></span><br><span class="line">name</span><br><span class="line"><span class="comment"># 当前进程实例的 PID 值</span></span><br><span class="line">pid</span><br></pre></td></tr></table></figure><h3 id="使用-Pool（进程池）实现多进程"><a href="#使用-Pool（进程池）实现多进程" class="headerlink" title="使用 Pool（进程池）实现多进程"></a>使用 Pool（进程池）实现多进程</h3><p>​        当需要创建的子进程数量不多时，可以直接利用<code>multiprocessing</code>中的<code>Process</code>动态生成多个进程，但如果时上百甚至上千个目标，手动的去创建进程的工作量巨大，此时可以用到<code>multiprocessing</code>模块提供的<code>Pool</code>方法</p><p>​        初始化<code>Pool</code>时，可以指定一个最大进程数，当有新的请求提交到<code>Pool</code>中时，如果池还没有满，那么就会创建一个新的进程来执行请求；如果进程池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中进程结束，才会请求池中的空闲进程来执行</p><p>​        使用<code>Pool</code>实现多进程的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(<span class="string">'===pid=%d===num=%d'</span> % (os.getpid(), num))</span><br><span class="line">        time.sleep()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pool = Pool(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    print(<span class="string">'---%d---'</span> % i)</span><br><span class="line">    pool.apply_async(worker, (i,))</span><br><span class="line"></span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">---0---</span><br><span class="line">---1---</span><br><span class="line">---2---</span><br><span class="line">---3---</span><br><span class="line">---4---</span><br><span class="line">---5---</span><br><span class="line">---6---</span><br><span class="line">---7---</span><br><span class="line">---8---</span><br><span class="line">---9---</span><br><span class="line">===pid=6223===num=0</span><br><span class="line">===pid=6224===num=1</span><br><span class="line">===pid=6225===num=2</span><br><span class="line">===pid=6225===num=3</span><br><span class="line">===pid=6224===num=4</span><br><span class="line">===pid=6224===num=5</span><br><span class="line">===pid=6225===num=6</span><br><span class="line">===pid=6225===num=9</span><br><span class="line">===pid=6223===num=7</span><br><span class="line">===pid=6224===num=8</span><br></pre></td></tr></table></figure><p>​        <code>Pool</code>的其他常用方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非堵塞式添加进程，第一个参数为需要调用的目标，第二个参数为传递给目标参数的元组</span></span><br><span class="line"><span class="comment"># 如果添加的任务数量超过了进程池中进程的个数的话，不会导致添加不进去，它会等待进程池中的进程完成一个任务后，自动的用刚刚那个进程，完成当前的新任务</span></span><br><span class="line">Pool.apply_async(func, (item, item, ...))</span><br><span class="line"><span class="comment"># 堵塞式添加进程，每个请求添加就开始执行，结束后再添加下一个请求</span></span><br><span class="line">Pool.apply(func, (item, item, ...))</span><br><span class="line"><span class="comment"># 关闭进程池，关闭后进程池不会再接收新的请求</span></span><br><span class="line">Pool.close()</span><br><span class="line"><span class="comment"># 主进程在向进程池创建或添加任务后，默认不会等待进程池中的任务执行完，join 函数就是等待 Pool 中所有的子进程执行完成，必须放在 close() 函数后执行</span></span><br><span class="line">Pool.join()</span><br></pre></td></tr></table></figure><h3 id="三种方法的比较："><a href="#三种方法的比较：" class="headerlink" title="三种方法的比较："></a>三种方法的比较：</h3><p>​        <code>fork()</code>：最底层的方法，其余两种方法创建进程实际上最底层也是通过fork()来创建的，<code>fork()</code>不能直接跨平台使用，只支持 Linux 或类 Linux 平台<br>​        <code>Process</code>：父进程和子进程都用来执行，并且父进程会等待所有子进程结束后再结束<br>​        <code>Pool</code>：<code>Pool</code>方法中，父进程一般只用于等待，真正的任务都在子进程中执行</p><h2 id="进程间通信（使用-Queue）"><a href="#进程间通信（使用-Queue）" class="headerlink" title="进程间通信（使用 Queue）"></a>进程间通信（使用 Queue）</h2><p>​        进程之间是没有任何关联的，可以使用队列来进行进程间的通信，这里使用的是<code>multiProcessing</code>模块的<code>Queue</code>和<code>Manage</code>（用于线程池）</p><p>​        队列是一种先进先出（FIFO）的数据结构，下面是通过不断向同一个队列中输入数据和读取数据实现进程间的通信</p><h3 id="使用-Queue（使用-Process-实现的多进程）"><a href="#使用-Queue（使用-Process-实现的多进程）" class="headerlink" title="使用 Queue（使用 Process 实现的多进程）"></a>使用 Queue（使用 Process 实现的多进程）</h3><p>​        直接放代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]:</span><br><span class="line">        print(<span class="string">'Put %s to queue...'</span> % value)</span><br><span class="line">        q.put(value)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            value = q.get(<span class="literal">True</span>)</span><br><span class="line">            print(<span class="string">'Get %s from queue'</span> % value)</span><br><span class="line">            time.sleep(random.random())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    q = Queue()</span><br><span class="line">    pw = Process(target=write, args=(q,))</span><br><span class="line">    pr = Process(target=read, args=(q,))</span><br><span class="line"></span><br><span class="line">    pw.start()</span><br><span class="line">    pw.join()</span><br><span class="line"></span><br><span class="line">    pr.start()</span><br><span class="line">    pr.join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">' '</span>)</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Put A to queue...</span><br><span class="line">Put B to queue...</span><br><span class="line">Put C to queue...</span><br><span class="line">Get A from queue</span><br><span class="line">Get B from queue</span><br><span class="line">Get C from queue</span><br></pre></td></tr></table></figure><h3 id="使用-Manage（使用-Pool-实现的多进程）"><a href="#使用-Manage（使用-Pool-实现的多进程）" class="headerlink" title="使用 Manage（使用 Pool 实现的多进程）"></a>使用 Manage（使用 Pool 实现的多进程）</h3><p>​        直接放代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">'reader start (%s), Dad is (%s)'</span> % (os.getpid(), os.getppid()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(q.qsize()):</span><br><span class="line">        print(<span class="string">'rader get from queue : %s'</span> % q.get(<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">'writer start (%s), Dad is (%s)'</span> % (os.getpid(), os.getppid()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">'LiMingHui love GH'</span>:</span><br><span class="line">        q.put(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'(%s) start'</span> % os.getpid())</span><br><span class="line">    q = Manager().Queue()</span><br><span class="line">    po = Pool()</span><br><span class="line"></span><br><span class="line">    po.apply(writer, (q,))</span><br><span class="line">    po.apply(reader, (q,))</span><br><span class="line"></span><br><span class="line">    po.close()</span><br><span class="line">    po.join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'(%s) is end'</span> % os.getpid())</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(6306) start</span><br><span class="line">writer start (6313), Dad is (6306)</span><br><span class="line">reader start (6313), Dad is (6306)</span><br><span class="line">rader get from queue : L</span><br><span class="line">rader get from queue : i</span><br><span class="line">rader get from queue : M</span><br><span class="line">rader get from queue : i</span><br><span class="line">rader get from queue : n</span><br><span class="line">rader get from queue : g</span><br><span class="line">rader get from queue : H</span><br><span class="line">rader get from queue : u</span><br><span class="line">rader get from queue : i</span><br><span class="line">rader get from queue :  </span><br><span class="line">rader get from queue : l</span><br><span class="line">rader get from queue : o</span><br><span class="line">rader get from queue : v</span><br><span class="line">rader get from queue : e</span><br><span class="line">rader get from queue :  </span><br><span class="line">rader get from queue : G</span><br><span class="line">rader get from queue : H</span><br><span class="line">(6306) is end</span><br></pre></td></tr></table></figure><h2 id="一个使用多进程实现的复制文件夹的小程序"><a href="#一个使用多进程实现的复制文件夹的小程序" class="headerlink" title="一个使用多进程实现的复制文件夹的小程序"></a>一个使用多进程实现的复制文件夹的小程序</h2><p>​        只需要输入文件夹名字，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyFile</span><span class="params">(name, oldFolderName, newFolderName, queue)</span>:</span></span><br><span class="line">    fr = open(oldFolderName + <span class="string">'/'</span> + name)</span><br><span class="line">    fw = open(newFolderName + <span class="string">'/'</span> + name, <span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line">    content = fr.read()</span><br><span class="line">    fw.write(content)</span><br><span class="line"></span><br><span class="line">    fr.close()</span><br><span class="line">    fw.close()</span><br><span class="line"></span><br><span class="line">    queue.put(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    oldFolderName = input(<span class="string">'Floder-name is:'</span>)</span><br><span class="line">    newFolderName = oldFolderName + <span class="string">'_scopy'</span></span><br><span class="line">    os.mkdir(newFolderName)</span><br><span class="line"></span><br><span class="line">    fileNames = os.listdir(oldFolderName)</span><br><span class="line"></span><br><span class="line">    pool = Pool(<span class="number">5</span>)</span><br><span class="line">    queue = Manager().Queue()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> fileNames:</span><br><span class="line">        pool.apply_async(copyFile, args=(name, oldFolderName, newFolderName, queue))</span><br><span class="line"></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    allNum = len(fileNames)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> num &lt; allNum:</span><br><span class="line">        queue.get()</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        copyRate = num / allNum</span><br><span class="line">        print(<span class="string">'\rcopy : %.2f %%'</span> % (copyRate * <span class="number">100</span>), end=<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'copy end...'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-中的进程&quot;&gt;&lt;a href=&quot;#Python-中的进程&quot; class=&quot;headerlink&quot; title=&quot;Python 中的进程&quot;&gt;&lt;/a&gt;Python 中的进程&lt;/h1&gt;&lt;h2 id=&quot;什么是进程&quot;&gt;&lt;a href=&quot;#什么是进程&quot; class=&quot;headerlink&quot; title=&quot;什么是进程&quot;&gt;&lt;/a&gt;什么是进程&lt;/h2&gt;&lt;p&gt;​        当一段代码被运行，或者一个应用程序被运行，就会创建一个进程，以下内容来自百度百科：&lt;/p&gt;
&lt;p&gt;​        &lt;code&gt;“进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体”&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的Python" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84Python/"/>
    
  </entry>
  
  <entry>
    <title>Python——正则表达式</title>
    <link href="http://yoursite.com/2020/02/01/Python%E2%80%94%E2%80%94%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/02/01/Python——正则表达式/</id>
    <published>2020-02-01T10:56:03.000Z</published>
    <updated>2020-02-01T12:00:10.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-中的正则表达式"><a href="#Python-中的正则表达式" class="headerlink" title="Python 中的正则表达式"></a>Python 中的正则表达式</h1><p>​        正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定的字符串、及这些特定字符的组合，组成一个”规则字符串“，这个规则字符串用来表示对字符串的一种过滤逻辑</p><p>​        字符串是编程时涉及到的最多的一种数据结构，使用正则表达式可以完成判断一个字符串是否为合法电话号、是否是 Email 格式等操作</p><p>​        文章最后符一些常用的正则表达式！</p><a id="more"></a><h2 id="正则表达式通用符号及解释"><a href="#正则表达式通用符号及解释" class="headerlink" title="正则表达式通用符号及解释"></a>正则表达式通用符号及解释</h2><table><thead><tr><th align="center">模式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">.</td><td align="center">匹配任意除 <code>\n</code>外的字符</td></tr><tr><td align="center">\</td><td align="center">转义字符，是一个特殊字符原来的意思</td></tr><tr><td align="center">[…]</td><td align="center">对应位置可以是字符集中的任意字符</td></tr><tr><td align="center">\d</td><td align="center">数字（0~9）</td></tr><tr><td align="center">\D</td><td align="center">非数字</td></tr><tr><td align="center">\s</td><td align="center">空白字符（空格、\t、\r、\n、\f、\v）</td></tr><tr><td align="center">\S</td><td align="center">非空白字符</td></tr><tr><td align="center">\w</td><td align="center">单词字符（A<del>Z、a</del>z、0~9）</td></tr><tr><td align="center">\W</td><td align="center">非单词字符</td></tr><tr><td align="center">*</td><td align="center">匹配前一个字符 0 或 无限次</td></tr><tr><td align="center">+</td><td align="center">匹配前一个字符 1 或 无限次</td></tr><tr><td align="center">？</td><td align="center">匹配前一个字符 0 或 1 次</td></tr><tr><td align="center">{m}</td><td align="center">匹配前一个字符串 m 次</td></tr><tr><td align="center">{m, n}</td><td align="center">匹配前一个字符串 m 至 n 次</td></tr><tr><td align="center">^</td><td align="center">匹配字符串开头</td></tr><tr><td align="center">$</td><td align="center">匹配字符串末尾</td></tr><tr><td align="center">\A</td><td align="center">仅匹配字符串开头</td></tr><tr><td align="center">\Z</td><td align="center">仅匹配字符串末尾</td></tr><tr><td align="center">\b</td><td align="center">匹配 \w 和 \W 之间</td></tr><tr><td align="center">\B</td><td align="center">与上一个相反</td></tr></tbody></table><h2 id="re-模块"><a href="#re-模块" class="headerlink" title="re 模块"></a>re 模块</h2><p>​        python 通过导入 re 模块来使用正则表达式功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure><h3 id="re-compile"><a href="#re-compile" class="headerlink" title="re.compile"></a>re.compile</h3><p>​        compile 函数的返回值是一个 <code>pattern</code>（正则表达式对象），是用来自己定义正则表达式的函数，下面的句子是描述一个以 he 开头，后面接任意字符，并且以 o 结尾的字符串的正则表达式，例如 hello</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r'^(he)+.*o$'</span>)</span><br></pre></td></tr></table></figure><h3 id="re-match"><a href="#re-match" class="headerlink" title="re.match"></a>re.match</h3><p>​        match 函数是根据给定的正则表达式，来判定一个字符串是否符合规则的函数，匹配成功返回一个 match 对象，否则返回 None，下面是以上边 compile 函数返回的正则表达式为基础，对字符串检测的语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result = re.match(pattern, <span class="string">'hello'</span>)</span><br><span class="line">result = re.match(pattern, <span class="string">'hello'</span>, re.l)</span><br><span class="line"><span class="comment"># match 函数的第三个参数 flag 为可选参数，表示标志位，用于控制正则表达式的匹配方式，有如下用法：</span></span><br><span class="line"><span class="comment"># re.l 使匹配对大小写不敏感</span></span><br><span class="line"><span class="comment"># re.L 使匹配对大小写不敏感</span></span><br><span class="line"><span class="comment"># re.M 多行匹配</span></span><br><span class="line"><span class="comment"># re.S 使 . 匹配包括换行在内的左右字符</span></span><br><span class="line"><span class="comment"># re.U 根据 Unicode 字符集解析字符</span></span><br><span class="line"><span class="comment"># re.X 使格式更灵活，以便正则表达式更易于理解</span></span><br></pre></td></tr></table></figure><h3 id="match-group"><a href="#match-group" class="headerlink" title="match.group"></a>match.group</h3><p>​        这个函数是用来获取匹配后的字符串的，它的返回值是一个元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号</span></span><br><span class="line">result.group()</span><br><span class="line"><span class="comment"># 返回一个包含 num 指定小组所对应值的元组</span></span><br><span class="line">result.group(num)</span><br></pre></td></tr></table></figure><h3 id="re-search"><a href="#re-search" class="headerlink" title="re.search"></a>re.search</h3><p>​        search 函数的用法和 match 函数很接近，search 函数会扫描整个字符串并返回第一个成功的匹配，也是一个 match 对象，使用的参数也与 match 函数相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = re.search(pattern1, str)</span><br><span class="line">res = re.search(pattern1, str, re.l)</span><br></pre></td></tr></table></figure><p>​        二者的区别在于，match 函数只匹配字符串的开始，如果开始不符合，就会匹配失败，而 search 函数会匹配整个字符串，直到找到一个匹配</p><h3 id="re-findall"><a href="#re-findall" class="headerlink" title="re.findall"></a>re.findall</h3><p>​        findall 函数会找到字符串中所有符合正则表达式规则的字符串，返回值是一个列表，如果没有匹配，就会返回一个空列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res1 = re.findall(pattern1, str)</span><br></pre></td></tr></table></figure><h3 id="re-finditer"><a href="#re-finditer" class="headerlink" title="re.finditer"></a>re.finditer</h3><p>​        finditer 也是查找所有符合正则表达式规则的字符串，不同的是返回值，finditer 返回的是一个迭代器，用法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> re.finditer(pattern1, str):</span><br><span class="line">    print(item.group())</span><br></pre></td></tr></table></figure><h2 id="小样例"><a href="#小样例" class="headerlink" title="小样例"></a>小样例</h2><p>​        常用的正则表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</span><br><span class="line"></span><br><span class="line">2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?</span><br><span class="line"></span><br><span class="line">3. InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 手机号码：^(<span class="number">13</span>[<span class="number">0</span><span class="number">-9</span>]|<span class="number">14</span>[<span class="number">5</span>|<span class="number">7</span>]|<span class="number">15</span>[<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">5</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9</span>]|<span class="number">18</span>[<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">5</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9</span>])\d&#123;<span class="number">8</span>&#125;$</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 电话号码(<span class="string">"XXX-XXXXXXX"</span>、<span class="string">"XXXX-XXXXXXXX"</span>、<span class="string">"XXX-XXXXXXX"</span>、<span class="string">"XXX-XXXXXXXX"</span>、<span class="string">"XXXXXXX"</span>和<span class="string">"XXXXXXXX)：^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">6. 国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">7. 身份证号(15位、18位数字)：^\d&#123;15&#125;|\d&#123;18&#125;$</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-中的正则表达式&quot;&gt;&lt;a href=&quot;#Python-中的正则表达式&quot; class=&quot;headerlink&quot; title=&quot;Python 中的正则表达式&quot;&gt;&lt;/a&gt;Python 中的正则表达式&lt;/h1&gt;&lt;p&gt;​        正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定的字符串、及这些特定字符的组合，组成一个”规则字符串“，这个规则字符串用来表示对字符串的一种过滤逻辑&lt;/p&gt;
&lt;p&gt;​        字符串是编程时涉及到的最多的一种数据结构，使用正则表达式可以完成判断一个字符串是否为合法电话号、是否是 Email 格式等操作&lt;/p&gt;
&lt;p&gt;​        文章最后符一些常用的正则表达式！&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的Python" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84Python/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JAVA中的流</title>
    <link href="http://yoursite.com/2020/01/31/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JAVA%E4%B8%AD%E7%9A%84%E6%B5%81/"/>
    <id>http://yoursite.com/2020/01/31/JAVA基础——JAVA中的流/</id>
    <published>2020-01-31T11:41:20.000Z</published>
    <updated>2020-01-31T13:33:13.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-JAVA-中的“流”"><a href="#什么是-JAVA-中的“流”" class="headerlink" title="什么是 JAVA 中的“流”"></a>什么是 JAVA 中的“流”</h1><p>​        流是一种抽象出来的概念，当数据在介质中传输，就形成了流，所以流就是用来进行数据的传输的</p><a id="more"></a><h2 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h2><p>​        JAVA 中的流根据其在方向上、处理数据单元上、使用方式上可以分为很多种类</p><p>​        流可以分为输入流和输出流两大类， I（input）和 O（output），即我们常说的 I/O 流，这里的输入和输出是对 JAVA 程序来说的，数据流向 JAVA 程序时，是流入，即输入流，数据从 JAVA 程序中输出时，是流出，即输出流</p><p>​        又可以根据数据单元的不同，分为字节流和字符流，字节流可以处理所有类型的数据，因为它是一个字节一个字节的去读取数据的，而字符流则更适合处理文本数据，他们和输入流及输出流的概念并不冲突</p><h2 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h2><p>​        输入流是指将数据读入到 JAVA 程序中，包括 <code>Reader</code>、<code>InputStream</code> 以及它们的子类，一下以实例说明用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">    br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"F://lmh.txt"</span>));</span><br><span class="line">    String str = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((str = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (br != <span class="keyword">null</span>) &#123;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这个样例是以 <code>FileReader</code> 为基础，使用包装流 <code>Buffered</code> 包装，将一个文件中的数据读入程序中，所有的输入流中，都包含 read 方法用来读入数据，与字节流不同的是，字符流中的 <code>Reader</code> 支持 <code>readLine</code> 方法，可以将一行数据一次性读入，这也证明了字符流更适合操作文本数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"F:/lmh.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file.exists())</span><br><span class="line">        file.createNewFile();</span><br><span class="line">    String path = file.getPath();</span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10000</span>];</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">    <span class="keyword">int</span> fisRead = <span class="number">0</span>;</span><br><span class="line">    fisRead = fis.read(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这个样例是一个典型的，使用字节流向 JAVA 程序读入数据的功能，这里的读入使用 read 函数，read 函数有三种使用方法，一种是无参的读入，<code>read()</code> ，它不会存储读入的数据，只是一味的将读入指针在文件中后移，第二种是有参的读入，<code>read(byte[] bt)</code>，它会存储读入的数据，保存在名为 bt 的 byte 数组中，第三种是 <code>read(byte[] bt, int orr, int len)</code>，它是从输入流读取 len 个字节的数据到 bt 数组，off 为 bt 数组的起始偏移量，这也体现了字符流和字节流在读入数据时的区别</p><h2 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h2><p>​        输出流是将数据从 JAVA 程序输出到控制台或者文件中的流，可以理解为流出 JAVA 程序，包括 <code>Writer</code> 和 <code>OutputStream</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">    BufferedWriter bw = <span class="keyword">null</span>;</span><br><span class="line">    br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"F://lmh.txt"</span>));</span><br><span class="line">    bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"F://lmh01.txt"</span>));</span><br><span class="line">    String str = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((str = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bw.write(str, <span class="number">0</span>, str.length());</span><br><span class="line">        bw.newLine();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (br != <span class="keyword">null</span> || bw != <span class="keyword">null</span>) &#123;</span><br><span class="line">        br.close();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这个样例是一个先使用 <code>Reader</code> 读入数据，再将读入到的数据使用 <code>Writer</code> 写入另一个文件的功能，使用包装流 <code>BufferedWriter</code> 对 <code>FileWriter</code> 进行包装，可以提高运行效率，在使用 <code>Writer</code> 中定义的 write 方法，将其写入到文件中，write 方法有三种，一种是<code>write(char c)</code>，将指定的字符写入，第二种是<code>write(CharSequence cs)</code>，将指定的字符序列写入，第三种是<code>write(CharSequence cs, int off, int len)</code>，写入字符序列 cs 中从 off 位置开始，长度为 len 的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DataInputStream dis = <span class="keyword">null</span>;</span><br><span class="line">    DataOutputStream dos = <span class="keyword">null</span>;</span><br><span class="line">    dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"C://Users//StephenCurry//Desktop//chance//IMA//curry.jpg"</span>));</span><br><span class="line">    dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"C://Users//StephenCurry//Desktop//chance//IMA//curry5.jpg"</span>));</span><br><span class="line">    <span class="keyword">byte</span>[] bt = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024000</span>];</span><br><span class="line">    <span class="keyword">int</span> length = dis.read(bt);</span><br><span class="line">    dos.write(bt, <span class="number">0</span>, length);</span><br><span class="line">    <span class="keyword">if</span> (dis != <span class="keyword">null</span> || dos != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dis.close();</span><br><span class="line">        dos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这个样例就比较有趣了，使用字节流读入一张 jpg 的图片，再使用字节流输出到一个空的 jpg 文件中，实现文件的复制，因为是图片，这里必须使用字节流，使用 write 函数，将读入的字节数据，全部写入到另一个文件中，便完成了文件的复制</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        这里说的只不过是流的简单用法，最重要的是，每种流都有它最擅长的地方，学会在什么情景下使用什么流，才是最关键的</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是-JAVA-中的“流”&quot;&gt;&lt;a href=&quot;#什么是-JAVA-中的“流”&quot; class=&quot;headerlink&quot; title=&quot;什么是 JAVA 中的“流”&quot;&gt;&lt;/a&gt;什么是 JAVA 中的“流”&lt;/h1&gt;&lt;p&gt;​        流是一种抽象出来的概念，当数据在介质中传输，就形成了流，所以流就是用来进行数据的传输的&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>算法——双指针算法</title>
    <link href="http://yoursite.com/2020/01/17/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/01/17/算法——双指针算法/</id>
    <published>2020-01-17T13:56:51.000Z</published>
    <updated>2020-01-17T14:38:40.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h1><p>​        双指针算法是指一切采用双指针的方式，降低原本暴力解法的时间复杂度的算法，通常双指针算法可以将暴力的 <code>O(n^2)</code>降低到 <code>O(n)</code></p><p>​        由于双指针算法指的是一类算法，下面我用两道题来简单解释一下</p><a id="more"></a><h2 id="单词个数问题"><a href="#单词个数问题" class="headerlink" title="单词个数问题"></a>单词个数问题</h2><p>​        即查找一段字符串中，以空格为分隔的单词的个数，这道题用暴力法完全可解，外层 for 循环遍历整个字符数组，内层 for 循环检测 <code>&#39; &#39;</code> 字符，但是显然这种方法时间复杂度是 <code>O(n^2)</code></p><p>​        如果采用双指针算法， 外层循环用来控制遍历字符串，内层循环直接跳到 <code>&#39; &#39;</code> 处，记住这个单词后，直接将外层循环跳到 <code>&#39; &#39;</code> 的下一位继续执行，时间复杂度便为 <code>&#39;O(n)&#39;</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numStr</span><span class="params">(<span class="keyword">char</span> str[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> length = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">while</span> (str[l]) &#123;</span><br><span class="line"><span class="keyword">while</span> (r &lt;= length &amp;&amp; str[r] != <span class="string">' '</span>)</span><br><span class="line">r++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt; r; k++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str[k];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">sum++;</span><br><span class="line">l = ++r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = numStr(<span class="string">"hello world !"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"有 "</span> &lt;&lt; sum &lt;&lt; <span class="string">" 个单词"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长连续不重复子序列问题"><a href="#最长连续不重复子序列问题" class="headerlink" title="最长连续不重复子序列问题"></a>最长连续不重复子序列问题</h2><p>​        首先，这个问题也可以使用暴力法，嵌套 for 循环，可以解决问题，但是速度慢且代码复杂</p><p>​        采用双指针算法的思想，第一个指针持续后移，使用另一个数组统计每个数字出现的次数来控制第二个指针的移动，以此来计算不重复子序列，时间复杂度可达到 <code>O(n)</code></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">s[a[i]]++;</span><br><span class="line"><span class="keyword">while</span> (s[a[i]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">s[a[j]]--;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">res = max(res, i - j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>​        另外归并排序也是双指针算法的一个实例，归并排序在我之前的博客有讲过，链接是：<a href="https://stephencuhui.github.io/2020/01/14/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" target="_blank" rel="noopener">归并排序讲解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;双指针算法&quot;&gt;&lt;a href=&quot;#双指针算法&quot; class=&quot;headerlink&quot; title=&quot;双指针算法&quot;&gt;&lt;/a&gt;双指针算法&lt;/h1&gt;&lt;p&gt;​        双指针算法是指一切采用双指针的方式，降低原本暴力解法的时间复杂度的算法，通常双指针算法可以将暴力的 &lt;code&gt;O(n^2)&lt;/code&gt;降低到 &lt;code&gt;O(n)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​        由于双指针算法指的是一类算法，下面我用两道题来简单解释一下&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法——二分查找</title>
    <link href="http://yoursite.com/2020/01/15/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2020/01/15/算法——二分查找/</id>
    <published>2020-01-15T05:25:57.000Z</published>
    <updated>2020-01-15T07:07:46.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分算法"><a href="#二分算法" class="headerlink" title="二分算法"></a>二分算法</h1><p>​        二分算法分为浮点数二分和整数二分，整数二分相对于浮点数二分来讲更复杂，需要考虑边界问题等</p><a id="more"></a><h2 id="二分思想"><a href="#二分思想" class="headerlink" title="二分思想"></a>二分思想</h2><p>​        二分算法的思想是就一段有序序列来讲，想要查找其中某一个数，可以先找到位于序列中点的数，如果目标值小等于中点值，且序列是单调递增的，那么目标值一定在中点左侧，这样再用同样的方式对左侧区间进行二分，如此查找，最后就会找到要找的数字</p><h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><p>​        整数二分思想上很好理解，就是将有序的序列从中间分开，判断目标值在哪半边，再继续二分那段序列就可以</p><p>​        下面给出整数二分的一个例子，包括了整数二分的两种写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line"><span class="keyword">return</span> q[l];</span><br><span class="line"><span class="keyword">int</span> x = q[l], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">while</span> (x &gt; q[++i]);</span><br><span class="line"><span class="keyword">while</span> (x &lt; q[--j]);</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line">swap(q[i], q[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sl = j - l + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (k &lt;= sl)</span><br><span class="line"><span class="keyword">return</span> quick_sort(l, j, k);</span><br><span class="line"><span class="keyword">return</span> quick_sort(j + <span class="number">1</span>, r, k - sl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; quick_sort(<span class="number">0</span>, n - <span class="number">1</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这里之所以存在两种写法，主要区别在于求中点 mid 的值时，如果边界值采取不当的话，整数二分极有可能产生死循环导致程序崩溃，所以须在求 mid 时进行向下取整，即 <code>mid = (l + r + 1) / 2</code></p><h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><p>​        在理解了整数二分的基础上，理解浮点数二分就变得十分简单了，因为浮点数二分不会涉及到边界问题，所以在确定边界值上十分简单，下面是用浮点数二分的思想实现的开平方问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="keyword">double</span> l = <span class="number">0</span>, r = x;</span><br><span class="line"><span class="keyword">while</span> (r - l &gt; <span class="number">1e-6</span>) &#123;</span><br><span class="line"><span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (mid * mid &gt;= x)</span><br><span class="line">r = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">l = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二分算法&quot;&gt;&lt;a href=&quot;#二分算法&quot; class=&quot;headerlink&quot; title=&quot;二分算法&quot;&gt;&lt;/a&gt;二分算法&lt;/h1&gt;&lt;p&gt;​        二分算法分为浮点数二分和整数二分，整数二分相对于浮点数二分来讲更复杂，需要考虑边界问题等&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法——归并排序</title>
    <link href="http://yoursite.com/2020/01/14/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/01/14/算法——归并排序/</id>
    <published>2020-01-14T09:54:45.000Z</published>
    <updated>2020-01-14T10:39:35.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>​        归并排序是另一种排序算法，也是采用分治的思想，但是和快排有很大的区别，归并排序是稳定的，而快排则不稳定</p><a id="more"></a><h2 id="归并的思想"><a href="#归并的思想" class="headerlink" title="归并的思想"></a>归并的思想</h2><p>​        归并排序的思想可以简单的分为三个步骤：</p><ol><li>确定分界点 mid</li><li>递归分界点得到左右空间</li><li>归并，将若干数组合并为一个有序数组</li></ol><h2 id="确定分界点"><a href="#确定分界点" class="headerlink" title="确定分界点"></a>确定分界点</h2><p>​        确定分界点，归并排序的分界点即为数组的中点，设数组左边界为 left，有边界为 right，那么分界点 mid 便为 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>​        归并排序的分界点和快排的分界点有本质的区别，快排的分界点是对数组的元素值而言的，而归并排序的分界点是就数组的 index 来说的</p><p>​        通过确定的分界点，一个数组就被分解成了两个以 mid 为分界的数组，第一个数组的就原素组而言的下标范围是 left &lt;= index &lt;= mid，第二个数组是 mid + 1 &lt;= index &lt;= right</p><h2 id="递归分界点左右空间"><a href="#递归分界点左右空间" class="headerlink" title="递归分界点左右空间"></a>递归分界点左右空间</h2><p>​        根据第一步得到的结果，可以使用递归将得到的两个数组继续分解，即</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">merge_sort(q, l, mid);</span><br><span class="line">merge_sort(q, mid + <span class="number">1</span>, r);</span><br></pre></td></tr></table></figure><h2 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h2><p>​        这是归并排序最重要的一步，是对归并得到的数组得处理，对于两个有序数组来说，想要合并，就要不断得对比数组头位置元素的大小，这又是使用双指针，分别指向两个数组的头元素，不断对比两个指针对应元素大小，保存较小的那个，并后移与其对应的指针，由于两个指针实际上是分步执行的，当其中一个数组被遍历完后，直接将另一个数组接到答案数组的尾部即可，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//k 用来记录答案数组中现存元素的数量</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line"><span class="keyword">if</span> (q[i] &lt;= q[j])</span><br><span class="line">tmp[k++] = q[i++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tmp[k++] = q[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">tmp[k++] = q[i++];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">tmp[k++] = q[j++];</span><br><span class="line"><span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++)</span><br><span class="line">q[i] = tmp[j];</span><br></pre></td></tr></table></figure><h2 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[N], tmp[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">merge_sort(q, l, mid);</span><br><span class="line">merge_sort(q, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line"><span class="keyword">if</span> (q[i] &lt;= q[j])</span><br><span class="line">tmp[k++] = q[i++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tmp[k++] = q[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">tmp[k++] = q[i++];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">tmp[k++] = q[j++];</span><br><span class="line"><span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++)</span><br><span class="line">q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; q[i];</span><br><span class="line">&#125;</span><br><span class="line">merge_sort(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; q[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h1&gt;&lt;p&gt;​        归并排序是另一种排序算法，也是采用分治的思想，但是和快排有很大的区别，归并排序是稳定的，而快排则不稳定&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法——快速排序</title>
    <link href="http://yoursite.com/2020/01/13/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/01/13/算法——快速排序/</id>
    <published>2020-01-13T09:53:56.000Z</published>
    <updated>2020-01-14T10:40:00.623Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><p>​        从头开始学习算法，从最简单的排序算法开始，第一个接触的就是快排，学习的平台是 AcWing，希望现在学习还不晚，对以后能有帮助</p><a id="more"></a><h2 id="快排的原理"><a href="#快排的原理" class="headerlink" title="快排的原理"></a>快排的原理</h2><p>​        快排使用的是分治的思想，有三个关键点：确定分界点、调整区间、递归处理左右两段，这里的思想是使用两个指针，分别对应数组的左右边界，一下简称 l 和 r，通过循环来将两个指针向中间移动直到 l 和 r 相遇，在这期间，将数组调整为小于等于分界点的值和大于等于分界点的值两部分，再使用递归的思想处理</p><p>​        首先要做的是确定一个分治的分界点，这个点可以是任意的一个数组元素，但不要给它设置成固定值，最好通过变量来对它进行定义，例如 array[l]、array[r]、array[(l + r) / 2] 这种都可以</p><p>​        然后通过分界点的值来调整数组空间，，这里需要用到刚才提到的 l 和 r 两个指针，过程是：先将 l 向后移动，检验 l 对应的值是否小于分界点，如果小于则继续后移 l，否则 l 就会停下，这是 r 开始前移，检测移动后的 r 所对应的值是否大于分界点，如果大于则继续前移 r，否则 r 也会停下，这个时候 l 和 r 都已经停下了，说明 l 和 r 都已经遇到了不属于自己对应空间的值，直接交换两个指针当前所对应的值，然后继续移动 l 和 r 指针，直到 l 和 r 相遇</p><p>​        最后便是使用递归的思想，对分界点左边（大小意义上的左，并非是排序上的左）和分界点右边的元素再进行第二步的过程，当最后一次递归结束后，数组便完成了排序</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span> <span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//x:分治变量 循环变量需在两侧边界外一个偏移量的位置，因为每次都是先让指针后/前移一格，所以循环变量需要在边界的前/后一个偏移量的位置</span></span><br><span class="line">    <span class="keyword">int</span> x = arr[l], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">while</span> (arr[i] &lt; x);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        j++;</span><br><span class="line">    <span class="keyword">while</span> (arr[j] &gt; x);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) </span><br><span class="line">       swap(arr[i], arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    quick_sort(arr, l, j);</span><br><span class="line">    quick_sort(arr, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;快排&quot;&gt;&lt;a href=&quot;#快排&quot; class=&quot;headerlink&quot; title=&quot;快排&quot;&gt;&lt;/a&gt;快排&lt;/h1&gt;&lt;p&gt;​        从头开始学习算法，从最简单的排序算法开始，第一个接触的就是快排，学习的平台是 AcWing，希望现在学习还不晚，对以后能有帮助&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JAVA线程简介及两种创建方式</title>
    <link href="http://yoursite.com/2020/01/04/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JAVA%E7%BA%BF%E7%A8%8B%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%B8%A4%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/01/04/JAVA基础——JAVA线程简介及两种创建方式/</id>
    <published>2020-01-04T01:34:30.000Z</published>
    <updated>2020-01-04T03:07:25.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p>​        进程是程序的一次执行过程，是一个动态的概念，是程序在执行过程中分配和管理资源的基本单位，每一个进程都有一个自己的地址空间，也就是说，进程是应用程序运行的状态，应用程序的执行实例，有独立的内存空间和系统资源</p><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>​        一个进程中包括多个线程，线程是 CPU 调度和分派的基本单位，是进程中执行运算的最小单位，真正在 CPU 上运行的是线程，可以与同一个进程中的其他线程共享进程的全部资源</p><a id="more"></a><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>​        线程是进程的一部分，它也是一个动态执行的概念，有从产生到死亡的过程，线程的生命周期可以分为五个部分：</p><p>​        新生状态-&gt;（线程创建了，还未运行）-&gt;可运行状态（CPU 准备调度线程）-&gt;（系统调度，获取 CPU 资源）-&gt;运行状态-&gt;阻塞状态（线程阻塞，让出 CPU 资源）-&gt;死亡状态</p><h3 id="新生状态"><a href="#新生状态" class="headerlink" title="新生状态"></a>新生状态</h3><p>​        线程对象被创建后，这个线程就处于新生状态，这个状态会一直持续到 start() 这个线程</p><h3 id="可运行状态"><a href="#可运行状态" class="headerlink" title="可运行状态"></a>可运行状态</h3><p>​        当线程调用了 start() 方法后，该线程就进入可运行状态，进入可运行状态的线程会被插入就绪队列中，等待 JVM 里线程调度器的调度</p><h3 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h3><p>​        当可运行状态的线程得到 CPU 资源后，该线程就可以执行 run()，此时线程便处于运行状态，运行状态的线程可以向阻塞状态、就绪状态和死亡状态转变</p><h3 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h3><p>​        当一个线程调用了 sleep()、join()、yield() 等方法，失去所占用的资源后，线程进入阻塞状态，在说的资源或者睡眠时间已到后可以重新进入就绪状态</p><h3 id="死亡状态"><a href="#死亡状态" class="headerlink" title="死亡状态"></a>死亡状态</h3><p>​        正常死亡和非正常死亡都会杀死进程，进程死亡即进程被销毁</p><h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>​        在 Java 中，线程有优先级的概念，其范围为 1 - 10，默认优先级为 5，但是优先级是概率性的，优先级高的线程并不一定优先执行，只是被分配资源的概率更高</p><p>​        setPriority() 方法有三种常量：</p><p>​            MAX_PRIORITY (10)</p><p>​            MIN_PRIORITY (1)</p><p>​            NORM_PRIORITY (5)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(mt);</span><br><span class="line">t.setPriority(<span class="number">1</span>);</span><br><span class="line">t.start();</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(mt);</span><br><span class="line"><span class="comment">//设置线程名称</span></span><br><span class="line">t2.setName(<span class="string">"sc"</span>);</span><br><span class="line"><span class="comment">//设置线程优先级，但是是概率事件，并非优先级高一定先运行，1 - 10 表示，10 最高，默认值是 5</span></span><br><span class="line">t2.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">Thread.currentThread().setPriority(Thread.MIN_PRIORITY);</span><br></pre></td></tr></table></figure><h2 id="线程在-Java-中的两种创建方式"><a href="#线程在-Java-中的两种创建方式" class="headerlink" title="线程在 Java 中的两种创建方式"></a>线程在 Java 中的两种创建方式</h2><p>​        在 Java 中有两种创建线程的方法，下面逐个解释并说明他们的区别</p><h3 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h3><p>​        通过继承 Thread 类来创建线程，创建该类的实例，继承类必须重写 run() 方法，run() 方法中是线程所执行的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        mt.start();</span><br><span class="line">        </span><br><span class="line">        MyThread mt2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        mt2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        Thread 类实际上是实现了 Runnable 接口的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br></pre></td></tr></table></figure><h3 id="通过实现-Runnable-接口"><a href="#通过实现-Runnable-接口" class="headerlink" title="通过实现 Runnable 接口"></a>通过实现 Runnable 接口</h3><p>​        实现 Runnable 接口直需要重写其中的 run() 方法，Thread 的构造方法中，可以通过静态代理的方法，使用 Runnable 的实现类来创建进程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread2 mt = <span class="keyword">new</span> MyThread2();</span><br><span class="line">        <span class="comment">//静态代理</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(mt);</span><br><span class="line">        t.setPriority(<span class="number">1</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(mt);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>​        首先，单继承不能再继承其他类，而实现可以多实现，同时也可以继承</p><p>​        另外，通过实现 Runnable 接口来创建的线程可以共享实现类的资源，这是多线程实现的基础</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;进程与线程&quot;&gt;&lt;a href=&quot;#进程与线程&quot; class=&quot;headerlink&quot; title=&quot;进程与线程&quot;&gt;&lt;/a&gt;进程与线程&lt;/h1&gt;&lt;h2 id=&quot;什么是进程&quot;&gt;&lt;a href=&quot;#什么是进程&quot; class=&quot;headerlink&quot; title=&quot;什么是进程&quot;&gt;&lt;/a&gt;什么是进程&lt;/h2&gt;&lt;p&gt;​        进程是程序的一次执行过程，是一个动态的概念，是程序在执行过程中分配和管理资源的基本单位，每一个进程都有一个自己的地址空间，也就是说，进程是应用程序运行的状态，应用程序的执行实例，有独立的内存空间和系统资源&lt;/p&gt;
&lt;h2 id=&quot;什么是线程&quot;&gt;&lt;a href=&quot;#什么是线程&quot; class=&quot;headerlink&quot; title=&quot;什么是线程&quot;&gt;&lt;/a&gt;什么是线程&lt;/h2&gt;&lt;p&gt;​        一个进程中包括多个线程，线程是 CPU 调度和分派的基本单位，是进程中执行运算的最小单位，真正在 CPU 上运行的是线程，可以与同一个进程中的其他线程共享进程的全部资源&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JVM之G1（Garbage First）垃圾回收器</title>
    <link href="http://yoursite.com/2019/12/29/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JVM%E4%B9%8BG1%EF%BC%88Garbage-First%EF%BC%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>http://yoursite.com/2019/12/29/JAVA基础——JVM之G1（Garbage-First）垃圾回收器/</id>
    <published>2019-12-29T02:16:26.000Z</published>
    <updated>2019-12-29T03:45:10.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Garbage-First-垃圾回收器"><a href="#Garbage-First-垃圾回收器" class="headerlink" title="Garbage First 垃圾回收器"></a>Garbage First 垃圾回收器</h1><h2 id="G1-简介"><a href="#G1-简介" class="headerlink" title="G1 简介"></a>G1 简介</h2><p>​        G1（Garbage First）垃圾回收器是最新的 JDK 中默认的垃圾回收器，也是垃圾回收技术最前沿的成果，它同时注重吞吐量（Throughput）和低延迟（Low Latency），默认的暂停目标是 200ms，适用于超大的堆内存</p><p>​        G1 引入了分区（region）的思想，弱化了分代的概念，它将堆内存分为大小相等的区，每个区的大约是 1248M，并且每个区都可以是 Eden、Survivor、Old 或者大对象区，G1 垃圾回收器在整体上使用了标记整理算法，两个区域之间使用的是复制算法</p><a id="more"></a><h2 id="G1-垃圾回收流程"><a href="#G1-垃圾回收流程" class="headerlink" title="G1 垃圾回收流程"></a>G1 垃圾回收流程</h2><p>​        G1 垃圾回收器的名字来源于它的设计原则：优先收集回收效果最大的区域（Garbage First），G1 垃圾回收器不是等到内存耗尽开始进行垃圾回收的，它采用启发式算法，当内存使用达到一定比例时就会开始进行垃圾回收，G1 垃圾回收器的工作流程大体上可以分为三个步骤的循环执行：Young Collection、Young Collection + CM、Mixed Collection</p><p><img src="https://img-blog.csdnimg.cn/20191229114401950.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70" alt></p><h3 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h3><p>​        Young Collection 阶段主要进行新生代的垃圾回收，和其他垃圾回收器一样，当 Eden 区逐渐被沾满时，会将 Eden 区中的幸存对象复制进 Survivor 区，这期间会造成 STW，当 Survivor 区中对象逐渐被占满时，被占满的 Survivor 区的对象中，符合晋升条件的会晋升到老年代，其余的会复制到其他 Survivor 区，另外，在进行 Young Collection 时，JVM 会对对象进行初始标记</p><h3 id="Young-Collection-Concurrent-Mark"><a href="#Young-Collection-Concurrent-Mark" class="headerlink" title="Young Collection + Concurrent Mark"></a>Young Collection + Concurrent Mark</h3><p>​        当老年代占用堆空间比例达到一定的阈值时，会进行并发标记，并发标记不会造成 STW，也就是不会影响其他的用户线程，阈值的默认值是 45%，即老年代占比达到堆空间的 45% 时会开始进行并发标记，这里的并发标记过程也和其他的垃圾回收器一样，就是对初始标记后的对象再进行一次更细致的标记</p><h3 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h3><p>​        混合回收是 G1 垃圾回收循环中的最后一项，在混合回收中，G1 可以将一些老年代区域添加到将回收的 Eden 和 Survivor，G1 垃圾回收器回收足够数量的老年代区域后，G1 会恢复到执行 Young Collection，直到下一个并发标记周期的完成</p><p>​        Mixed Collection 分为最终标记（Remark）和拷贝存活（Evacuation）两个阶段，两个阶段都会造成 STW</p><h4 id="Remark（重标记、最终标记）"><a href="#Remark（重标记、最终标记）" class="headerlink" title="Remark（重标记、最终标记）"></a>Remark（重标记、最终标记）</h4><p>​        最终标记（重标记）对于垃圾回收的过程是十分必要的，比如有如下情况：对象 C 在初始标记时因为没有被强引用所引用，初始标记的过程就不会标记 C 对象，而在垃圾回收之前和并发标记这段时间里，强引用对象 A 又引用了对象 C，如果不在垃圾回收之前进行一次 Remark，这时的对象 C 毫无疑问会被当作垃圾回收掉</p><p>​        为了防止这种事情发生，在并发标记之后，如果对象的引用发生了改变，JVM 会执行写屏障指令，将发生引用改变的对象放入一个 satb_mark_queue 中，当重新标记进行时会检查这个队列，检测其中的对象是否有强引用所引用</p><h4 id="Evacuation（拷贝存活）"><a href="#Evacuation（拷贝存活）" class="headerlink" title="Evacuation（拷贝存活）"></a>Evacuation（拷贝存活）</h4><p>​        拷贝存活即最后的整理，将多个区域的存活对象整理进一个或几个区域，并完成 Eden 到 Survivor，Survivor 到 Old，Old 到 Eden 和 Survivor 的过程，回收老年代的对象时，G1 会优先回收垃圾最多的区域，以达到暂停时间短的目标</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Garbage-First-垃圾回收器&quot;&gt;&lt;a href=&quot;#Garbage-First-垃圾回收器&quot; class=&quot;headerlink&quot; title=&quot;Garbage First 垃圾回收器&quot;&gt;&lt;/a&gt;Garbage First 垃圾回收器&lt;/h1&gt;&lt;h2 id=&quot;G1-简介&quot;&gt;&lt;a href=&quot;#G1-简介&quot; class=&quot;headerlink&quot; title=&quot;G1 简介&quot;&gt;&lt;/a&gt;G1 简介&lt;/h2&gt;&lt;p&gt;​        G1（Garbage First）垃圾回收器是最新的 JDK 中默认的垃圾回收器，也是垃圾回收技术最前沿的成果，它同时注重吞吐量（Throughput）和低延迟（Low Latency），默认的暂停目标是 200ms，适用于超大的堆内存&lt;/p&gt;
&lt;p&gt;​        G1 引入了分区（region）的思想，弱化了分代的概念，它将堆内存分为大小相等的区，每个区的大约是 1248M，并且每个区都可以是 Eden、Survivor、Old 或者大对象区，G1 垃圾回收器在整体上使用了标记整理算法，两个区域之间使用的是复制算法&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JVM之垃圾回收器</title>
    <link href="http://yoursite.com/2019/12/26/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>http://yoursite.com/2019/12/26/JAVA基础——JVM之垃圾回收器/</id>
    <published>2019-12-26T11:58:59.000Z</published>
    <updated>2019-12-28T08:54:08.394Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-垃圾回收器"><a href="#JVM-垃圾回收器" class="headerlink" title="JVM 垃圾回收器"></a>JVM 垃圾回收器</h1><p>​        在 JVM 中，垃圾回收器大体分为三个种类：串行垃圾回收器、吞吐量优先的垃圾回收器和响应时间优先的垃圾回收器</p><a id="more"></a><h2 id="串行垃圾回收器"><a href="#串行垃圾回收器" class="headerlink" title="串行垃圾回收器"></a>串行垃圾回收器</h2><p>​        串行垃圾回收器是一种单线程的垃圾回收器，适合堆内存小，cpu 个数少的电脑</p><p>​        开启：-XX:+UseSerialGC = Serial + SerialOld</p><p>​        串行垃圾回收器分为两个部分：Serial 和 SerialOld，Serial 工作在新生代，使用的垃圾回收算法是复制算法，SerialOld 工作在老年代，使用标记整理算法</p><p>​        当串行垃圾回收器进行垃圾回收时，所有的用户线程将会暂停，因为垃圾回收的过程中会涉及到地址的变化，当所有线程运行到一个本身的安全点时会进入阻塞状态，等待垃圾回收线程结束后，再恢复运行</p><p><img src="https://img-blog.csdnimg.cn/2019122816521345.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70" alt></p><h2 id="吞吐量优先的垃圾回收器"><a href="#吞吐量优先的垃圾回收器" class="headerlink" title="吞吐量优先的垃圾回收器"></a>吞吐量优先的垃圾回收器</h2><p>​        吞吐量优先的垃圾回收器是一种多线程，并行的垃圾回收器</p><p>​        开启：+UseParallelGC~-XX:+UseParallelOldGC</p><p>​        吞吐量优先的垃圾回收器也分为两个部分：Parallel 和 ParallelOld，Parallel 工作在新生代，使用复制算法，ParallelOld 工作在老年代，使用标记整理算法，两个垃圾回收器都是多线程的垃圾回收器，开启一个的同时会默认开启另一个</p><p>​        当需要进行垃圾回收时，所有线程会到安全点时停下，转换为阻塞状态，之后垃圾回收器会开启多个线程进行垃圾回收，其线程个数一般情况下和 cpu 核数相同，回收结束后，各线程再恢复运行，垃圾回收时，cpu 的利用率会达到 100 %</p><p><img src="https://img-blog.csdnimg.cn/20191228165229857.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70" alt></p><p>​        可以通过参数来设置垃圾回收中的属性：</p><p>​    ·    -XX:+UseAdaptiveSizePolicy<br>​        -XX:GCTimeRatio = ratio 设置垃圾回收时间占总时间的百分比小于 1 / 1 + ratio，ratio 一般设置成 19<br>​        -XX:MaxGCPauseMillis = time 最大暂停毫秒数 &lt; time ms，可能和前一项冲突、对立</p><h2 id="响应时间优先的垃圾回收器"><a href="#响应时间优先的垃圾回收器" class="headerlink" title="响应时间优先的垃圾回收器"></a>响应时间优先的垃圾回收器</h2><p>​        响应时间优先的垃圾回收器是一种多线程，并发的垃圾回收器，用户线程和垃圾回收线程可以同时进行，一起抢占 cpu 资源</p><p>​        开启：-XX:+UseConcMarkSweepGC<del>-XX:+UseParNewGC</del>SerialOl</p><p>​        ConcMarkSweep 是工作在老年代的垃圾回收器，与之配套使用的是工作在新生代的 ParNew，ParNew 是一种基于复制算法的垃圾回收器，ConcMarkSweep 是并发的，基于标记清除算法的垃圾回收器，但是它可能会并发失败，这是它会退化为 SerialOld</p><p>​        当老年代发生垃圾回收时，所有线程会在运行到安全点时暂停并进入阻塞状态，需要进行垃圾回收的线程会进行一次初始标记，初始标记时间很快，只标记一些根对象，接着用户的其他线程便恢复运行，垃圾回收线程与此同时也会并发执行，再一次进行更细致的标记，结束后，会造成第二次 STW，这时对所有的线程进行一次重新标记，以避免并发运行期间，新的内存使用对垃圾回收产生影响，重新标记结束后，垃圾回收线程开始进行清理，用户线程也都恢复运行，这时也是垃圾回收线程和用户线程并发运行，这种垃圾回收方式对系统吞吐量是有影响的，因为用于计算的 cpu 个数降低了</p><p>​        由于这种垃圾回收方式不会保证清除掉所有垃圾，所以不能像以上的两种垃圾回收器那样，等内存占用满时再进行垃圾回收，会在内存占比达到一定比例时便进行垃圾回收</p><p><img src="https://img-blog.csdnimg.cn/20191228165244736.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM-垃圾回收器&quot;&gt;&lt;a href=&quot;#JVM-垃圾回收器&quot; class=&quot;headerlink&quot; title=&quot;JVM 垃圾回收器&quot;&gt;&lt;/a&gt;JVM 垃圾回收器&lt;/h1&gt;&lt;p&gt;​        在 JVM 中，垃圾回收器大体分为三个种类：串行垃圾回收器、吞吐量优先的垃圾回收器和响应时间优先的垃圾回收器&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JVM之垃圾回收算法</title>
    <link href="http://yoursite.com/2019/12/25/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JVM%E4%B9%8B%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2019/12/25/JAVA基础——JVM之垃圾回收算法/</id>
    <published>2019-12-25T09:04:47.000Z</published>
    <updated>2019-12-25T10:27:45.208Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-的垃圾回收算法"><a href="#JVM-的垃圾回收算法" class="headerlink" title="JVM 的垃圾回收算法"></a>JVM 的垃圾回收算法</h1><p>​        在 JVM 中，经常使用的垃圾回收算法有：标记-清除算法、标记-整理算法、复制算法以及分代回收算法，在这里会逐一介绍说明</p><a id="more"></a><h2 id="标记-清除算法（Mark-Sweep）"><a href="#标记-清除算法（Mark-Sweep）" class="headerlink" title="标记-清除算法（Mark Sweep）"></a>标记-清除算法（Mark Sweep）</h2><p>​        标记清除算法的运行流程是先标记，将有引用链连接的引用对象进行标记，再将未被标记的引用对象的起始地址和结束地址存入空闲地址列表中，下次需要内存时直接对其进行覆盖</p><p>​        标记清除算法从原理上来说很容易实现，但有一个很严重的问题是此算法容易产生内存碎片，因为标记清除算法回收后的内存可能是断断续续的，而此时就不再可能分配出较大的连续内存空间而触发新一次的垃圾回收</p><p>​        标记清除算法在存活的引用对象多的时候十分高效，但因为其只对未被引用链所连接的即未被标记的引用对象进行清除操作，不移动被标记的对象，所以产生内存碎片是不能避免的</p><h2 id="标记-整理算法（Mark-Compact）"><a href="#标记-整理算法（Mark-Compact）" class="headerlink" title="标记-整理算法（Mark  Compact）"></a>标记-整理算法（Mark  Compact）</h2><p>​        标记整理算法的标记过程和标记清除算法没有区别，整理的过程会对使用的内存进行整理，将存活的对象都向内存的一端移动，然后清理掉整端边界以外的内存</p><p>​        标记整理算法显然解决了标记清除算法会产生内存碎片的问题，但该算法中涉及到对象的移动，所以运算时的成本会有所提高</p><h2 id="复制算法（Copy）"><a href="#复制算法（Copy）" class="headerlink" title="复制算法（Copy）"></a>复制算法（Copy）</h2><p>​        复制算法是将内存区域分成了大小相等的 FROM 和 TO 两块区域，TO 区开始没有对象，所有的对象都使用 FROM 区，当 FROM 区满了需要垃圾回收时，将存活的对象复制到 TO 区中，然后把 FROM 区清空，这样一来复制到 FROM 区的对象是相连的，不会产生内存碎片的问题，最后改 FROM 为 TO，改 TO 为 FROM，这样新的对象就和老对象继续使用新的 FROM 区，而新的 TO 区依然是空的，如此循环</p><p>​        复制算法实现起来十分简单，也不会产生内存碎片，但缺点是以内存空间的使用率为代价，每次只能使用一半的内存空间，如果存活对象多的话，复制算法的效率也会下降</p><h2 id="分代回收算法（Generational-Collention）"><a href="#分代回收算法（Generational-Collention）" class="headerlink" title="分代回收算法（Generational Collention）"></a>分代回收算法（Generational Collention）</h2><p>​        首先分代收集是大部分 JVM 都采用的垃圾回收算法，它将内存划分为不同的区域，根据对象的生命周期对其进行分类，一般分为：新生代（Young Generation）和老年代（Tenured Generation）</p><p>​        新生代中，又被分成一块伊甸园（Eden Space）和两块幸存区（Survivor），幸存区 FROM 和幸存区TO，其比例一般为 8 : 1 : 1，每次都同时使用伊甸园和幸存区 FROM，在进行垃圾回收时（Minor GC），将伊甸园和幸存区 FROM 中的对象复制进幸存区 TO 中，然后清理掉伊甸园和幸存区 FROM，最后像复制算法一样对 FROM 和 TO 进行一次调换如此循环，也就是说，新生代的垃圾回收主要以复制算法为主</p><p>​        在分代回收算法中，有一个用来控制新生代对象进入老年代的属性，叫阈值，每次垃圾回收后，若该对象还存在于内存中，它的年龄就会 + 1，当对象的年龄超过阈值后，它就会从新生代晋升到老年代，也就是说，老年代存放的都是一些生命周期很长的对象</p><p>​        当老年代内存全部被占用时，会先尝试 Minor GC，若空间仍不足，会再进行一次 Full GC，Full GC 的 STW（Stop The World）时间很长，如果 Full GC 后空间仍不足，就会 OOF</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM-的垃圾回收算法&quot;&gt;&lt;a href=&quot;#JVM-的垃圾回收算法&quot; class=&quot;headerlink&quot; title=&quot;JVM 的垃圾回收算法&quot;&gt;&lt;/a&gt;JVM 的垃圾回收算法&lt;/h1&gt;&lt;p&gt;​        在 JVM 中，经常使用的垃圾回收算法有：标记-清除算法、标记-整理算法、复制算法以及分代回收算法，在这里会逐一介绍说明&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JAVA的五种引用类型及引用队列</title>
    <link href="http://yoursite.com/2019/12/20/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JAVA%E7%9A%84%E4%BA%94%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%E5%8F%8A%E5%BC%95%E7%94%A8%E9%98%9F%E5%88%97/"/>
    <id>http://yoursite.com/2019/12/20/JAVA基础——JAVA的五种引用类型及引用队列/</id>
    <published>2019-12-20T09:15:57.000Z</published>
    <updated>2019-12-22T07:22:21.159Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA-的五种引用类型及引用队列"><a href="#JAVA-的五种引用类型及引用队列" class="headerlink" title="JAVA 的五种引用类型及引用队列"></a>JAVA 的五种引用类型及引用队列</h1><p>​        在介绍 JAVA 的五种引用之前，先介绍一下什么是引用，以及引用和对象之间的关系</p><h2 id="什么是引用"><a href="#什么是引用" class="headerlink" title="什么是引用"></a>什么是引用</h2><p>​        众所周知，JAVA 是一种面向对象的语言，在 JAVA 程序运行时，对象是存储在堆内存（Heap）中的，C/C++ 中是通过指针来访问所谓对象（结构体）的，而 JAVA 则是通过引用来访问对象，也就是说，引用指向了对象在堆内存中的地址，引用本身也占用内存，64 位的 JVM 中，引用所占内存大小为 8 个字节，通过指针压缩后占用 4 个字节</p><p>​        在 JDK 1.2 之前，JAVA 对引用的定义为：如果一个数据中存储的数值代表的是另外一块内存的起始地址，就称这块数据的内存代表着一个引用</p><p>​        在 JDK 1.2 之后，JAVA 引用的概念得到了扩充，引用被分为：强引用、软引用、弱引用、虚引用、终结器引用</p><a id="more"></a><h2 id="引用和对象"><a href="#引用和对象" class="headerlink" title="引用和对象"></a>引用和对象</h2><p>​        在 JAVA 中，一切都被视为是对象，但标识符（变量名）实际上是对象的一个引用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//创建一个引用，引用可以独立存在，不是必须要关联某一对象</span></span><br><span class="line">String str;</span><br></pre></td></tr></table></figure><p>​        也可以将引用指向对象，这样操作后就可以通过引用来操作对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"123"</span>);</span><br></pre></td></tr></table></figure><h2 id="垃圾回收算法、五种引用类型及引用队列"><a href="#垃圾回收算法、五种引用类型及引用队列" class="headerlink" title="垃圾回收算法、五种引用类型及引用队列"></a>垃圾回收算法、五种引用类型及引用队列</h2><p>​        JAVA 在垃圾回收机制中判断是否要回收某一对象时，都需要引用的概念</p><h3 id="引用计数法"><a href="#引用计数法" class="headerlink" title="引用计数法"></a>引用计数法</h3><p>​        引用计数法的原理为：如果变量被引用：计数 +1，没有对象引用计数 -1，为 0 回收，很明显，当一个对象需要被循环引用时，引用计数法可能会存在问题</p><h3 id="可达性分析算法"><a href="#可达性分析算法" class="headerlink" title="可达性分析算法"></a>可达性分析算法</h3><p>​        Java 虚拟机中的垃圾回收器采用可达性分析来探索所有存活的对象：扫描堆中的对象，看是否能够沿着 GC Root 对象为起点的引用链找到该对象，找不到表示可以回收</p><h3 id="强引用"><a href="#强引用" class="headerlink" title="强引用"></a>强引用</h3><p>​        只有所有 GC Roots 对象都不通过强引用引用该对象，该对象才能被垃圾回收，换句话说就是，只要强引用存在，JVM 垃圾回收器就永远都不会回收被引用的对象，即使内存不足，JVM 会抛出 OutOfMemoryError</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只要 obj 指向 Object 对象，那它就永远都不会被 JVM 回收</span></span><br><span class="line">Object obj = <span class="keyword">new</span> Object();</span><br><span class="line"><span class="comment">//将 obj 置为 null，可以切断引用链，这样 obj 就会被 JVM 回收</span></span><br><span class="line">obj = <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure><h3 id="引用队列"><a href="#引用队列" class="headerlink" title="引用队列"></a>引用队列</h3><p>​        ReferenceQueue，当一个引用（软引用、弱引用）关联到了一个引用队列后，当这个引用所引用的对象要被垃圾回收时，就会将它加入到所关联的引用队列中，所以判断一个引用对象是否已经被回收的一个现象就是，这个对象的引用是否被加入到了它所关联的引用队列</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ReferenceQueue&lt;<span class="keyword">byte</span>[]&gt; queue = <span class="keyword">new</span> ReferenceQueue&lt;&gt;();</span><br><span class="line">SoftReference&lt;<span class="keyword">byte</span>[]&gt; ref = <span class="keyword">new</span> SoftReference&lt;&gt;(<span class="keyword">new</span> <span class="keyword">byte</span>[_4MB], queue);</span><br></pre></td></tr></table></figure><p>​        说到底，引用队列就是一个对引用的回收机制，当软引用或弱引用所包装的对象为 null 或被回收时，这个引用也就不在具有价值，引用队列就是清除掉这部分引用的一种回收机制</p><h3 id="软引用"><a href="#软引用" class="headerlink" title="软引用"></a>软引用</h3><p>​        仅有软引用引用该对象时，在垃圾回收后，内存仍不足时会再次触发垃圾回收，回收软引用对象，即在内存足够时，JVM 不会回收软引用对象，但当内存不足时，软引用对象就会被回收，所以软引用对象通常用来描述一些非必要但仍有用的对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不直接通过 list 引用 byte[]</span></span><br><span class="line"><span class="comment">//list -----&gt; SoftReference -----&gt; byte[] 添加了一层软引用</span></span><br><span class="line">List&lt;SoftReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="弱引用"><a href="#弱引用" class="headerlink" title="弱引用"></a>弱引用</h3><p>​        弱引用是较软引用更第一级的引用，只要发生垃圾回收，无论内存是否充足，JVM 都会回收掉弱引用对象</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">List&lt;WeakReference&lt;<span class="keyword">byte</span>[]&gt;&gt; list = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br></pre></td></tr></table></figure><h3 id="虚引用"><a href="#虚引用" class="headerlink" title="虚引用"></a>虚引用</h3><p>​        虚引用必须配合引用队列使用，主要配合 ByteBuffer 使用，被引用对象回收时，会将虚引用入队，由 Reference Handler 线程调用虚引用相关方法释放直接内存</p><h3 id="终结器引用"><a href="#终结器引用" class="headerlink" title="终结器引用"></a>终结器引用</h3><p>​        终结器引用无需手动编码，但其内部配合引用队列使用，在垃圾回收时，终结器引用入队（被引用对象暂时没有被回收），再由 Finalizer 线程通过终结器引用找到被引用对象并调用 finalize 方法，第二次 GC 时回收被引用对象</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JAVA-的五种引用类型及引用队列&quot;&gt;&lt;a href=&quot;#JAVA-的五种引用类型及引用队列&quot; class=&quot;headerlink&quot; title=&quot;JAVA 的五种引用类型及引用队列&quot;&gt;&lt;/a&gt;JAVA 的五种引用类型及引用队列&lt;/h1&gt;&lt;p&gt;​        在介绍 JAVA 的五种引用之前，先介绍一下什么是引用，以及引用和对象之间的关系&lt;/p&gt;
&lt;h2 id=&quot;什么是引用&quot;&gt;&lt;a href=&quot;#什么是引用&quot; class=&quot;headerlink&quot; title=&quot;什么是引用&quot;&gt;&lt;/a&gt;什么是引用&lt;/h2&gt;&lt;p&gt;​        众所周知，JAVA 是一种面向对象的语言，在 JAVA 程序运行时，对象是存储在堆内存（Heap）中的，C/C++ 中是通过指针来访问所谓对象（结构体）的，而 JAVA 则是通过引用来访问对象，也就是说，引用指向了对象在堆内存中的地址，引用本身也占用内存，64 位的 JVM 中，引用所占内存大小为 8 个字节，通过指针压缩后占用 4 个字节&lt;/p&gt;
&lt;p&gt;​        在 JDK 1.2 之前，JAVA 对引用的定义为：如果一个数据中存储的数值代表的是另外一块内存的起始地址，就称这块数据的内存代表着一个引用&lt;/p&gt;
&lt;p&gt;​        在 JDK 1.2 之后，JAVA 引用的概念得到了扩充，引用被分为：强引用、软引用、弱引用、虚引用、终结器引用&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JVM之虚拟机堆和方法区</title>
    <link href="http://yoursite.com/2019/12/03/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JVM%E4%B9%8B%E6%96%B9%E6%B3%95%E5%8C%BA%E5%92%8C%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%A0%86/"/>
    <id>http://yoursite.com/2019/12/03/JAVA基础——JVM之方法区和虚拟机堆/</id>
    <published>2019-12-03T09:02:35.000Z</published>
    <updated>2019-12-04T13:17:30.131Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM-虚拟机堆和方法区"><a href="#JVM-虚拟机堆和方法区" class="headerlink" title="JVM 虚拟机堆和方法区"></a>JVM 虚拟机堆和方法区</h1><p>​        虚拟机堆和方法区都存在与 JVM 的线程共享区，占有 JVM 内存中的很大一部分</p><a id="more"></a><h2 id="虚拟机堆"><a href="#虚拟机堆" class="headerlink" title="虚拟机堆"></a>虚拟机堆</h2><p>​        堆（Haep），在 Java 中所有通过 new 关键字创建的对象都会使用堆内存，堆是线程共享的，在堆中的对象都需要考虑线程安全问题（只要局部变量不逃逸出方法的作用范围，它就是线程安全的），另外堆还存在垃圾回收机制</p><p>​        垃圾回收机制是回收不再被引用、使用的变量，如果不断产生新的对象且都有人在使用，当对象数量达到一定限度时，就会产生堆内存溢出（OutOfMemoryError），可以通过指令设置堆内存上限</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">-Xmx10m</span><br><span class="line">//设置堆内存上限为 10M</span><br></pre></td></tr></table></figure><h2 id="方法区（Method-Area）"><a href="#方法区（Method-Area）" class="headerlink" title="方法区（Method Area）"></a>方法区（Method Area）</h2><p>​        方法区和虚拟机堆一样，是线程共享区的一部分，JVM 规范指出，方法区逻辑上是虚拟机堆的一部分，但不强制方法区的位置，它用于存储已被虚拟机加载的类信息、常量池、静态变量、即时编译器编译后的代码等数据</p><p>​        方法区的官方定义如下：</p><blockquote><p>2.5.4. Method Area<br>The Java Virtual Machine has a method area that is shared among all Java Virtual Machine threads. The method area is analogous to the storage area for compiled code of a conventional language or analogous to the “text” segment in an operating system process. It stores per-class structures such as the run-time constant pool, field and method data, and the code for methods and constructors, including the special methods used in class and instance initialization and interface initialization. The method area is created on virtual machine start-up. Although the method area is logically part of the heap, simple implementations may choose not to either garbage collect or compact it. This specification does not mandate the location of the method area or the policies used to manage compiled code. The method area may be of a fixed size or may be expanded as required by the computation and may be contracted if a larger method area becomes unnecessary. The memory for the method area does not need to be contiguous.</p></blockquote><h3 id="永久代（Permanent-Generation）"><a href="#永久代（Permanent-Generation）" class="headerlink" title="永久代（Permanent Generation）"></a>永久代（Permanent Generation）</h3><p>​        永久代是 HotSpot 虚拟机对方法区的具体实现，永久代本身也存在于虚拟机堆中，在 JDK 1.7 中，移除永久代的工作就已经开始了，存储在永久代中的数据转移到了虚拟机堆或者 Native Memory 中</p><h3 id="元空间（Meta-Space）"><a href="#元空间（Meta-Space）" class="headerlink" title="元空间（Meta Space）"></a>元空间（Meta Space）</h3><p>​        从 JDK 1.8 开始，HotSpot 虚拟机完全移除了永久代，改为在 Native Memory 中存放这些数据，新的空间被称为元空间</p><h3 id="常量池（Constant-Pool）"><a href="#常量池（Constant-Pool）" class="headerlink" title="常量池（Constant Pool）"></a>常量池（Constant Pool）</h3><p>​        一个类的二进制字节码文件大约分为三部分：类的基本信息、常量池、包含的虚拟机指令</p><p>​        常量池的作用是为虚拟机指令提供“常量符号”，根据“常量符号”，虚拟机指令可以找到常量池中存在的数据，所以常量池就是一张表，虚拟机指令根据这张常量表找到要执行的类型、方法名、参数类型、字面量等信息，存在于 .class 文件中</p><h4 id="运行时常量池"><a href="#运行时常量池" class="headerlink" title="运行时常量池"></a>运行时常量池</h4><p>​        当一个类被加载时，它的常量池信息就会放入运行时常量池，并把里面的符号地址变为真实地址</p><h4 id="串池（String-Table）"><a href="#串池（String-Table）" class="headerlink" title="串池（String Table）"></a>串池（String Table）</h4><p>​        为避免字符串被重复创建，JVM 引入了串池的概念，当一个字符串变成字符串对象时，该字符串会在已经被创建好的串池中查找是否有同名的字符串，如果有，就将已存在的字符串的地址赋给该字符串对象，如果没有就将该字符串放入串池中，从而降低相同值得字符串变量对内存得消耗</p><p>​        实际上，串池得本质是一个 Hash Table，字符串是它的 KEY，每当有字符串变成字符串变量时，就会检查串池中是否存在和该字符串同名得 KEY，另外，String Table 不能扩容，在 JDK 1.6 中存在于常量池中，在 1.8 时存在于堆中</p><p>​        javac 会在编译期对字符串变量进行优化，例如：String str = “a” + “b”，JVM 认为，”a”是常量，”b”也是常量，所以变量 str 的值在编译期已经决定了，所以会直接将 str 赋值为 “ab”</p><p>#####String.intern()</p><p>​        String.intern 方法，可以将通过 new 创建的 String 对象放入串池中，并且返回放入串池中的字符串</p><h5 id="直接定义的-String-类型变量和通过-new-创建的-String-对象的区别"><a href="#直接定义的-String-类型变量和通过-new-创建的-String-对象的区别" class="headerlink" title="直接定义的 String 类型变量和通过 new 创建的 String 对象的区别"></a>直接定义的 String 类型变量和通过 new 创建的 String 对象的区别</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="string">"a"</span>;</span><br></pre></td></tr></table></figure><p>​        创建 str 对象，在 String Table 中查找”a”字符串，如果有，就将 String Table 中”a”字符串的地址赋给 str，如果没有，就将”a”字符串放入 String Table 中，并把 String Table 中的”a”字符串的地址赋给 str</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">String str = <span class="keyword">new</span> String(<span class="string">"a"</span>);</span><br></pre></td></tr></table></figure><p>​        创建 str 对象，在 String Table 中查找”a”字符串，如果有，在虚拟机堆中复制（创建）一个”a”字符串对象，如果没有，就在 String Table 中放入”a”字符串，再在虚拟机堆中创建一个 String Table 中”a”字符串的复制对象</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM-虚拟机堆和方法区&quot;&gt;&lt;a href=&quot;#JVM-虚拟机堆和方法区&quot; class=&quot;headerlink&quot; title=&quot;JVM 虚拟机堆和方法区&quot;&gt;&lt;/a&gt;JVM 虚拟机堆和方法区&lt;/h1&gt;&lt;p&gt;​        虚拟机堆和方法区都存在与 JVM 的线程共享区，占有 JVM 内存中的很大一部分&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JVM之Java虚拟机栈</title>
    <link href="http://yoursite.com/2019/12/02/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JVM%E4%B9%8BJava%E8%99%9A%E6%8B%9F%E6%9C%BA%E6%A0%88/"/>
    <id>http://yoursite.com/2019/12/02/JAVA基础——JVM之Java虚拟机栈/</id>
    <published>2019-12-02T08:02:28.000Z</published>
    <updated>2019-12-02T11:17:56.922Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Java-虚拟机栈"><a href="#Java-虚拟机栈" class="headerlink" title="Java 虚拟机栈"></a>Java 虚拟机栈</h1><p>​        虚拟机栈描述的是 Java 方法执行的动态内存模型</p><a id="more"></a><h2 id="虚拟机栈的内容"><a href="#虚拟机栈的内容" class="headerlink" title="虚拟机栈的内容"></a>虚拟机栈的内容</h2><h3 id="栈帧"><a href="#栈帧" class="headerlink" title="栈帧"></a>栈帧</h3><p>​        在 Java 程序中的每个方法执行时，都会创建一个栈帧，伴随着方法从创建到执行完成，用于存储局部变量表、操作数栈、动态链接、方法出口等</p><p>​        虚拟机栈是存在大小的，当方法所占用的空间溢出，会产生 StackOverflowError</p><h3 id="局部变量表"><a href="#局部变量表" class="headerlink" title="局部变量表"></a>局部变量表</h3><p>​        局部表量表的内存空间在编译期即完成分配，主要保存函数的参数以及局部的变量信息，局部变量表中的变量作用域是当前调用的函数，函数调用结束后，随着函数栈帧的销毁，局部变量表也随之销毁，释放空间</p><p>​        局部变量表的最小存储单位是变量槽（Slot），槽的大小与操作系统位数相同，可以放下操作系统位数以内的数据类型</p><h3 id="操作数栈"><a href="#操作数栈" class="headerlink" title="操作数栈"></a>操作数栈</h3><p>​        操作数栈可理解为java虚拟机栈中的一个用于计算的临时数据存储区，局部变量表使用索引，操作数栈是通过出栈、入栈来访问，存储的数据与局部变量表一致含 int、long、float、double、reference、returnType，操作数栈中 byte、short、char 压栈前会被转为 int</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Java-虚拟机栈&quot;&gt;&lt;a href=&quot;#Java-虚拟机栈&quot; class=&quot;headerlink&quot; title=&quot;Java 虚拟机栈&quot;&gt;&lt;/a&gt;Java 虚拟机栈&lt;/h1&gt;&lt;p&gt;​        虚拟机栈描述的是 Java 方法执行的动态内存模型&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JVM简介及程序计数器</title>
    <link href="http://yoursite.com/2019/12/01/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JVM%E7%AE%80%E4%BB%8B%E5%8F%8A%E7%A8%8B%E5%BA%8F%E8%AE%A1%E6%95%B0%E5%99%A8/"/>
    <id>http://yoursite.com/2019/12/01/JAVA基础——JVM简介及程序计数器/</id>
    <published>2019-12-01T08:34:08.000Z</published>
    <updated>2019-12-01T10:30:43.130Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h1><p>​        JVM（Java 虚拟机），是一种用于计算设备的规范，是一个虚构出来的计算机，通过在实际的计算机上仿真模拟各种计算功能来实现，引入 JVM 后，Java 语言在不同平台上运行时不需要重新编译，它屏蔽了与具体平台相关的信息，使得 Java 程序只需生成在 JVM 上运行的字节码文件，就可以在多种平台上不加修改的运行</p><a id="more"></a><h2 id="JVM-基本结构"><a href="#JVM-基本结构" class="headerlink" title="JVM 基本结构"></a>JVM 基本结构</h2><p>​        首先，JVM 分为线程共享区和线程独占区两部分，线程共享区即线程公有，可以所有线程共享，向下分为方法区和 Java 堆，线程独占区即线程私有，向下分为虚拟机栈、本地方法栈以及一会会详细介绍的程序计数器</p><p>具体结构如图：</p><p><img src="https://img-blog.csdnimg.cn/20191201151515479.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70" alt></p><h2 id="JVM-程序计数器"><a href="#JVM-程序计数器" class="headerlink" title="JVM 程序计数器"></a>JVM 程序计数器</h2><p>​        程序计数器是一个记录着当前线程所执行到的字节码行号</p><h3 id="程序计数器的特点"><a href="#程序计数器的特点" class="headerlink" title="程序计数器的特点"></a>程序计数器的特点</h3><ol><li><p>线程隔离，每个线程工作室都有属于自己的独立计数器</p></li><li><p>执行 Java 方法时，程序计数器是有值的，且记录的是正在执行的字节码指令的地址</p></li><li><p>执行本地方法时，程序计数器的值为空（Undefined），因为 native 方法时 java 通过 JNI（Java 本地接口）直接调用本地的 C/C++ 库，由于此方法是通过 C/C++ 实现的，无法生成字节码文件，所以其在执行时内存的分配不是由 JVM 决定的</p></li><li><p>程序计数器占用的内存很小，在进行 JVM 内存计算时，可以忽略</p></li><li><p>另外，JVM 中只有程序计数器没有规定任何 OutOfMemoryError</p></li></ol>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JVM&quot;&gt;&lt;a href=&quot;#JVM&quot; class=&quot;headerlink&quot; title=&quot;JVM&quot;&gt;&lt;/a&gt;JVM&lt;/h1&gt;&lt;p&gt;​        JVM（Java 虚拟机），是一种用于计算设备的规范，是一个虚构出来的计算机，通过在实际的计算机上仿真模拟各种计算功能来实现，引入 JVM 后，Java 语言在不同平台上运行时不需要重新编译，它屏蔽了与具体平台相关的信息，使得 Java 程序只需生成在 JVM 上运行的字节码文件，就可以在多种平台上不加修改的运行&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JAVA简介和运行原理</title>
    <link href="http://yoursite.com/2019/11/27/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JAVA%E7%AE%80%E4%BB%8B/"/>
    <id>http://yoursite.com/2019/11/27/JAVA基础——JAVA简介/</id>
    <published>2019-11-27T02:12:54.000Z</published>
    <updated>2019-11-27T11:53:13.606Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA"><a href="#JAVA" class="headerlink" title="JAVA"></a>JAVA</h1><p>​        本系列主要更新 Java 基础相关的知识，最近准备重新复习一遍 Java 基础，主要涉及一些原理上的东西，会持续更新！</p><a id="more"></a><p>##Java 简介</p><p>​        Java 是一种简洁的、面向对象的、分布式的、解释型的、健壮安全的、结构中立的、可移植的、性能优异、多线程的动态语言</p><p>​        看不懂吧，简单来说，Java 就是一种面向对象的编程语言，功能完善、安全、使用广泛，在 WEB</p><p> 程序设计、嵌入式开发、桌面应用开发等开发工作中都占有一席之地</p><p>##Java 平台</p><p>​        当前 Java 技术的平台架构包括三方面：</p><p>​        Java SE：开发部署在桌面、服务器、嵌入式环境和实时环境的 Java 应用程序，包含了 Java Web 服务开发的类，为 Java EE 提供基础</p><p>​        Java EE：帮助开发和部署可移植、健壮、可伸缩且安全的服务器端 Java 应用程序。Java EE 是在 Java SE 的基础上构建的，提供了 Web 服务、组件模型、管理和通信 API，且可以用来实现企业级的面向服务体系结构和 Web 应用程序</p><p>​        Java ME：为在移动设备和嵌入式设备上运行的应用程序提供了一个健壮且灵活的环境，Java ME 包括灵活的用户界面、健壮的安全模式</p><h2 id="Java-运行流程"><a href="#Java-运行流程" class="headerlink" title="Java 运行流程"></a>Java 运行流程</h2><p>​        1.使用文字编辑软件或集成开发环境编辑 Java 源文件，扩展名为 .java</p><p>​        2.通过编译 .java 文件，生成同名的 .class 字节码文件</p><p>​        3.通过 JVM 解释方式，将 .class 字节码文件转变为由 0 或 1 组成的二进制指令（机器码）运行</p><h2 id="JDK"><a href="#JDK" class="headerlink" title="JDK"></a>JDK</h2><p>​        JDK 是 Java 开发包（开发工具），JDK 是整个 Java 的核心，包含了 JRE，Java 工具类和 Java 核心类库</p><p>​        JDK 适合编译解释小型 Java 文件，随着项目体积的变大，使用 JDK 来维护各类（class）间的依赖关系将变得十分繁琐和复杂</p><h2 id="JRE"><a href="#JRE" class="headerlink" title="JRE"></a>JRE</h2><p>​        JRE 是 Java 运行环境，包含了 JVM（Java 虚拟机）标准实现及 Java 核心类库，但不包含编译器、调试器和其他工具</p><h2 id="JVM"><a href="#JVM" class="headerlink" title="JVM"></a>JVM</h2><p>​        JVM 是 Java 虚拟机，是 Java 跨平台性的基础，Java 的 .class 字节码文件因为会在 JVM 中被解释成面型不同系统的机器码文件，所以 Java 才具有了跨平台性</p><h3 id="JVM-的内存模型"><a href="#JVM-的内存模型" class="headerlink" title="JVM 的内存模型"></a>JVM 的内存模型</h3><blockquote><p>运行时数据区</p><blockquote><p>方法区</p><p>虚拟机栈</p><p>本地方法栈</p><p>堆</p><p>程序计数器</p></blockquote><p>执行引擎</p><p>本地接口</p><p>本地方法库</p></blockquote><p>​        JVM 还有很多内容，我还在继续学习！</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JAVA&quot;&gt;&lt;a href=&quot;#JAVA&quot; class=&quot;headerlink&quot; title=&quot;JAVA&quot;&gt;&lt;/a&gt;JAVA&lt;/h1&gt;&lt;p&gt;​        本系列主要更新 Java 基础相关的知识，最近准备重新复习一遍 Java 基础，主要涉及一些原理上的东西，会持续更新！&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>Hibernate——其他查询方法</title>
    <link href="http://yoursite.com/2019/11/25/Hibernate%E6%A1%86%E6%9E%B6%E2%80%94%E2%80%94%E5%85%B6%E4%BB%96%E6%9F%A5%E8%AF%A2%E6%96%B9%E6%B3%95/"/>
    <id>http://yoursite.com/2019/11/25/Hibernate框架——其他查询方法/</id>
    <published>2019-11-25T10:32:30.000Z</published>
    <updated>2019-11-25T12:16:08.921Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Hibernate-框架的查询方法"><a href="#Hibernate-框架的查询方法" class="headerlink" title="Hibernate 框架的查询方法"></a>Hibernate 框架的查询方法</h1><p>​        除了通过 session.get() 方法进行查询外，Hibernate 框架还提供了其他的查询方式</p><a id="more"></a><h2 id="Query-查询对象"><a href="#Query-查询对象" class="headerlink" title="Query 查询对象"></a>Query 查询对象</h2><p>​        query 查询对象可以通过设置查询条件进行查询，使用 HQL 语言（Hibernate Query Language），是 Hibernate 的面向对象查询语言，最终底层要转成面向数据库查询语言</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//1.查询所有用户</span></span><br><span class="line">Query query = session.createQuery(<span class="string">"From User"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.查询符合条件得用户【username 和 password 是 User 对象得属性，而不是表的字段名】</span></span><br><span class="line">Query query = session.createQuery(<span class="string">"From User where username = ? and password = ?"</span>);</span><br><span class="line">query.setParameter(<span class="number">0</span>, <span class="string">"lmh"</span>);</span><br><span class="line">query.setParameter(<span class="number">1</span>, <span class="string">"123"</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.分页查询</span></span><br><span class="line">Query query = session.creatQuery(<span class="string">"From User"</span>);</span><br><span class="line">query.setMaxResults(<span class="number">3</span>);</span><br><span class="line">query.setFirstResult(<span class="number">3</span>);</span><br></pre></td></tr></table></figure><h2 id="Criteria-查询对象"><a href="#Criteria-查询对象" class="headerlink" title="Criteria 查询对象"></a>Criteria 查询对象</h2><p>​        QBC（query by criteria），是 hibernate 提供纯面向对象查询得语言，提供直接使用 PO 对象进行操作</p><p>​        PO：persistent object，用于与数据库交互数据——dao 层（JavaBean + hbm）</p><p>​        BO：business object，业务数据对象——service 层</p><p>​        VO：value object 值对象——web 层</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Criteria：hibernate 独创的查询对象，全程无 hql 语言</span></span><br><span class="line">Criteria criteria = session.createCriteria(User.class);</span><br><span class="line"></span><br><span class="line"><span class="comment">//等于 =</span></span><br><span class="line">criteria.add(Restriction.eq(<span class="string">"lmh"</span>, <span class="string">"123"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//like</span></span><br><span class="line">criteria.add(Restriction.like(<span class="string">"lmh"</span>, <span class="string">"%123%"</span>));</span><br><span class="line"></span><br><span class="line"><span class="comment">//..........</span></span><br></pre></td></tr></table></figure><h2 id="SQLQuery-查询对象"><a href="#SQLQuery-查询对象" class="headerlink" title="SQLQuery 查询对象"></a>SQLQuery 查询对象</h2><p>​        SQLQuery：使用原生的 SQL 语句查询</p><p>​        并不是所有的 sql 都能转成 hql</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">SQLQuery query = session.createSQLQuery(<span class="string">"select * from t_user"</span>);</span><br></pre></td></tr></table></figure><h2 id="文件逻辑优化"><a href="#文件逻辑优化" class="headerlink" title="文件逻辑优化"></a>文件逻辑优化</h2><h3 id="使用工具类"><a href="#使用工具类" class="headerlink" title="使用工具类"></a>使用工具类</h3><p>​        将重复代码封装进工具类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> org.hibernate.Session;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.SessionFactory;</span><br><span class="line"><span class="keyword">import</span> org.hibernate.cfg.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HibernateUtils</span> </span>&#123;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> SessionFactory sf;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"><span class="comment">//1.加载配置</span></span><br><span class="line">Configuration cfg = <span class="keyword">new</span> Configuration().configure();</span><br><span class="line"></span><br><span class="line"><span class="comment">//2.创建一个sessionFactory</span></span><br><span class="line">sf = cfg.buildSessionFactory();</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.在虚拟机关闭时，释放SessionFactory</span></span><br><span class="line">Runtime.getRuntime().addShutdownHook(<span class="keyword">new</span> Thread()&#123;</span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">sf.close();</span><br><span class="line">System.out.println(<span class="string">"释放资源"</span>);</span><br><span class="line">&#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">openSession</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> sf.openSession();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Session <span class="title">getCurrentSession</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">return</span> sf.getCurrentSession();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Hibernate-框架的查询方法&quot;&gt;&lt;a href=&quot;#Hibernate-框架的查询方法&quot; class=&quot;headerlink&quot; title=&quot;Hibernate 框架的查询方法&quot;&gt;&lt;/a&gt;Hibernate 框架的查询方法&lt;/h1&gt;&lt;p&gt;​        除了通过 session.get() 方法进行查询外，Hibernate 框架还提供了其他的查询方式&lt;/p&gt;
    
    </summary>
    
    
      <category term="Hibernate框架" scheme="http://yoursite.com/tags/Hibernate%E6%A1%86%E6%9E%B6/"/>
    
  </entry>
  
</feed>
