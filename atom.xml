<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Step By Step</title>
  
  <subtitle>耀出千分光</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-02-27T15:25:11.508Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>LiMinghui</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>算法——使用DFS解决全排列问题</title>
    <link href="http://yoursite.com/2020/02/27/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8DFS%E8%A7%A3%E5%86%B3%E5%85%A8%E6%8E%92%E5%88%97%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/02/27/算法——使用DFS解决全排列问题/</id>
    <published>2020-02-27T14:48:40.000Z</published>
    <updated>2020-02-27T15:25:11.508Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-DFS"><a href="#什么是-DFS" class="headerlink" title="什么是 DFS"></a>什么是 DFS</h1><p>​        DFS 是深度优先遍历，将序列抽象成树状结构，以优先深度的方式进行遍历，获取想要的结果</p><a id="more"></a><h2 id="例如"><a href="#例如" class="headerlink" title="例如"></a>例如</h2><p>​        假设一个树的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">    1 </span><br><span class="line">  2   3</span><br><span class="line">4  5 5  7</span><br></pre></td></tr></table></figure><p>​        使用深度优先遍历的遍历顺序就是<code>1-&gt;2-&gt;4-&gt;5-&gt;3-&gt;5-&gt;7</code>，也就是说，深度优先遍历会从根节点<code>root</code>开始，以深度优先遍历到其一个 <em>不能再继续向下遍历</em> 的子孙节点，然后回溯到该节点的父节点，再重复向下遍历和回溯的过程</p><h2 id="优缺点"><a href="#优缺点" class="headerlink" title="优缺点"></a>优缺点</h2><p>​        DFS 的优点是，使用 DFS 进行遍历，空间的占用是<code>O(h)</code>（h 为树的高度）级别的，因为空间占有最多的时候，也就是遍历到最深的叶子节点时，此时空间的使用是等于树的高度的</p><p>​        而由于 DFS 执着与向下搜索，可能会错过更近的答案，从而浪费运算的时间，即如果树的第二层和第五层都存在答案，DFS 可能会先找到第五层的目标而不是第二层的</p><h1 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h1><p>​        这是一道全排列问题，即给定<code>n</code>，我们要给出<code>1 ~ n</code>这些数字所能排列出的所有情况，这里<code>1 ≤ n ≤ 7</code></p><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>​        首先考虑思路，全排列问题是经典的 DFS 问题，假定<code>n = 3</code>，我们要给出<code>1 ~ 3</code>的全排列，正确结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1 2 3 </span><br><span class="line">1 3 2 </span><br><span class="line">2 1 3 </span><br><span class="line">2 3 1 </span><br><span class="line">3 1 2 </span><br><span class="line">3 2 1</span><br></pre></td></tr></table></figure><p>​        我们可以把它抽象为一个树，我们首先考虑第一位的元素，有三种情况<code>1、2、3</code>，这就是树的三个分支，再考虑<code>1</code>的分支的第二位，有<code>12、13</code>两种情况，这两种情况又是<code>1</code>的两个分支，在考虑<code>12</code>，只剩<code>123</code>一种情况了，到此，从<code>1</code>开始的一个分支就彻底结束了，我们也得到了全排列的第一个情况</p><p>​        这是我们还位于<code>123</code>，下一步就是回溯，向上回溯，首先来到<code>12</code>，我们发现它只有<code>123</code>一个分支，已经被遍历完了，所以继续向上回溯，来到<code>1</code>，我们发现它还有一个<code>13</code>分支没有遍历，我们就继续遍历<code>13</code>，如此一直重复下去，直到所有的分支都遍历结束后，我们也就得到了全排列的全部结果</p><h2 id="代码-注释"><a href="#代码-注释" class="headerlink" title="代码 + 注释"></a>代码 + 注释</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="comment">// 用来存储结果的数组</span></span><br><span class="line"><span class="keyword">int</span> path[N];</span><br><span class="line"><span class="comment">// 用来标志元素是否被使用过的数组</span></span><br><span class="line"><span class="keyword">bool</span> st[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> u)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 如果 dfs 层数 == 最大深度，就输出这种情况</span></span><br><span class="line">    <span class="keyword">if</span> (u == n) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%d "</span>, path[i]);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 深度优先遍历</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++) &#123;</span><br><span class="line">        <span class="comment">// 每遍历到一个元素，先检测是否重复</span></span><br><span class="line">        <span class="keyword">if</span> (!st[i]) &#123;</span><br><span class="line">            <span class="comment">// 设定当前位置的值</span></span><br><span class="line">            path[u] = i;</span><br><span class="line">            <span class="comment">// 将这个值标记为已用</span></span><br><span class="line">            st[i] = <span class="literal">true</span>;</span><br><span class="line">            <span class="comment">// 继续向下遍历</span></span><br><span class="line">            dfs(u + <span class="number">1</span>);</span><br><span class="line">            <span class="comment">// 恢复原样</span></span><br><span class="line">            st[i] = <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line">    <span class="comment">// 从 0 开始 DFS</span></span><br><span class="line">    dfs(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是-DFS&quot;&gt;&lt;a href=&quot;#什么是-DFS&quot; class=&quot;headerlink&quot; title=&quot;什么是 DFS&quot;&gt;&lt;/a&gt;什么是 DFS&lt;/h1&gt;&lt;p&gt;​        DFS 是深度优先遍历，将序列抽象成树状结构，以优先深度的方式进行遍历，获取想要的结果&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JDK实现的动态代理</title>
    <link href="http://yoursite.com/2020/02/21/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JDK%E5%AE%9E%E7%8E%B0%E7%9A%84%E5%8A%A8%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2020/02/21/JAVA基础——JDK实现的动态代理/</id>
    <published>2020-02-21T03:02:32.000Z</published>
    <updated>2020-02-22T01:47:27.066Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA-中的动态代理"><a href="#JAVA-中的动态代理" class="headerlink" title="JAVA 中的动态代理"></a>JAVA 中的动态代理</h1><p>​        动态代理和静态代理类的区别在于，动态代理可以在程序运行时，动态地创建代理类，执行被代理类方法的同时，可以运行被代理类调用的拓展方法</p><a id="more"></a><h1 id="JDK-实现的动态代理"><a href="#JDK-实现的动态代理" class="headerlink" title="JDK 实现的动态代理"></a>JDK 实现的动态代理</h1><p>​        </p><p>​        JDK 的动态代理要通过<code>import java.lang.reflect</code>包中的内容实现，代理类需要调用该包下的<code>Proxy</code>类下的<code>newProxyInstance</code>方法，返回一个<code>Object</code>类型的对象，这个对象就是实现代理类功能的对象，通过强制转换，可以转换为被代理类的对象使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Object <span class="title">newProxyInstance</span><span class="params">(ClassLoader loader,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      Class&lt;?&gt;[] interfaces,</span></span></span><br><span class="line"><span class="function"><span class="params">                                      InvocationHandler h)</span></span></span><br></pre></td></tr></table></figure><p>​        上边是<code>newProxyInstance</code>方法的定义，该方法中有三个参数，第一个<code>ClassLoader</code>类型是一个类加载器，这个参数是要加载当前的代理类，即假如代理类名为<code>userServiceProxy</code>，这里的参数即为<code>userServiceProxy.class.getClassLoader()</code>，第二个则是一个接口，用来表示包含被代理类全部内容的接口</p><p>​        最后一个参数是一个<code>InvocationHandler</code>的接口，它内部只有一个<code>invoke</code>方法，用来实现代理类中向被代理类拓展内容的功能，<code>InvocationHandler</code>类定义如下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">InvocationHandler</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span></span></span><br><span class="line"><span class="function">        <span class="keyword">throws</span> Throwable</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        所以我们实现的<code>InvocationHandler</code>接口也需要重写这个方法，这个方法也是我们关联代理类和被代理类的关键，该方法需要返回一个<code>Object</code>类型的对象，我们通过反射，让被代理类和代理类产生关联，并且在这方法中，我们可以自行在其中定义拓展内容</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><p>​        接口、实现类（被代理类）、切面方法类同之前静态代理的没有区别，地址戳：<a href="https://blog.csdn.net/scfor333/article/details/104420155" target="_blank" rel="noopener">https://blog.csdn.net/scfor333/article/details/104420155</a></p><h2 id="代理类"><a href="#代理类" class="headerlink" title="代理类"></a>代理类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jdkProxy;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.InvocationHandler;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Method;</span><br><span class="line"><span class="keyword">import</span> java.lang.reflect.Proxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> UserService <span class="title">createUserService</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line">        MyAspcet aspcet = <span class="keyword">new</span> MyAspcet();</span><br><span class="line">        UserService userServiceProxy = (UserService) Proxy.newProxyInstance(</span><br><span class="line">            UserServiceProxy.class.getClassLoader(), </span><br><span class="line">            userService.getClass().getInterfaces(), </span><br><span class="line">            <span class="keyword">new</span> InvocationHandler()&#123;</span><br><span class="line">            </span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> Object <span class="title">invoke</span><span class="params">(Object proxy, Method method, Object[] args)</span> <span class="keyword">throws</span> Throwable </span>&#123;</span><br><span class="line">                    <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">                    aspcet.before();</span><br><span class="line">                    Object retObj = method.invoke(userService, args);</span><br><span class="line">                    System.out.println(<span class="string">"拦截到的返回值"</span> + retObj);</span><br><span class="line">                    aspcet.after();</span><br><span class="line">                    <span class="keyword">return</span> retObj;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        <span class="keyword">return</span> userServiceProxy;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="测试类"><a href="#测试类" class="headerlink" title="测试类"></a>测试类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> jdkProxy;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService userService = UserServiceProxy.createUserService();</span><br><span class="line">        userService.add();</span><br><span class="line">        userService.delete();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">before method</span><br><span class="line">service add</span><br><span class="line">拦截到的返回值null</span><br><span class="line">after method</span><br><span class="line">before method</span><br><span class="line">service delete</span><br><span class="line">拦截到的返回值null</span><br><span class="line">after method</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JAVA-中的动态代理&quot;&gt;&lt;a href=&quot;#JAVA-中的动态代理&quot; class=&quot;headerlink&quot; title=&quot;JAVA 中的动态代理&quot;&gt;&lt;/a&gt;JAVA 中的动态代理&lt;/h1&gt;&lt;p&gt;​        动态代理和静态代理类的区别在于，动态代理可以在程序运行时，动态地创建代理类，执行被代理类方法的同时，可以运行被代理类调用的拓展方法&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——静态代理</title>
    <link href="http://yoursite.com/2020/02/20/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94%E9%9D%99%E6%80%81%E4%BB%A3%E7%90%86/"/>
    <id>http://yoursite.com/2020/02/20/JAVA基础——静态代理/</id>
    <published>2020-02-20T14:19:45.000Z</published>
    <updated>2020-02-20T14:56:22.468Z</updated>
    
    <content type="html"><![CDATA[<h1 id="JAVA-中的代理"><a href="#JAVA-中的代理" class="headerlink" title="JAVA 中的代理"></a>JAVA 中的代理</h1><p>​        代理是一种<code>23</code>种经典设计模式之一，可以实现在不改变功能函数的情况下，实现对该函数、对象的功能拓展</p><a id="more"></a><h1 id="静态代理"><a href="#静态代理" class="headerlink" title="静态代理"></a>静态代理</h1><p>​        静态代理是一种手动实现的，在程序运行之前代理类和被代理类的代理关系已经被确定好了，在使用静态代理时，代理类和被代理类必须实现同一个接口，演示如下</p><p>​        首先是接口类，很简单，就两个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Aspect;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 接口类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        然后是被代理类，直接实现接口类的方法，并打印输出以区分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Aspect;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 被代理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceImpl</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">"service add"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        System.out.println(<span class="string">"service delete"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这里我还自己定义了一个切面方法类，用来表示需要插入在功能函数前后的拓展方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Aspect;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 切面方法类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">myAspect</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">before</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"before method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">after</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"after method"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        然后我们来实现代理类，所谓代理类就是要代理执行被代理类中的功能，所以要在代理类中创建一个被代理类对象，之前说过，静态代理实现的前提是代理类和被代理类必须实现同一个接口</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Aspect;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 代理类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceProxy</span> <span class="keyword">implements</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    UserService userService = <span class="keyword">new</span> UserServiceImpl();</span><br><span class="line"></span><br><span class="line">    myAspect aspect = <span class="keyword">new</span> myAspect();</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">add</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        aspect.before();</span><br><span class="line">        userService.add();</span><br><span class="line">        aspect.after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">// TODO Auto-generated method stub</span></span><br><span class="line">        aspect.before();</span><br><span class="line">        userService.delete();</span><br><span class="line">        aspect.after();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        最后我们实现一个测试类，通过接口指向实现类来创建一个代理类对象，调用其中的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> Aspect;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 测试类</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        UserService userService = <span class="keyword">new</span> UserServiceProxy();</span><br><span class="line">        userService.add();</span><br><span class="line">        userService.delete();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">before method</span><br><span class="line">service add</span><br><span class="line">after method</span><br><span class="line">before method</span><br><span class="line">service delete</span><br><span class="line">after method</span><br></pre></td></tr></table></figure><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>​        这就是 JAVA 中的静态代理，静态代理很简陋，没有什么不好理解的地方，在使用上也没有十分方便，由于静态的原因，使用前代理类和被代理类的关系需要提前设定好，所以静态代理也存在很大的局限性</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;JAVA-中的代理&quot;&gt;&lt;a href=&quot;#JAVA-中的代理&quot; class=&quot;headerlink&quot; title=&quot;JAVA 中的代理&quot;&gt;&lt;/a&gt;JAVA 中的代理&lt;/h1&gt;&lt;p&gt;​        代理是一种&lt;code&gt;23&lt;/code&gt;种经典设计模式之一，可以实现在不改变功能函数的情况下，实现对该函数、对象的功能拓展&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>算法——插入排序及优化（希尔排序）</title>
    <link href="http://yoursite.com/2020/02/17/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%E5%8F%8A%E4%BC%98%E5%8C%96%EF%BC%88%E5%B8%8C%E5%B0%94%E6%8E%92%E5%BA%8F%EF%BC%89/"/>
    <id>http://yoursite.com/2020/02/17/算法——插入排序及优化（希尔排序）/</id>
    <published>2020-02-17T07:56:47.000Z</published>
    <updated>2020-02-17T08:22:52.576Z</updated>
    
    <content type="html"><![CDATA[<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><p>​        插入排序是排序算法的一种，顾名思义，是一种插入的形态进行排序的算法</p><a id="more"></a><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><p>​        插入排序的过程可以形象的比做我们打扑克抓牌时，整理扑克牌的过程，每次我们抽一张新牌时，会以特定的规律，将其插入到已有的牌中，使手中的牌形成一个有序的牌的集合</p><p>​        插入排序也是如此我们使用两个嵌套的<code>for</code>循环从头开始遍历一个序列，外部的<code>for</code>循环顺序向下执行，内部的<code>for</code>循环负责比较其当前遍历的位置元素是否小于（或大于）它前面的所有元素，如果是，就调换其位置，以此类推，最后得到一个有序的序列</p><h2 id="Java-代码"><a href="#Java-代码" class="headerlink" title="Java 代码"></a>Java 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insertionSort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = nums.length;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; N; i++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt; <span class="number">0</span> &amp;&amp; nums[j] &lt; nums[j - <span class="number">1</span>]; j--) &#123;</span><br><span class="line">            <span class="keyword">int</span> item = nums[j - <span class="number">1</span>];</span><br><span class="line">            nums[j - <span class="number">1</span>] = nums[j];</span><br><span class="line">            nums[j] = item;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="思考"><a href="#思考" class="headerlink" title="思考"></a>思考</h2><p>​        从插入排序的定义中我们可以发现，如果一个尽量有序的序列，例如<code>[1, 2, 3, 4, 0]</code>，实际上插入排序的效率是接近<code>O(N)</code>的，因为它的内层循环实际上只运行了一次，所以插入排序十分适合对已经尽量有序的序列来进行排序</p><h1 id="优化插入排序——希尔排序"><a href="#优化插入排序——希尔排序" class="headerlink" title="优化插入排序——希尔排序"></a>优化插入排序——希尔排序</h1><p>​        为了优化插入排序，我们可以先使数组尽可能多的有序化，或者说局部有序化，希尔排序就诞生了</p><h2 id="原理-1"><a href="#原理-1" class="headerlink" title="原理"></a>原理</h2><p>​        希尔排序的原理是通过间隔<code>h</code>分组，将原序列分成又干个不相邻的间隔为<code>h</code>的两两一组的序列，对这两个元素进行插入排序，然后缩小间隔<code>h</code>，再两两进行插入排序，在这个过程中，原序列会从无序越来越趋近于有序，当<code>h = 0</code>时，虽然是对整个序列进行插入排序，但此时序列已经相对的更加有序，所以效率会得到提高</p><h2 id="Java-代码-1"><a href="#Java-代码-1" class="headerlink" title="Java 代码"></a>Java 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">shellsort</span><span class="params">(<span class="keyword">int</span>[] nums)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> N = nums.length;</span><br><span class="line">    <span class="keyword">int</span> h = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &lt; N / <span class="number">3</span>)</span><br><span class="line">        h = h * <span class="number">3</span> + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (h &gt;= <span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = h; i &lt; N; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &gt;= h &amp;&amp; nums[j] &lt; nums[j - h]; j -= h) &#123;</span><br><span class="line">                <span class="keyword">int</span> item = nums[j];</span><br><span class="line">                nums[j] = nums[j - h];</span><br><span class="line">                nums[j - h] = item;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        h = h / <span class="number">3</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;插入排序&quot;&gt;&lt;a href=&quot;#插入排序&quot; class=&quot;headerlink&quot; title=&quot;插入排序&quot;&gt;&lt;/a&gt;插入排序&lt;/h1&gt;&lt;p&gt;​        插入排序是排序算法的一种，顾名思义，是一种插入的形态进行排序的算法&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽得算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E5%BE%97%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-98——验证二叉搜索树</title>
    <link href="http://yoursite.com/2020/02/15/LeetCode-98%E2%80%94%E2%80%94%E9%AA%8C%E8%AF%81%E4%BA%8C%E5%8F%89%E6%90%9C%E7%B4%A2%E6%A0%91%EF%BC%88Java%E3%80%81Python%EF%BC%89/"/>
    <id>http://yoursite.com/2020/02/15/LeetCode-98——验证二叉搜索树（Java、Python）/</id>
    <published>2020-02-15T13:57:56.000Z</published>
    <updated>2020-02-15T14:26:11.694Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>​        给定一个二叉树，判断其是否是一个有效的二叉搜索树。</p><p>​        假设一个二叉搜索树具有如下特征：</p><ul><li>节点的左子树只包含小于当前节点的数</li><li>节点的右子树只包含大于当前节点的数</li><li>所有左子树和右子树自身必须也是二叉搜索树</li></ul><p>​        示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">输入:</span><br><span class="line">    2</span><br><span class="line">   / \</span><br><span class="line">  1   3</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">输入:</span><br><span class="line">    5</span><br><span class="line">   / \</span><br><span class="line">  1   4</span><br><span class="line">     / \</span><br><span class="line">    3   6</span><br><span class="line">输出: false</span><br><span class="line">解释: 输入为: [5,1,4,null,null,3,6]</span><br><span class="line">     根节点的值为 5 ，但是其右子节点值为 4</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>​        这道题提供三种解法</p><h2 id="使用二叉树中序遍历的方法"><a href="#使用二叉树中序遍历的方法" class="headerlink" title="使用二叉树中序遍历的方法"></a>使用二叉树中序遍历的方法</h2><p>​        根据二叉搜索树的性质，可以得出二叉搜索树使用中序遍历得到的序列应该是一个升序的序列，所以我们可以利用这一性质来判断其是否为二叉搜索树</p><h2 id="Python-代码"><a href="#Python-代码" class="headerlink" title="Python 代码"></a>Python 代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    inorder = self.inorder(root)</span><br><span class="line">    <span class="keyword">return</span> inorder == list(sorted(set(inorder)))</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">inorder</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> []</span><br><span class="line">    <span class="keyword">return</span> self.inorder(root.left) + [root.val] + self.inorder(root.right)</span><br></pre></td></tr></table></figure><h2 id="只考虑当前节点的上一级"><a href="#只考虑当前节点的上一级" class="headerlink" title="只考虑当前节点的上一级"></a>只考虑当前节点的上一级</h2><p>​        另外，我们可以简化上面的方法，因为二叉搜索树实际上就是要保证，在中序遍历的顺序下，当前节点的值一定要大于前一个节点的值</p><h2 id="Python-代码-1"><a href="#Python-代码-1" class="headerlink" title="Python 代码"></a>Python 代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isValidBST</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    self.prev = <span class="literal">None</span></span><br><span class="line">    <span class="keyword">return</span> self.helper(root)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">helper</span><span class="params">(self, root)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> root <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">if</span> <span class="keyword">not</span> self.helper(root.left):</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    <span class="keyword">if</span> self.prev <span class="keyword">and</span> self.prev.val &gt;= root.val:</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">False</span></span><br><span class="line">    self.prev = root</span><br><span class="line">    <span class="keyword">return</span> self.helper(root.right)</span><br></pre></td></tr></table></figure><h2 id="使用递归"><a href="#使用递归" class="headerlink" title="使用递归"></a>使用递归</h2><p>​        除中序遍历的方法外，我们还可以使用递归的思想，根据二叉搜索树的性质，我们只需要满足<code>当前节点的左子树中的最大值比节点值小，右子树中的最小值比节点值大</code>即可证明其为二叉搜索树</p><h2 id="Java-代码"><a href="#Java-代码" class="headerlink" title="Java 代码"></a>Java 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isValidBST</span><span class="params">(TreeNode root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> helper(root, <span class="keyword">null</span>, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">helper</span><span class="params">(TreeNode root, Integer min, Integer max)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    <span class="keyword">if</span> (min != <span class="keyword">null</span> &amp;&amp; root.val &lt;= min)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (max != <span class="keyword">null</span> &amp;&amp; root.val &gt;= max)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    <span class="keyword">return</span> helper(root.left, min, root.val) &amp;&amp; helper(root.right, root.val, max);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;​        给定一个二叉树，判断其是否是一个有效的二叉搜索树。&lt;/p&gt;
&lt;p&gt;​        假设一个二叉搜索树具有如下特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;节点的左子树只包含小于当前节点的数&lt;/li&gt;
&lt;li&gt;节点的右子树只包含大于当前节点的数&lt;/li&gt;
&lt;li&gt;所有左子树和右子树自身必须也是二叉搜索树&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;​        示例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  1   3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入:&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;   / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;  1   4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     / \&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    3   6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释: 输入为: [5,1,4,null,null,3,6]&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     根节点的值为 5 ，但是其右子节点值为 4&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-242——有效的字母异位词（Java、Python）</title>
    <link href="http://yoursite.com/2020/02/15/LeetCode-242%E2%80%94%E2%80%94%E6%9C%89%E6%95%88%E7%9A%84%E5%AD%97%E6%AF%8D%E5%BC%82%E4%BD%8D%E8%AF%8D%EF%BC%88Java%E3%80%81Python%EF%BC%89/"/>
    <id>http://yoursite.com/2020/02/15/LeetCode-242——有效的字母异位词（Java、Python）/</id>
    <published>2020-02-15T13:22:07.000Z</published>
    <updated>2020-02-15T13:51:06.367Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>​        给定两个字符串<code>s</code>和<code>t</code>，编写一个函数来判断<code>t</code>是否是<code>s</code>的字母异位词</p><p>​        示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;anagram&quot;, t = &quot;nagaram&quot;</span><br><span class="line">输出: true</span><br><span class="line"></span><br><span class="line">输入: s = &quot;rat&quot;, t = &quot;car&quot;</span><br><span class="line">输出: false</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>​        这里提供三种解法</p><h2 id="直接排序"><a href="#直接排序" class="headerlink" title="直接排序"></a>直接排序</h2><p>​        因为大部分语言中都自带排序函数，我们可以直接把两个字符串进行排序，因为如果两个字符串互为字母异位词的话，那么他们所包含的字母及每个字母的数量就是一致的，代码很简洁，使用 Python 的话只有两行</p><h2 id="Python-代码"><a href="#Python-代码" class="headerlink" title="Python 代码"></a>Python 代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> sorted(s) == sorted(t)</span><br></pre></td></tr></table></figure><h2 id="使用-map-记住每个字母的数量"><a href="#使用-map-记住每个字母的数量" class="headerlink" title="使用 map 记住每个字母的数量"></a>使用 map 记住每个字母的数量</h2><p>​        我们也可以利用 map 键值对的特性，使用两个 map 来存储每个字符串中的每一个字母出现的次数，最后直接比较这两个 map 是否相等即可，代码使用的是 Python 中的字典</p><h2 id="Python-代码-1"><a href="#Python-代码-1" class="headerlink" title="Python 代码"></a>Python 代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">    dic1, dic2 = &#123;&#125;, &#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> s:</span><br><span class="line">        dic1[item] = dic1.get(item, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> t:</span><br><span class="line">        dic2[item] = dic2.get(item, <span class="number">0</span>) + <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dic1 == dic2</span><br></pre></td></tr></table></figure><h2 id="使用长度为-26-的数组计数"><a href="#使用长度为-26-的数组计数" class="headerlink" title="使用长度为 26 的数组计数"></a>使用长度为 26 的数组计数</h2><p>​        题目给出了两个字符串中的字符均为小写，我们可以直接初始化两个长为 26，初始值都为 0 的数组，然后遍历两个字符串来给字符串中的字符进行计数，最后比较数组是否相等</p><h2 id="Java-代码"><a href="#Java-代码" class="headerlink" title="Java 代码"></a>Java 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isAnagram</span><span class="params">(String s, String t)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span>[] a = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">int</span>[] b = <span class="keyword">new</span> <span class="keyword">int</span>[<span class="number">26</span>];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : s.toCharArray()) &#123;</span><br><span class="line">        a[(<span class="keyword">int</span>)c - (<span class="keyword">int</span>)(<span class="string">'a'</span>)] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">char</span> c : t.toCharArray()) &#123;</span><br><span class="line">        b[(<span class="keyword">int</span>)c - (<span class="keyword">int</span>)(<span class="string">'a'</span>)] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Arrays.equals(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Python-代码-2"><a href="#Python-代码-2" class="headerlink" title="Python 代码"></a>Python 代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">isAnagram</span><span class="params">(self, s, t)</span>:</span></span><br><span class="line">    dic1, dic2 = [<span class="number">0</span>] * <span class="number">26</span>, [<span class="number">0</span>] * <span class="number">26</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> s:</span><br><span class="line">        dic1[ord(item) - ord(<span class="string">'a'</span>)] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> item <span class="keyword">in</span> t:</span><br><span class="line">        dic2[ord(item) - ord(<span class="string">'a'</span>)] += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> dic1 == dic2</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;​        给定两个字符串&lt;code&gt;s&lt;/code&gt;和&lt;code&gt;t&lt;/code&gt;，编写一个函数来判断&lt;code&gt;t&lt;/code&gt;是否是&lt;code&gt;s&lt;/code&gt;的字母异位词&lt;/p&gt;
&lt;p&gt;​        示例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: s = &amp;quot;anagram&amp;quot;, t = &amp;quot;nagaram&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入: s = &amp;quot;rat&amp;quot;, t = &amp;quot;car&amp;quot;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: false&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-141——环形链表</title>
    <link href="http://yoursite.com/2020/02/14/LeetCode-141%E2%80%94%E2%80%94%E7%8E%AF%E5%BD%A2%E9%93%BE%E8%A1%A8%EF%BC%88Java%E3%80%81Python%EF%BC%89/"/>
    <id>http://yoursite.com/2020/02/14/LeetCode-141——环形链表（Java、Python）/</id>
    <published>2020-02-14T14:22:46.000Z</published>
    <updated>2020-02-14T14:40:16.981Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>​        给定一个链表，判断链表中是否有环</p><p>​        为了表示给定链表中的环，我们使用整数<code>pos</code>来表示链表尾连接到链表中的位置（索引从<code>0</code>开始）。 如果<code>pos</code>是<code>-1</code>，则在该链表中没有环</p><p>​        示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">输入：head = [3,2,0,-4], pos = 1</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第二个节点。</span><br><span class="line"></span><br><span class="line">输入：head = [1,2], pos = 0</span><br><span class="line">输出：true</span><br><span class="line">解释：链表中有一个环，其尾部连接到第一个节点。</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>​        这里给这道题提供两种解法</p><h2 id="使用-Set"><a href="#使用-Set" class="headerlink" title="使用 Set"></a>使用 Set</h2><p>​        检测一个链表中是否存在环，可以理解为检测链表中存不存在一个节点，这个节点有两个指针同时指向它，这样链表中就产生了环，我们可以使用 Set 来解决这个问题</p><p>​        我们从头至尾遍历这个链表，每到一个节点，就检测实现定义好的 Set 中是否存在一个相同的节点，不存在就将它放入 Set，反之如果存在，就说明这个节点被两个节点同时所指向，使链表形成了环</p><h2 id="Java-代码"><a href="#Java-代码" class="headerlink" title="Java 代码"></a>Java 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (head == <span class="keyword">null</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">    Set&lt;ListNode&gt; set = <span class="keyword">new</span> HashSet&lt;ListNode&gt;();</span><br><span class="line">    <span class="keyword">while</span> (head.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        head = head.next;</span><br><span class="line">        <span class="keyword">if</span> (set.contains(head))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            set.add(head);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="使用快慢指针"><a href="#使用快慢指针" class="headerlink" title="使用快慢指针"></a>使用快慢指针</h2><p>​        另一种方法是使用快慢指针，即定义两个指针，都从链表的头部开始遍历，只要保证慢指针每次走的步数小于快指针即可（通常就慢指针一次走一个节点，快指针一次走两个就行），当其中一个指针为空了，就说明链表到头了，没有环，而如果两个指针相遇了，就说明链表是有环的</p><p>​        这个解法的原理就是，如果链表没有环，快慢指针永远都不会相遇</p><h2 id="Java-代码-1"><a href="#Java-代码-1" class="headerlink" title="Java 代码"></a>Java 代码</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">hasCycle</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode fast = head, slow = head;</span><br><span class="line">    <span class="keyword">while</span> (fast != <span class="keyword">null</span> &amp;&amp; slow != <span class="keyword">null</span> &amp;&amp; fast.next != <span class="keyword">null</span>) &#123;</span><br><span class="line">        slow = slow.next;</span><br><span class="line">        fast = fast.next.next;</span><br><span class="line">        <span class="keyword">if</span> (slow == fast)</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Python-代码"><a href="#Python-代码" class="headerlink" title="Python 代码"></a>Python 代码</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hasCycle</span><span class="params">(self, head: ListNode)</span> -&gt; bool:</span></span><br><span class="line">    fast = slow = head</span><br><span class="line">    <span class="keyword">while</span> slow <span class="keyword">and</span> fast <span class="keyword">and</span> fast.next:</span><br><span class="line">        slow = slow.next</span><br><span class="line">        fast = fast.next.next</span><br><span class="line">        <span class="keyword">if</span> slow <span class="keyword">is</span> fast:</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line">    <span class="keyword">return</span> <span class="literal">False</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;​        给定一个链表，判断链表中是否有环&lt;/p&gt;
&lt;p&gt;​        为了表示给定链表中的环，我们使用整数&lt;code&gt;pos&lt;/code&gt;来表示链表尾连接到链表中的位置（索引从&lt;code&gt;0&lt;/code&gt;开始）。 如果&lt;code&gt;pos&lt;/code&gt;是&lt;code&gt;-1&lt;/code&gt;，则在该链表中没有环&lt;/p&gt;
&lt;p&gt;​        示例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入：head = [3,2,0,-4], pos = 1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：链表中有一个环，其尾部连接到第二个节点。&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输入：head = [1,2], pos = 0&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出：true&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;解释：链表中有一个环，其尾部连接到第一个节点。&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>LeetCode-206——反转链表（Java、Python）</title>
    <link href="http://yoursite.com/2020/02/14/LeetCode-206%E2%80%94%E2%80%94%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%EF%BC%88Java%E3%80%81Python%EF%BC%89/"/>
    <id>http://yoursite.com/2020/02/14/LeetCode-206——反转链表（Java、Python）/</id>
    <published>2020-02-14T13:47:48.000Z</published>
    <updated>2020-02-14T14:41:07.672Z</updated>
    
    <content type="html"><![CDATA[<h1 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h1><p>​        反转一个链表</p><p>​        示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: 1-&gt;2-&gt;3-&gt;4-&gt;5-&gt;NULL</span><br><span class="line">输出: 5-&gt;4-&gt;3-&gt;2-&gt;1-&gt;NULL</span><br></pre></td></tr></table></figure><a id="more"></a><h1 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h1><p>​        这道题我们需要两个额外的链表节点变量<code>ListNode</code>来协助完成</p><p>​        假设我们有一个<code>1-&gt;2-&gt;3-&gt;4-&gt;5</code>的链表，我们定义<code>cur</code>和<code>prev</code>两个节点变量，分别用来表示当前节点和上一个节点，<code>cur</code>初始指向头节点，<code>prev</code>初始为空，然后遍历这个链表</p><p>​        从<code>1</code>这个节点开始，此时<code>cur</code>即为<code>1</code>，我们只需要在遍历过程中不断的改变每个节点指针的方向，让它指向前一个节点即可，需要注意的就是，大部分语言都需要实现存下<code>cur.next</code>的值，否则在指针的变换中可能会使链表断掉</p><h1 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h1><h2 id="Java-版"><a href="#Java-版" class="headerlink" title="Java 版"></a>Java 版</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ListNode <span class="title">reverseList</span><span class="params">(ListNode head)</span> </span>&#123;</span><br><span class="line">    ListNode cur = head;</span><br><span class="line">    ListNode pre = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> (cur != <span class="keyword">null</span>) &#123;</span><br><span class="line">        ListNode temp = cur.next;</span><br><span class="line">        cur.next = pre;</span><br><span class="line">        pre = cur;</span><br><span class="line">        cur = temp;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Python-版"><a href="#Python-版" class="headerlink" title="Python 版"></a>Python 版</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reverseList</span><span class="params">(head)</span>:</span></span><br><span class="line">    cur, prev = head, <span class="literal">None</span></span><br><span class="line">    <span class="keyword">while</span> cur:</span><br><span class="line">        cur.next, prev, cur = prev, cur, cur.next</span><br><span class="line">    <span class="keyword">return</span> prev</span><br></pre></td></tr></table></figure><p>​        Python 的代码中<code>cur.next, prev, cur = prev, cur, cur.next</code>使用了多重赋值的语法，关于多重赋值原理的解释，看这里：<a href="https://blog.csdn.net/scfor333/article/details/104316694" target="_blank" rel="noopener">https://blog.csdn.net/scfor333/article/details/104316694</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h1&gt;&lt;p&gt;​        反转一个链表&lt;/p&gt;
&lt;p&gt;​        示例：&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;输入: 1-&amp;gt;2-&amp;gt;3-&amp;gt;4-&amp;gt;5-&amp;gt;NULL&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;输出: 5-&amp;gt;4-&amp;gt;3-&amp;gt;2-&amp;gt;1-&amp;gt;NULL&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>Python——NumPy安装、NdArray对象的简单使用、NumPy的数据类型</title>
    <link href="http://yoursite.com/2020/02/06/Python%E2%80%94%E2%80%94NumPy%E5%AE%89%E8%A3%85%E3%80%81NdArray%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%AE%80%E5%8D%95%E4%BD%BF%E7%94%A8%E3%80%81NumPy%E7%9A%84%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/02/06/Python——NumPy安装、NdArray对象的简单使用、NumPy的数据类型/</id>
    <published>2020-02-06T15:30:33.000Z</published>
    <updated>2020-02-06T15:31:58.236Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-NumPy"><a href="#什么是-NumPy" class="headerlink" title="什么是 NumPy"></a>什么是 NumPy</h1><blockquote><p>NumPy 是一个用 python 实现的科学计算，包括：1、一个强大的 N 维数组对象 Array；2、比较成熟的（广播）函数库；3、用于整合 C/C++ 和 Fortran 代码的工具包；4、实用的线性代数、傅里叶变换和随机数生成函数，numpy 和稀疏矩阵运算包scipy配合使用更加方便</p><p>​        NumPy（Numeric Python）提供了许多高级的数值编程工具，如：矩阵数据类型、矢量处理，以及精密的运算库，专为进行严格的数字处理而产生，多为很多大型金融公司使用，以及核心的科学计算组织如：Lawrence Livermore， NASA 用其处理一些本来使用 C++，Fortran 或 MatLab 等所做的任务</p></blockquote><a id="more"></a><h2 id="安装-NumPy"><a href="#安装-NumPy" class="headerlink" title="安装 NumPy"></a>安装 NumPy</h2><p>​        在 windows 下，推荐使用下载 Python 发行版的方式，它会包含很多关键的包，比如<code>NumPy</code>、<code>Pandas</code>等</p><p>​        我选择的是<code>ANACONDA</code>，可以直接百度搜索到官网下载，但是会很慢，可以在清华大学开源镜像站下载，连接是</p><blockquote><p><a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/" target="_blank" rel="noopener">https://mirrors.tuna.tsinghua.edu.cn/anaconda/archive/</a></p></blockquote><p>​        下载安装后，系统就已经拥有 NumPy 包了</p><p>​        也可以使用 PIP 命令直接安装</p><h3 id="导入-NumPy"><a href="#导入-NumPy" class="headerlink" title="导入 NumPy"></a>导入 NumPy</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np</span><br></pre></td></tr></table></figure><p>​        上边的代码是向程序中导入 NumPy 库，如果导入成功，也就说明 NumPy 库安装成功了</p><h2 id="NumPy-中的-NdArray-对象"><a href="#NumPy-中的-NdArray-对象" class="headerlink" title="NumPy 中的 NdArray 对象"></a>NumPy 中的 NdArray 对象</h2><p>​        NumPy 最最最重要的特点就是它所包含的多维数组对象：<code>ndarray</code>，它是用于存放同类元素的多维数组</p><h3 id="NdArray-的使用"><a href="#NdArray-的使用" class="headerlink" title="NdArray 的使用"></a>NdArray 的使用</h3><h4 id="创建一个-NdArray-对象"><a href="#创建一个-NdArray-对象" class="headerlink" title="创建一个 NdArray 对象"></a>创建一个 NdArray 对象</h4><p>​        <code>ndarray</code>数组可以直接通过<code>numpy.array(object, dtype = None, copy = True, order = None, subok = False, nfmin = 0)</code>方法来创建，下面说一下<code>ndarray</code>的重要参数</p><ul><li>object：数组或嵌套数列</li><li>dtype：数组元素的数据类型，可选</li><li>copy：对象是否需要复制，可选</li><li>order：创建数组呃样式，C 为行方向，F 为列方向，A 为任意方向（默认）</li><li>subok：默认返回一个与基类类型一致的数组</li><li>ndmin：指定生成数组的最小维度</li></ul><p>​        下面是一个创建多维数组的简单示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">arr = np.array(</span><br><span class="line">    [</span><br><span class="line">        [</span><br><span class="line">            [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">            [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">            [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">        ],</span><br><span class="line">        [</span><br><span class="line">            [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">            [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>],</span><br><span class="line">            [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>]</span><br><span class="line">        ]</span><br><span class="line">    ]，</span><br><span class="line">    dtype=np.int</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h2 id="NumPy-中的数据类型"><a href="#NumPy-中的数据类型" class="headerlink" title="NumPy 中的数据类型"></a>NumPy 中的数据类型</h2><p>​        <code>numpy</code>支持的数据类型比<code>Python</code>内置的数据类型多得多，如下表：</p><table><thead><tr><th align="center">数据类型</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">bool_</td><td align="center">布尔型数据类型（True 或 False）</td></tr><tr><td align="center">int_</td><td align="center">默认的整数类型（类似于 C 语言中的 long）</td></tr><tr><td align="center">intc</td><td align="center">同 C 语言中的 int 类型一样</td></tr><tr><td align="center">intp</td><td align="center">用于索引的整数类型</td></tr><tr><td align="center">int8</td><td align="center">字节（-128 to 127）</td></tr><tr><td align="center">int16</td><td align="center">整数（-32768 to 32767）</td></tr><tr><td align="center">int32</td><td align="center">整数（-2147483648 to 2147483647）</td></tr><tr><td align="center">int64</td><td align="center">整数（-9223372036854775808 to 9223372036854775807）</td></tr><tr><td align="center">uint8</td><td align="center">无符号整数（0 to 255）</td></tr><tr><td align="center">uint16</td><td align="center">无符号整数（0 to 65535）</td></tr><tr><td align="center">uint32</td><td align="center">无符号整数（0 to 4294967295）</td></tr><tr><td align="center">uint64</td><td align="center">无符号整数（0 to 18446744073709551615）</td></tr><tr><td align="center">float_</td><td align="center">float64 类型的简写</td></tr><tr><td align="center">float16</td><td align="center">半精度浮点数，包括：1 个符号位，5 个指数位，10 个尾数位</td></tr><tr><td align="center">float32</td><td align="center">单精度浮点数，包括：1 个符号位，8 个指数位，23 个尾数位</td></tr><tr><td align="center">float64</td><td align="center">双精度浮点数，包括：1 个符号位，11 个指数位，52 个尾数位</td></tr><tr><td align="center">complex_</td><td align="center">complex128 类型的简写，即 128 位复数</td></tr><tr><td align="center">complex64</td><td align="center">复数，表示双 32 位浮点数（实数部分和虚数部分）</td></tr><tr><td align="center">complex128</td><td align="center">复数，表示双 64 位浮点数（实数部分和虚数部分）</td></tr></tbody></table><p>​        并且，在<code>numpy</code>中，每个内建类型都有一个唯一定义的字符代码：</p><table><thead><tr><th align="center">字符</th><th align="center">对应类型</th></tr></thead><tbody><tr><td align="center">b</td><td align="center">布尔型</td></tr><tr><td align="center">i</td><td align="center">(有符号) 整型</td></tr><tr><td align="center">u</td><td align="center">无符号整型 integer</td></tr><tr><td align="center">f</td><td align="center">浮点型</td></tr><tr><td align="center">c</td><td align="center">复数浮点型</td></tr><tr><td align="center">m</td><td align="center">timedelta（时间间隔）</td></tr><tr><td align="center">M</td><td align="center">datetime（日期时间）</td></tr><tr><td align="center">O</td><td align="center">(Python) 对象</td></tr><tr><td align="center">S, a</td><td align="center">(byte-)字符串</td></tr><tr><td align="center">U</td><td align="center">Unicode</td></tr><tr><td align="center">V</td><td align="center">原始数据 (void)</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是-NumPy&quot;&gt;&lt;a href=&quot;#什么是-NumPy&quot; class=&quot;headerlink&quot; title=&quot;什么是 NumPy&quot;&gt;&lt;/a&gt;什么是 NumPy&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;NumPy 是一个用 python 实现的科学计算，包括：1、一个强大的 N 维数组对象 Array；2、比较成熟的（广播）函数库；3、用于整合 C/C++ 和 Fortran 代码的工具包；4、实用的线性代数、傅里叶变换和随机数生成函数，numpy 和稀疏矩阵运算包scipy配合使用更加方便&lt;/p&gt;
&lt;p&gt;​        NumPy（Numeric Python）提供了许多高级的数值编程工具，如：矩阵数据类型、矢量处理，以及精密的运算库，专为进行严格的数字处理而产生，多为很多大型金融公司使用，以及核心的科学计算组织如：Lawrence Livermore， NASA 用其处理一些本来使用 C++，Fortran 或 MatLab 等所做的任务&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
    
      <category term="李明徽的Python" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84Python/"/>
    
  </entry>
  
  <entry>
    <title>Python——生产者消费者问题、死锁、同步和异步</title>
    <link href="http://yoursite.com/2020/02/05/Python%E2%80%94%E2%80%94%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%97%AE%E9%A2%98%E3%80%81%E5%90%8C%E6%AD%A5%E5%92%8C%E5%BC%82%E6%AD%A5/"/>
    <id>http://yoursite.com/2020/02/05/Python——生产者消费者问题、同步和异步/</id>
    <published>2020-02-05T09:07:58.000Z</published>
    <updated>2020-02-05T10:39:17.870Z</updated>
    
    <content type="html"><![CDATA[<h1 id="多线程产生的问题"><a href="#多线程产生的问题" class="headerlink" title="多线程产生的问题"></a>多线程产生的问题</h1><p>​        并发编程由于需要很多线程、进程之间的协作，所以很容易出现问题，下面主要介绍生产者与消费者问题、死锁问题、同步和异步问题</p><a id="more"></a><h2 id="生产者与消费者问题"><a href="#生产者与消费者问题" class="headerlink" title="生产者与消费者问题"></a>生产者与消费者问题</h2><p>​        当我们进行一个任务，需要两个线程不断地获取和操作数据时，可能会产生一个问题，如果数据获取很快，而操作很慢，那么获取数据的线程就必须等待操作数据的线程处理完毕，反之如果数据获取的很慢而操作的很快，那么操作数据的线程就必须等待获取数据的线程，这种问题可以看作是一种生产消费能力的不平衡，称之为生产者与消费者问题</p><h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>​        解决这种生产消费能力不平衡的方法就是，在在生产者和消费者中间设立一个缓冲机制，生产者将生产的数据放入缓冲池中，消费者从缓冲池中取出数据进行处理，当缓冲池中的数据量小于一定的值时，生产者就会向缓冲池中添加数据，而当缓冲池中数据大于一个值时，消费者就会从缓冲池中取出数据，使生产者和消费者达到一种动态的平衡</p><p>​        实现代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> queue <span class="keyword">import</span> Queue</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Producer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> Queue</span><br><span class="line">        count = <span class="number">0</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> queue.qsize() &lt; <span class="number">1000</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">100</span>):</span><br><span class="line">                    count += <span class="number">1</span></span><br><span class="line">                    msg = <span class="string">'Pro '</span> + str(count)</span><br><span class="line">                    queue.put(msg)</span><br><span class="line">            time.sleep(<span class="number">0.5</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Consumer</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">global</span> queue</span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> queue.qsize() &gt; <span class="number">100</span>:</span><br><span class="line">                <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">                    msg = self.name + <span class="string">'Spend '</span> + queue.get()</span><br><span class="line">                    print(msg)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    queue = Queue()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">500</span>):</span><br><span class="line">        queue.put(<span class="string">'Start Pro '</span> + str(i))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">2</span>):</span><br><span class="line">        p = Producer()</span><br><span class="line">        p.start()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        c = Consumer()</span><br><span class="line">        c.start()</span><br></pre></td></tr></table></figure><p>​        运行结果（截取）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Thread-7Spend Start Pro 494</span><br><span class="line">Thread-3Spend Start Pro 495</span><br><span class="line">Thread-5Spend Start Pro 496</span><br><span class="line">Thread-5Spend Start Pro 498</span><br><span class="line">Thread-5Spend Start Pro 499</span><br><span class="line">Thread-3Spend Start Pro 497</span><br><span class="line">Thread-3Spend Pro 1</span><br><span class="line">Thread-4Spend Pro 2</span><br><span class="line">Thread-4Spend Pro 3</span><br><span class="line">Thread-4Spend Pro 4</span><br><span class="line">Thread-6Spend Pro 5</span><br><span class="line">Thread-6Spend Pro 6</span><br></pre></td></tr></table></figure><h2 id="死锁问题"><a href="#死锁问题" class="headerlink" title="死锁问题"></a>死锁问题</h2><p>​        在多线程中，线程可以通过互斥锁来保证对同一资源的唯一占有，但当程序变得复杂后，可能会出现线程 A 对资源 A 上了锁，而线程 A 后边需要用到资源 B，使用完毕后才会对资源 A解锁，而线程 B 对资源 B 上了锁，它后边选要用到资源 A，用过后才会给 B 解锁，如果线程 A 和线程 B 同时运行，就可能会造成一种情况：线程 A 在等待线程 B 解锁，线程 B 也在等待线程 A 解锁，这就是死锁问题</p><h3 id="死锁模拟"><a href="#死锁模拟" class="headerlink" title="死锁模拟"></a>死锁模拟</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThraed1</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> mutexA.acquire():</span><br><span class="line">            print(self.name + <span class="string">'----do 1----up----'</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> mutexB.acquire():</span><br><span class="line">                print(self.name + <span class="string">'----do 1----down----'</span>)</span><br><span class="line">                mutexB.release()</span><br><span class="line">            mutexA.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> mutexB.acquire():</span><br><span class="line">            print(self.name + <span class="string">'----d0 2----up----'</span>)</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">if</span> mutexA.acquire():</span><br><span class="line">                print(<span class="string">'----do 2----down----'</span>)</span><br><span class="line">                mutexA.release()</span><br><span class="line">            mutexB.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">mutexA = threading.Lock()</span><br><span class="line">mutexB = threading.Lock()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t1 = MyThraed1()</span><br><span class="line">    t2 = MyThread2()</span><br><span class="line"></span><br><span class="line">    t1.start()</span><br><span class="line">    t2.start()</span><br></pre></td></tr></table></figure><p>​        以上代码运行后，毫无疑问会产生死锁问题，结果如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Thread-1----do 1----up----</span><br><span class="line">Thread-2----d0 2----up----</span><br></pre></td></tr></table></figure><p>​        程序由于三个线程都在等待对方释放资源而卡住了</p><h3 id="解决方法-1"><a href="#解决方法-1" class="headerlink" title="解决方法"></a>解决方法</h3><p>​        死锁问题应该尽量在设计程序时避免，或添加等待超时时间，从而检测程序是否产生了死锁，另一种就是通过银行家算法也可以避免死锁问题</p><h4 id="银行家算法"><a href="#银行家算法" class="headerlink" title="银行家算法"></a>银行家算法</h4><p>​        银行家算法的思想就是，假设银行有 10 元，这个时候有三个人提出贷款，A 要贷款 9 元，B 要贷款 3 元，C 要贷款 8 元，这时，银行肯定不够将所有人都满足，银行家算法就诞生了</p><p>​        这时银行为了留住所有客户并且保证自己的钱不会不足，便分批贷款给客户，先借给 A 2 元、B 2 元、C 4 元，银行还剩 2 元，此时 B 直需要再借 1 元就满足了他自己的需求，银行便借给他 1 元，自己剩 1 元，当 B 用完，将 3 元还给银行后，银行再将这 4 元借给 C，C 也就满足了，等 C 还款后，再将 8 元中的 7 元借给 A，这样便动态的满足了三个客户的需求</p><p>​        银行家算法在程序中实际上也是模拟了银行贷款的过程，操作系统会动态的向各个线程分配资源，在分配前，系统会判断分配后会不会导致系统进入不安全状态，不会就分配资源给线程，会则令线程等待</p><h2 id="同步和异步"><a href="#同步和异步" class="headerlink" title="同步和异步"></a>同步和异步</h2><p>​        同步和异步是并发编程下的两种重要的状态</p><h3 id="同步"><a href="#同步" class="headerlink" title="同步"></a>同步</h3><p>​        同步是指当程序 A 调用程序 B 时，程序 A 停下不动，等待程序 B 完成后再继续运行</p><p>​        举个例子就是，假设 A 喊 B 出去吃饭，B 说等我写完代码再去，A 就一直在原地等着 B，这就是同步</p><p>​        归根结底，同步实现的就是一种顺序的运行</p><h4 id="使用互斥锁实现线程同步"><a href="#使用互斥锁实现线程同步" class="headerlink" title="使用互斥锁实现线程同步"></a>使用互斥锁实现线程同步</h4><p>​        代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"><span class="keyword">from</span> time <span class="keyword">import</span> sleep</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task1</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> lock1.acquire():</span><br><span class="line">                print(<span class="string">'-----Task 1-----'</span>)</span><br><span class="line">                sleep(<span class="number">0.5</span>)</span><br><span class="line">                lock2.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task2</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> lock2.acquire():</span><br><span class="line">                print(<span class="string">'-----Task 2-----'</span>)</span><br><span class="line">                sleep(<span class="number">0.5</span>)</span><br><span class="line">                lock3.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Task3</span><span class="params">(Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">            <span class="keyword">if</span> lock3.acquire():</span><br><span class="line">                print(<span class="string">'-----Task 3-----'</span>)</span><br><span class="line">                sleep(<span class="number">0.5</span>)</span><br><span class="line">                lock1.release()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">lock1 = Lock()</span><br><span class="line"></span><br><span class="line">lock2 = Lock()</span><br><span class="line">lock2.acquire()</span><br><span class="line"></span><br><span class="line">lock3 = Lock()</span><br><span class="line">lock3.acquire()</span><br><span class="line"></span><br><span class="line">t1 = Task1()</span><br><span class="line">t2 = Task2()</span><br><span class="line">t3 = Task3()</span><br><span class="line"></span><br><span class="line">t1.start()</span><br><span class="line">t2.start()</span><br><span class="line">t3.start()</span><br></pre></td></tr></table></figure><p>​        运行结果</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">-----Task 1-----</span><br><span class="line">-----Task 2-----</span><br><span class="line">-----Task 3-----</span><br><span class="line">-----Task 1-----</span><br><span class="line">-----Task 2-----</span><br><span class="line">-----Task 3-----</span><br></pre></td></tr></table></figure><h3 id="异步"><a href="#异步" class="headerlink" title="异步"></a>异步</h3><p>​        反之，异步是指当程序 A 调用程序 B 后，A 不会等到 B 执行完再运行，而是继续向下运行自己的程序</p><p>​        举个例子就是，A 还是叫 B 去吃饭，B 依然说敲完代码再去，这时 A 没有等 B，而是去做自己的事情，等 B 敲完代码，两个再一起去吃饭</p><h4 id="使用进程池实现进程异步"><a href="#使用进程池实现进程异步" class="headerlink" title="使用进程池实现进程异步"></a>使用进程池实现进程异步</h4><p>​        代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">'-----Process in Pool----- pid = %d, ppid = %d'</span> % (os.getpid(), os.getppid()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        print(<span class="string">'----%d----'</span> % i)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hahah'</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">(args)</span>:</span></span><br><span class="line">    print(<span class="string">'---callback func---- pid = %d'</span> % os.getpid())</span><br><span class="line">    print(<span class="string">'---callback func---- args = %s'</span> % args)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pool = Pool(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">pool.apply_async(func=test, callback=test2)</span><br><span class="line"></span><br><span class="line">time.sleep(<span class="number">5</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'----mainProcess pid = %d----'</span> % os.getpid())</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">-----Process in Pool----- pid = 6027, ppid = 6025</span><br><span class="line">----0----</span><br><span class="line">----1----</span><br><span class="line">----2----</span><br><span class="line">---callback func---- pid = 6025</span><br><span class="line">---callback func---- args = hahah</span><br><span class="line">----mainProcess pid = 6025----</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;多线程产生的问题&quot;&gt;&lt;a href=&quot;#多线程产生的问题&quot; class=&quot;headerlink&quot; title=&quot;多线程产生的问题&quot;&gt;&lt;/a&gt;多线程产生的问题&lt;/h1&gt;&lt;p&gt;​        并发编程由于需要很多线程、进程之间的协作，所以很容易出现问题，下面主要介绍生产者与消费者问题、死锁问题、同步和异步问题&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的Python" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84Python/"/>
    
  </entry>
  
  <entry>
    <title>Python——多线程以及多线程会产生的一些问题</title>
    <link href="http://yoursite.com/2020/02/04/Python%E2%80%94%E2%80%94%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BB%A5%E5%8F%8A%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BC%9A%E4%BA%A7%E7%94%9F%E7%9A%84%E4%B8%80%E4%BA%9B%E9%97%AE%E9%A2%98/"/>
    <id>http://yoursite.com/2020/02/04/Python——多线程以及多线程会产生的一些问题/</id>
    <published>2020-02-04T13:35:59.000Z</published>
    <updated>2020-02-04T14:39:45.183Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-中的多线程"><a href="#Python-中的多线程" class="headerlink" title="Python 中的多线程"></a>Python 中的多线程</h1><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>​        一个进程中包括多个线程，线程是 CPU 调度和分派的基本单位，是进程中执行运算的最小单位，真正在 CPU 上运行的是线程，可以与同一个进程中的其他线程共享进程的全部资源</p><a id="more"></a><h2 id="Python-中实现多线程"><a href="#Python-中实现多线程" class="headerlink" title="Python 中实现多线程"></a>Python 中实现多线程</h2><p>​        Python 中有两种方式床架多线程，一种是调用底层的 <code>thread</code>模块（Python3 中已弃用），另一种是使用<code>threading</code>模块，下面我说的也是使用这个模块实现多线程的方法</p><p>​        从形式上将，多线程的实现和多进程的实现十分类似，<code>threading</code>模块提供了<code>Thread</code>类来创建线程，同<code>Process</code>类一样，我们可以通过直接调用或创建子类来继承这两种方式来创建线程</p><h3 id="使用-Thread-实现多线程"><a href="#使用-Thread-实现多线程" class="headerlink" title="使用 Thread 实现多线程"></a>使用 Thread 实现多线程</h3><p>​        直接调用<code>threading</code>，模块的<code>Thread</code>类来创建线程十分简单，使用<code>threading.Thread([target], [(item1, item2, ...)])</code>方法，<code>target</code>为目标函数名称（如果有目标函数的话），后边为参数元组，用来传递函数参数</p><p>​        线程创建好后，调用<code>Thread.start()</code>方法，就可以运行线程，如果没有目标函数，<code>start()</code>会自动执行<code>Thread</code>类中的<code>run()</code>方法，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">saySorry</span><span class="params">()</span>:</span></span><br><span class="line">    time.sleep(<span class="number">5</span>)</span><br><span class="line">    print(<span class="string">'I am sorry'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(<span class="string">'create %i Thread'</span> % i)</span><br><span class="line">        t = threading.Thread(target=saySorry)</span><br><span class="line">        t.start()</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">create 0 Thread</span><br><span class="line">create 1 Thread</span><br><span class="line">create 2 Thread</span><br><span class="line">create 3 Thread</span><br><span class="line">create 4 Thread</span><br><span class="line">I am sorry</span><br><span class="line">I am sorry</span><br><span class="line">I am sorry</span><br><span class="line">I am sorry</span><br><span class="line">I am sorry</span><br></pre></td></tr></table></figure><p>​        上边的程序也证明了，程序在创建了子线程后，不会等待线程执行完毕，而是会继续向下执行，而当主程序全部执行完毕后，却会等待所有子线程执行完毕再结束，这点和进程有些区别</p><h3 id="继承-Thread-实现多线程"><a href="#继承-Thread-实现多线程" class="headerlink" title="继承 Thread 实现多线程"></a>继承 Thread 实现多线程</h3><p>​        另外一种方式是通过创建继承<code>Thread</code>类的子类来实现多线程，这样做的好处就是可以将线程要运行的代码全部放入<code>run</code>函数中，用起来更方便，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span><span class="params">(threading.Thread)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">            time.sleep(<span class="number">1</span>)</span><br><span class="line">            msg = <span class="string">'I am '</span> + self.name + <span class="string">' @ '</span> + str(i)</span><br><span class="line">            print(msg)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t = MyThread()</span><br><span class="line">    t.start()</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">I am Thread-1 @ 0</span><br><span class="line">I am Thread-1 @ 1</span><br><span class="line">I am Thread-1 @ 2</span><br></pre></td></tr></table></figure><h2 id="Python-多线程中全局变量和非全局变量的使用问题"><a href="#Python-多线程中全局变量和非全局变量的使用问题" class="headerlink" title="Python 多线程中全局变量和非全局变量的使用问题"></a>Python 多线程中全局变量和非全局变量的使用问题</h2><p>​        开始就说过，线程可以和同一个进程中的其他线程共享进程的全部资源，那么在多线程程序中，各线程对全局变量和非全局变量的使用到底是怎样的呢</p><h3 id="非全局变量"><a href="#非全局变量" class="headerlink" title="非全局变量"></a>非全局变量</h3><p>​        非全局变量在多线程中是不会被共享的，这就像是假设有一个存在局部变量<code>a</code>的函数，当程序调用两次这个函数时，每次调用所产生的局部变量<code>a</code>都是一个新的变量，不会受另一个函数执行的干扰，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">import</span> threading</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    str = threading.current_thread().name</span><br><span class="line">    g_num = <span class="number">100</span></span><br><span class="line">    <span class="keyword">if</span> str == <span class="string">'Thread-1'</span>:</span><br><span class="line">        print(str)</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        print(str)</span><br><span class="line">        g_num -= <span class="number">1</span></span><br><span class="line">    print(<span class="string">'-----test1----- g_num = %d'</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = Thread(target=test1)</span><br><span class="line">p1.start()</span><br><span class="line"></span><br><span class="line">p2 = Thread(target=test1)</span><br><span class="line">p2.start()</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Thread-1</span><br><span class="line">-----test1----- g_num = 101</span><br><span class="line">Thread-2</span><br><span class="line">-----test1----- g_num = 99</span><br></pre></td></tr></table></figure><p>​        可以看到，局部变量<code>g_num</code>并不会因为另一个线程中的同名函数而收到影响</p><h3 id="全局变量"><a href="#全局变量" class="headerlink" title="全局变量"></a>全局变量</h3><p>​        在多线程中，全局变量是可以在各线程间共享的，这也就是说，线程间通信不需要通过管道、内存映射等方法，只需要使用一个全局变量（同一个进程中的共享资源）便可以，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">g_flag = <span class="number">0</span></span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"---test1--- g_num = %d"</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"---test2--- g_num = %d "</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = Thread(target=test1)</span><br><span class="line">p1.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p2 = Thread(target=test2)</span><br><span class="line">p2.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"---g_num= %d ---"</span> % g_num)</span><br></pre></td></tr></table></figure><p>​        运行结果:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---g_num= 372639 ---</span><br><span class="line">---test1--- g_num = 1456098</span><br><span class="line">---test2--- g_num = 1596586</span><br></pre></td></tr></table></figure><p>​        到这里，我们可以发现一个问题，正常来讲，<code>g_num</code>最后的值不应给是<code>2000000</code>吗，为什么不是呢？这就是多线程使用全局变量时有可能出现的 bug，请继续阅读！</p><h2 id="Python-多线程中如何防止使用全局变量出现-bug（轮询和互斥锁）"><a href="#Python-多线程中如何防止使用全局变量出现-bug（轮询和互斥锁）" class="headerlink" title="Python 多线程中如何防止使用全局变量出现 bug（轮询和互斥锁）"></a>Python 多线程中如何防止使用全局变量出现 bug（轮询和互斥锁）</h2><p>​        通过刚才在多线程中使用全局变量我们发现，当代码逻辑稍微复杂一些时，在两个线程中同时使用一个全局变量会出现问题，是什么导致了这个问题呢？</p><p>​        从代码中我们可以发现<code>g_num += 1</code>这句代码，实际上是<code>g_num + 1</code>和将其结果赋给<code>g_num</code>两步，正是因为这连续的两次对全局变量的操作造成了这个问题</p><p>​        当一个线程执行到<code>g_num + 1</code>这步后，cpu 有可能会转头去处理另一个线程，另一个线程也运行了<code>g_num + 1</code>，当 cpu 再回头执行第一个线程时，<code>g_num</code> 已经不止被运算过一次了</p><p>​        那么怎么避免这样的情况发生呢，只能是如果存在对全局变量变量值的修改时，我们要优先运行一个线程，当它结束修改后，再允许另一个线程去访问这个局部变量，下面提供两种方式，轮询和互斥锁</p><h3 id="轮询"><a href="#轮询" class="headerlink" title="轮询"></a>轮询</h3><p>​        顾名思义，轮询的意思就是反复询问，抽象起来理解就是，我们可以设置另一个用来作为目标值的全局变量，两个线程执行的条件根据目标值的不同而不同，当目标值满足一个线程执行时，其他线程就会一直处在一个堵塞的过程，它会一直询问目标值是否符合自己，当上一个线程结束时，这个线程会将目标值修改，这样下一个符合目标值的线程就会运行，示例如下:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"></span><br><span class="line">g_flag = <span class="number">0</span></span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">global</span> g_flag</span><br><span class="line">    <span class="keyword">if</span> g_flag == <span class="number">0</span>:</span><br><span class="line">        <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">            g_num += <span class="number">1</span></span><br><span class="line">        g_flag = <span class="number">1</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"---test1--- g_num = %d"</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    <span class="keyword">global</span> g_flag</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> g_flag != <span class="number">0</span>:</span><br><span class="line">            <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">                g_num += <span class="number">1</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"---test2--- g_num = %d "</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = Thread(target=test1)</span><br><span class="line">p1.start()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p2 = Thread(target=test2)</span><br><span class="line">p2.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"---g_num= %d ---"</span> % g_num)</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---g_num= <span class="number">181893</span> ---</span><br><span class="line">---test1--- g_num = <span class="number">1000000</span></span><br><span class="line">---test2--- g_num = <span class="number">2000000</span></span><br></pre></td></tr></table></figure><p>​        如结果所示，线程之间使用全局变量的 bug 已经解决，但是轮询的方法十分消耗资源，堵塞的线程其实一直都处在一个死循环的状态占用系统资源</p><h3 id="互斥锁"><a href="#互斥锁" class="headerlink" title="互斥锁"></a>互斥锁</h3><p>​        相比而言，互斥锁就是一种比较优化的方法，互斥锁会使用<code>threading</code>模块的<code>Lock</code>类</p><p>​        互斥锁的思想是，当一个线程运行时，它会给它需要的这部分资源上锁，这样同样使用这把锁的其他线程全部都会被堵塞，但被互斥锁所堵塞的线程不会占用系统资源，它们会处在睡眠状态，当运行的线程用完被锁的这部分资源后，它会解锁，这时其他线程就会被唤醒来抢占 cpu 资源，得到资源的线程会再次上锁，达到多线程下全局变量的访问安全，示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Thread</span><br><span class="line"><span class="keyword">from</span> threading <span class="keyword">import</span> Lock</span><br><span class="line"></span><br><span class="line">g_num = <span class="number">0</span></span><br><span class="line">mutex = Lock()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    mutex.acquire()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    mutex.release()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"---test1--- g_num = %d"</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> g_num</span><br><span class="line">    mutex.acquire()</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">1000000</span>):</span><br><span class="line">        g_num += <span class="number">1</span></span><br><span class="line">    mutex.release()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">"---test2--- g_num = %d "</span> % g_num)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p1 = Thread(target=test1)</span><br><span class="line">p1.start()</span><br><span class="line"></span><br><span class="line">p2 = Thread(target=test2)</span><br><span class="line">p2.start()</span><br><span class="line"></span><br><span class="line">print(<span class="string">"---g_num= %d ---"</span> % g_num)</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">---g_num= <span class="number">200009</span> ---</span><br><span class="line">---test1--- g_num = <span class="number">1000000</span></span><br><span class="line">---test2--- g_num = <span class="number">2000000</span></span><br></pre></td></tr></table></figure><p>​        互斥锁的方法说明：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 创建锁</span></span><br><span class="line">mutex = threading.Lock()</span><br><span class="line"><span class="comment"># 上锁，blocking 为 True 表示堵塞</span></span><br><span class="line">mutex.acquire([blocking])</span><br><span class="line"><span class="comment"># 解锁，只要开了锁，那么接下来会让所有因为这个锁而被阻塞的线程抢着上锁</span></span><br><span class="line">mutex.release()</span><br></pre></td></tr></table></figure><p>​        使用互斥锁时要注意，为了提高运算效率，上锁的资源越少，运算的效率越高</p><p>​        另外，线程等待解锁的方式不是通过轮询，二十通过通知，线程会睡眠，等待唤醒的通知，所以互斥锁较轮询来讲更为优化</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-中的多线程&quot;&gt;&lt;a href=&quot;#Python-中的多线程&quot; class=&quot;headerlink&quot; title=&quot;Python 中的多线程&quot;&gt;&lt;/a&gt;Python 中的多线程&lt;/h1&gt;&lt;h2 id=&quot;什么是线程&quot;&gt;&lt;a href=&quot;#什么是线程&quot; class=&quot;headerlink&quot; title=&quot;什么是线程&quot;&gt;&lt;/a&gt;什么是线程&lt;/h2&gt;&lt;p&gt;​        一个进程中包括多个线程，线程是 CPU 调度和分派的基本单位，是进程中执行运算的最小单位，真正在 CPU 上运行的是线程，可以与同一个进程中的其他线程共享进程的全部资源&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的Python" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84Python/"/>
    
  </entry>
  
  <entry>
    <title>Python——多进程、进程池、进程间通信（还有一个复制文件的小程序）</title>
    <link href="http://yoursite.com/2020/02/03/Python%E2%80%94%E2%80%94%E8%BF%9B%E7%A8%8B%E3%80%81%E8%BF%9B%E7%A8%8B%E6%B1%A0%E3%80%81%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1%EF%BC%88%E8%BF%98%E6%9C%89%E4%B8%80%E4%B8%AA%E5%A4%8D%E5%88%B6%E6%96%87%E4%BB%B6%E7%9A%84%E5%B0%8F%E7%A8%8B%E5%BA%8F%EF%BC%89/"/>
    <id>http://yoursite.com/2020/02/03/Python——进程、进程池、进程间通信（还有一个复制文件的小程序）/</id>
    <published>2020-02-03T12:00:50.000Z</published>
    <updated>2020-02-03T13:06:42.561Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-中的进程"><a href="#Python-中的进程" class="headerlink" title="Python 中的进程"></a>Python 中的进程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p>​        当一段代码被运行，或者一个应用程序被运行，就会创建一个进程，以下内容来自百度百科：</p><p>​        <code>“进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体”</code></p><a id="more"></a><h2 id="并行与并发"><a href="#并行与并发" class="headerlink" title="并行与并发"></a>并行与并发</h2><p>​        每台计算机，cpu 是计算机的运算核心，多核计算机的意思就是，这台计算机上可以同时运行数量等于其核数的进程</p><p>​        并发执行，即 cpu 核数 &lt; 进程数，这个时候这些进程需要操作系统中的调度算法（时间片轮转算法、优先级调度算法等）来协调</p><p>​        并行执行，即 cpu 核数 &gt; 进程数，这个时候所有的进程都能得到执行，就是并行</p><h2 id="Python-中实现多进程的三种方法"><a href="#Python-中实现多进程的三种方法" class="headerlink" title="Python 中实现多进程的三种方法"></a>Python 中实现多进程的三种方法</h2><p>​        在 Python 中，想要实现多进程有三种方式：使用<code>os</code>模块中的<code>fork()</code>函数、使用<code>multiProcessing</code>模块的<code>Process</code>类、使用<code>multiProcessing</code>模块中的<code>Pool</code>（进程池），下面分别介绍这三种方法及他们之间的比较</p><h3 id="使用-os-fork-实现多进程"><a href="#使用-os-fork-实现多进程" class="headerlink" title="使用 os.fork() 实现多进程"></a>使用 os.fork() 实现多进程</h3><p>​        首先，<code>fork()</code>函数只有在 Linux 或者是 类 Linux 系统中才能使用</p><p>​        当程序运行到这个函数时，会新创建一个进程，新的进程会从这个函数的返回值处开始执行，<code>fork()</code>函数很特殊，在父进程里，<code>fork()</code>的返回值为<code>&gt; 0</code>，并且这个返回值就是主进程的<code>pid</code>，而在子进程中<code>fork()</code>的返回值是<code>== 0</code>的</p><p>​        在有<code>fork()</code>函数的程序中，若主程序在子程序结束之前运行完，那么系统不会等待子进程结束，而是会直接结束主进程，但这并不代表子进程也会被结束，子进程此时已经是一个独立的进程，它会自己运行到结束为止</p><p>​        示例如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line">ret = os.fork()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> ret == <span class="number">0</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">'Dad:%d : %d'</span> % (ret, os.getpid()))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">'Son:%d : %d : %d'</span> % (ret, os.getpid(), os.getppid()))</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">Son:6081 : 6079 : 5917</span><br><span class="line">Dad:0 : 6081</span><br><span class="line">Son:6081 : 6079 : 5917</span><br><span class="line">Dad:0 : 6081</span><br><span class="line">Son:6081 : 6079 : 5917</span><br><span class="line">Dad:0 : 6081</span><br><span class="line">Son:6081 : 6079 : 5917</span><br><span class="line">Dad:0 : 6081</span><br><span class="line">Son:6081 : 6079 : 5917</span><br><span class="line">Dad:0 : 6081</span><br><span class="line">Son:6081 : 6079 : 5917</span><br><span class="line">Dad:0 : 6081</span><br><span class="line">Son:6081 : 6079 : 5917</span><br><span class="line">Dad:0 : 6081</span><br></pre></td></tr></table></figure><p>​        <code>os</code>模块的其他常用方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 获取当前进程的 pid（进程号）</span></span><br><span class="line">os.getpid()：</span><br><span class="line"><span class="comment"># 获取当前进程父进程的 pid</span></span><br><span class="line">os.getppid()：</span><br></pre></td></tr></table></figure><h3 id="使用-Process-实现多进程"><a href="#使用-Process-实现多进程" class="headerlink" title="使用 Process 实现多进程"></a>使用 Process 实现多进程</h3><p>​        <code>multiProcessing</code>模块是一个在 Windows 中也可以使用的模块，它包含<code>Process</code>，使用 Process 创建的进程，主进程会等待所有的子进程结束后才结束</p><p>​        并且，<code>Process</code>可以被继承，这样也使得<code>Process</code>可以被更灵活的运用，以及封装功能性代码</p><p>​        使用<code>Process</code>创建进程的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        print(<span class="string">'----test----'</span>)</span><br><span class="line">        time.sleep(<span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">p = Process(target=test)</span><br><span class="line"></span><br><span class="line">p.start()</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">    print(<span class="string">'----main----'</span>)</span><br><span class="line">    time.sleep(<span class="number">1</span>)</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">----main----</span><br><span class="line">----test----</span><br><span class="line">----main----</span><br><span class="line">----test----</span><br><span class="line">----main----</span><br><span class="line">----test----</span><br><span class="line">----main----</span><br><span class="line">----test----</span><br><span class="line">----main----</span><br></pre></td></tr></table></figure><p>​        创建一个类继承<code>Process</code>来实现多进程的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Process_Class</span><span class="params">(Process)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, interval)</span>:</span></span><br><span class="line">        Process.__init__(self)</span><br><span class="line">        self.interval = interval</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span></span><br><span class="line">        print(<span class="string">'son(%s) start, dad is (%s)'</span> % (os.getpid(), os.getppid()))</span><br><span class="line">        t_start = time.time()</span><br><span class="line">        time.sleep(self.interval)</span><br><span class="line">        t_stop = time.time()</span><br><span class="line">        print(<span class="string">'(%s) is over, Is %0.2f seconds'</span> % (os.getpid(), t_stop - t_start))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    t_start = time.time()</span><br><span class="line">    print(<span class="string">'now Process is (%s)'</span> % os.getpid())</span><br><span class="line">    p1 = Process_Class(<span class="number">2</span>)</span><br><span class="line">    p1.start()</span><br><span class="line">    p1.join()</span><br><span class="line">    t_stop = time.time()</span><br><span class="line">    print(<span class="string">'(%s) is over, spend %0.2f seconds'</span> % (os.getpid(), t_stop - t_start))</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">now Process is (6155)</span><br><span class="line">son(6157) start, dad is (6155)</span><br><span class="line">(6157) is over, Is 2.00 seconds</span><br><span class="line">(6155) is over, spend 2.01 seconds</span><br></pre></td></tr></table></figure><p>​        <code>os.Process</code>的其他常用方法及属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 常用方法：</span></span><br><span class="line"><span class="comment"># 判断进程实例是否还在执行</span></span><br><span class="line">Process.is_alive()</span><br><span class="line"><span class="comment"># 是否等待进程实例执行结束，或等待多少秒</span></span><br><span class="line">Process.join([timeout])</span><br><span class="line"><span class="comment"># 启动进程实例（创建子进程）</span></span><br><span class="line">Process.start()</span><br><span class="line"><span class="comment"># 如果没有给定 target 参数，这个对象调用 start() 方法时，就将执行对象中的 run() 方法</span></span><br><span class="line">Process.run()</span><br><span class="line"><span class="comment"># 不管任务是否完成，立即终止</span></span><br><span class="line">Process.terminate()</span><br><span class="line"><span class="comment"># 属性：</span></span><br><span class="line"><span class="comment"># 当前进程实例别名，默认为 Process-N，N 为从 1 开始递增的整数</span></span><br><span class="line">name</span><br><span class="line"><span class="comment"># 当前进程实例的 PID 值</span></span><br><span class="line">pid</span><br></pre></td></tr></table></figure><h3 id="使用-Pool（进程池）实现多进程"><a href="#使用-Pool（进程池）实现多进程" class="headerlink" title="使用 Pool（进程池）实现多进程"></a>使用 Pool（进程池）实现多进程</h3><p>​        当需要创建的子进程数量不多时，可以直接利用<code>multiprocessing</code>中的<code>Process</code>动态生成多个进程，但如果时上百甚至上千个目标，手动的去创建进程的工作量巨大，此时可以用到<code>multiprocessing</code>模块提供的<code>Pool</code>方法</p><p>​        初始化<code>Pool</code>时，可以指定一个最大进程数，当有新的请求提交到<code>Pool</code>中时，如果池还没有满，那么就会创建一个新的进程来执行请求；如果进程池中的进程数已经达到指定的最大值，那么该请求就会等待，直到池中进程结束，才会请求池中的空闲进程来执行</p><p>​        使用<code>Pool</code>实现多进程的示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">worker</span><span class="params">(num)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">        print(<span class="string">'===pid=%d===num=%d'</span> % (os.getpid(), num))</span><br><span class="line">        time.sleep()</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">pool = Pool(<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    print(<span class="string">'---%d---'</span> % i)</span><br><span class="line">    pool.apply_async(worker, (i,))</span><br><span class="line"></span><br><span class="line">pool.close()</span><br><span class="line">pool.join()</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">---0---</span><br><span class="line">---1---</span><br><span class="line">---2---</span><br><span class="line">---3---</span><br><span class="line">---4---</span><br><span class="line">---5---</span><br><span class="line">---6---</span><br><span class="line">---7---</span><br><span class="line">---8---</span><br><span class="line">---9---</span><br><span class="line">===pid=6223===num=0</span><br><span class="line">===pid=6224===num=1</span><br><span class="line">===pid=6225===num=2</span><br><span class="line">===pid=6225===num=3</span><br><span class="line">===pid=6224===num=4</span><br><span class="line">===pid=6224===num=5</span><br><span class="line">===pid=6225===num=6</span><br><span class="line">===pid=6225===num=9</span><br><span class="line">===pid=6223===num=7</span><br><span class="line">===pid=6224===num=8</span><br></pre></td></tr></table></figure><p>​        <code>Pool</code>的其他常用方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 非堵塞式添加进程，第一个参数为需要调用的目标，第二个参数为传递给目标参数的元组</span></span><br><span class="line"><span class="comment"># 如果添加的任务数量超过了进程池中进程的个数的话，不会导致添加不进去，它会等待进程池中的进程完成一个任务后，自动的用刚刚那个进程，完成当前的新任务</span></span><br><span class="line">Pool.apply_async(func, (item, item, ...))</span><br><span class="line"><span class="comment"># 堵塞式添加进程，每个请求添加就开始执行，结束后再添加下一个请求</span></span><br><span class="line">Pool.apply(func, (item, item, ...))</span><br><span class="line"><span class="comment"># 关闭进程池，关闭后进程池不会再接收新的请求</span></span><br><span class="line">Pool.close()</span><br><span class="line"><span class="comment"># 主进程在向进程池创建或添加任务后，默认不会等待进程池中的任务执行完，join 函数就是等待 Pool 中所有的子进程执行完成，必须放在 close() 函数后执行</span></span><br><span class="line">Pool.join()</span><br></pre></td></tr></table></figure><h3 id="三种方法的比较："><a href="#三种方法的比较：" class="headerlink" title="三种方法的比较："></a>三种方法的比较：</h3><p>​        <code>fork()</code>：最底层的方法，其余两种方法创建进程实际上最底层也是通过fork()来创建的，<code>fork()</code>不能直接跨平台使用，只支持 Linux 或类 Linux 平台<br>​        <code>Process</code>：父进程和子进程都用来执行，并且父进程会等待所有子进程结束后再结束<br>​        <code>Pool</code>：<code>Pool</code>方法中，父进程一般只用于等待，真正的任务都在子进程中执行</p><h2 id="进程间通信（使用-Queue）"><a href="#进程间通信（使用-Queue）" class="headerlink" title="进程间通信（使用 Queue）"></a>进程间通信（使用 Queue）</h2><p>​        进程之间是没有任何关联的，可以使用队列来进行进程间的通信，这里使用的是<code>multiProcessing</code>模块的<code>Queue</code>和<code>Manage</code>（用于线程池）</p><p>​        队列是一种先进先出（FIFO）的数据结构，下面是通过不断向同一个队列中输入数据和读取数据实现进程间的通信</p><h3 id="使用-Queue（使用-Process-实现的多进程）"><a href="#使用-Queue（使用-Process-实现的多进程）" class="headerlink" title="使用 Queue（使用 Process 实现的多进程）"></a>使用 Queue（使用 Process 实现的多进程）</h3><p>​        直接放代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Process</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Queue</span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">import</span> random</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">write</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">for</span> value <span class="keyword">in</span> [<span class="string">'A'</span>, <span class="string">'B'</span>, <span class="string">'C'</span>]:</span><br><span class="line">        print(<span class="string">'Put %s to queue...'</span> % value)</span><br><span class="line">        q.put(value)</span><br><span class="line">        time.sleep(random.random())</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">read</span><span class="params">(q)</span>:</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> q.empty():</span><br><span class="line">            value = q.get(<span class="literal">True</span>)</span><br><span class="line">            print(<span class="string">'Get %s from queue'</span> % value)</span><br><span class="line">            time.sleep(random.random())</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line"></span><br><span class="line">    q = Queue()</span><br><span class="line">    pw = Process(target=write, args=(q,))</span><br><span class="line">    pr = Process(target=read, args=(q,))</span><br><span class="line"></span><br><span class="line">    pw.start()</span><br><span class="line">    pw.join()</span><br><span class="line"></span><br><span class="line">    pr.start()</span><br><span class="line">    pr.join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">' '</span>)</span><br><span class="line">    print()</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Put A to queue...</span><br><span class="line">Put B to queue...</span><br><span class="line">Put C to queue...</span><br><span class="line">Get A from queue</span><br><span class="line">Get B from queue</span><br><span class="line">Get C from queue</span><br></pre></td></tr></table></figure><h3 id="使用-Manage（使用-Pool-实现的多进程）"><a href="#使用-Manage（使用-Pool-实现的多进程）" class="headerlink" title="使用 Manage（使用 Pool 实现的多进程）"></a>使用 Manage（使用 Pool 实现的多进程）</h3><p>​        直接放代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">reader</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">'reader start (%s), Dad is (%s)'</span> % (os.getpid(), os.getppid()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(q.qsize()):</span><br><span class="line">        print(<span class="string">'rader get from queue : %s'</span> % q.get(<span class="literal">True</span>))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">writer</span><span class="params">(q)</span>:</span></span><br><span class="line">    print(<span class="string">'writer start (%s), Dad is (%s)'</span> % (os.getpid(), os.getppid()))</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> <span class="string">'LiMingHui love GH'</span>:</span><br><span class="line">        q.put(i)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    print(<span class="string">'(%s) start'</span> % os.getpid())</span><br><span class="line">    q = Manager().Queue()</span><br><span class="line">    po = Pool()</span><br><span class="line"></span><br><span class="line">    po.apply(writer, (q,))</span><br><span class="line">    po.apply(reader, (q,))</span><br><span class="line"></span><br><span class="line">    po.close()</span><br><span class="line">    po.join()</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'(%s) is end'</span> % os.getpid())</span><br></pre></td></tr></table></figure><p>​        运行结果：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">(6306) start</span><br><span class="line">writer start (6313), Dad is (6306)</span><br><span class="line">reader start (6313), Dad is (6306)</span><br><span class="line">rader get from queue : L</span><br><span class="line">rader get from queue : i</span><br><span class="line">rader get from queue : M</span><br><span class="line">rader get from queue : i</span><br><span class="line">rader get from queue : n</span><br><span class="line">rader get from queue : g</span><br><span class="line">rader get from queue : H</span><br><span class="line">rader get from queue : u</span><br><span class="line">rader get from queue : i</span><br><span class="line">rader get from queue :  </span><br><span class="line">rader get from queue : l</span><br><span class="line">rader get from queue : o</span><br><span class="line">rader get from queue : v</span><br><span class="line">rader get from queue : e</span><br><span class="line">rader get from queue :  </span><br><span class="line">rader get from queue : G</span><br><span class="line">rader get from queue : H</span><br><span class="line">(6306) is end</span><br></pre></td></tr></table></figure><h2 id="一个使用多进程实现的复制文件夹的小程序"><a href="#一个使用多进程实现的复制文件夹的小程序" class="headerlink" title="一个使用多进程实现的复制文件夹的小程序"></a>一个使用多进程实现的复制文件夹的小程序</h2><p>​        只需要输入文件夹名字，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Pool</span><br><span class="line"><span class="keyword">from</span> multiprocessing <span class="keyword">import</span> Manager</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">copyFile</span><span class="params">(name, oldFolderName, newFolderName, queue)</span>:</span></span><br><span class="line">    fr = open(oldFolderName + <span class="string">'/'</span> + name)</span><br><span class="line">    fw = open(newFolderName + <span class="string">'/'</span> + name, <span class="string">'w'</span>)</span><br><span class="line"></span><br><span class="line">    content = fr.read()</span><br><span class="line">    fw.write(content)</span><br><span class="line"></span><br><span class="line">    fr.close()</span><br><span class="line">    fw.close()</span><br><span class="line"></span><br><span class="line">    queue.put(name)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">main</span><span class="params">()</span>:</span></span><br><span class="line">    oldFolderName = input(<span class="string">'Floder-name is:'</span>)</span><br><span class="line">    newFolderName = oldFolderName + <span class="string">'_scopy'</span></span><br><span class="line">    os.mkdir(newFolderName)</span><br><span class="line"></span><br><span class="line">    fileNames = os.listdir(oldFolderName)</span><br><span class="line"></span><br><span class="line">    pool = Pool(<span class="number">5</span>)</span><br><span class="line">    queue = Manager().Queue()</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> name <span class="keyword">in</span> fileNames:</span><br><span class="line">        pool.apply_async(copyFile, args=(name, oldFolderName, newFolderName, queue))</span><br><span class="line"></span><br><span class="line">    num = <span class="number">0</span></span><br><span class="line">    allNum = len(fileNames)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> num &lt; allNum:</span><br><span class="line">        queue.get()</span><br><span class="line">        num += <span class="number">1</span></span><br><span class="line">        copyRate = num / allNum</span><br><span class="line">        print(<span class="string">'\rcopy : %.2f %%'</span> % (copyRate * <span class="number">100</span>), end=<span class="string">""</span>)</span><br><span class="line"></span><br><span class="line">    print(<span class="string">'copy end...'</span>)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">'__main__'</span>:</span><br><span class="line">    main()</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-中的进程&quot;&gt;&lt;a href=&quot;#Python-中的进程&quot; class=&quot;headerlink&quot; title=&quot;Python 中的进程&quot;&gt;&lt;/a&gt;Python 中的进程&lt;/h1&gt;&lt;h2 id=&quot;什么是进程&quot;&gt;&lt;a href=&quot;#什么是进程&quot; class=&quot;headerlink&quot; title=&quot;什么是进程&quot;&gt;&lt;/a&gt;什么是进程&lt;/h2&gt;&lt;p&gt;​        当一段代码被运行，或者一个应用程序被运行，就会创建一个进程，以下内容来自百度百科：&lt;/p&gt;
&lt;p&gt;​        &lt;code&gt;“进程（Process）是计算机中的程序关于某数据集合上的一次运行活动，是系统进行资源分配和调度的基本单位，是操作系统结构的基础。在早期面向进程设计的计算机结构中，进程是程序的基本执行实体；在当代面向线程设计的计算机结构中，进程是线程的容器。程序是指令、数据及其组织形式的描述，进程是程序的实体”&lt;/code&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的Python" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84Python/"/>
    
  </entry>
  
  <entry>
    <title>Python——正则表达式</title>
    <link href="http://yoursite.com/2020/02/01/Python%E2%80%94%E2%80%94%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/02/01/Python——正则表达式/</id>
    <published>2020-02-01T10:56:03.000Z</published>
    <updated>2020-02-01T12:00:10.052Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Python-中的正则表达式"><a href="#Python-中的正则表达式" class="headerlink" title="Python 中的正则表达式"></a>Python 中的正则表达式</h1><p>​        正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定的字符串、及这些特定字符的组合，组成一个”规则字符串“，这个规则字符串用来表示对字符串的一种过滤逻辑</p><p>​        字符串是编程时涉及到的最多的一种数据结构，使用正则表达式可以完成判断一个字符串是否为合法电话号、是否是 Email 格式等操作</p><p>​        文章最后符一些常用的正则表达式！</p><a id="more"></a><h2 id="正则表达式通用符号及解释"><a href="#正则表达式通用符号及解释" class="headerlink" title="正则表达式通用符号及解释"></a>正则表达式通用符号及解释</h2><table><thead><tr><th align="center">模式</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">.</td><td align="center">匹配任意除 <code>\n</code>外的字符</td></tr><tr><td align="center">\</td><td align="center">转义字符，是一个特殊字符原来的意思</td></tr><tr><td align="center">[…]</td><td align="center">对应位置可以是字符集中的任意字符</td></tr><tr><td align="center">\d</td><td align="center">数字（0~9）</td></tr><tr><td align="center">\D</td><td align="center">非数字</td></tr><tr><td align="center">\s</td><td align="center">空白字符（空格、\t、\r、\n、\f、\v）</td></tr><tr><td align="center">\S</td><td align="center">非空白字符</td></tr><tr><td align="center">\w</td><td align="center">单词字符（A<del>Z、a</del>z、0~9）</td></tr><tr><td align="center">\W</td><td align="center">非单词字符</td></tr><tr><td align="center">*</td><td align="center">匹配前一个字符 0 或 无限次</td></tr><tr><td align="center">+</td><td align="center">匹配前一个字符 1 或 无限次</td></tr><tr><td align="center">？</td><td align="center">匹配前一个字符 0 或 1 次</td></tr><tr><td align="center">{m}</td><td align="center">匹配前一个字符串 m 次</td></tr><tr><td align="center">{m, n}</td><td align="center">匹配前一个字符串 m 至 n 次</td></tr><tr><td align="center">^</td><td align="center">匹配字符串开头</td></tr><tr><td align="center">$</td><td align="center">匹配字符串末尾</td></tr><tr><td align="center">\A</td><td align="center">仅匹配字符串开头</td></tr><tr><td align="center">\Z</td><td align="center">仅匹配字符串末尾</td></tr><tr><td align="center">\b</td><td align="center">匹配 \w 和 \W 之间</td></tr><tr><td align="center">\B</td><td align="center">与上一个相反</td></tr></tbody></table><h2 id="re-模块"><a href="#re-模块" class="headerlink" title="re 模块"></a>re 模块</h2><p>​        python 通过导入 re 模块来使用正则表达式功能</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> re</span><br></pre></td></tr></table></figure><h3 id="re-compile"><a href="#re-compile" class="headerlink" title="re.compile"></a>re.compile</h3><p>​        compile 函数的返回值是一个 <code>pattern</code>（正则表达式对象），是用来自己定义正则表达式的函数，下面的句子是描述一个以 he 开头，后面接任意字符，并且以 o 结尾的字符串的正则表达式，例如 hello</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pattern = re.compile(<span class="string">r'^(he)+.*o$'</span>)</span><br></pre></td></tr></table></figure><h3 id="re-match"><a href="#re-match" class="headerlink" title="re.match"></a>re.match</h3><p>​        match 函数是根据给定的正则表达式，来判定一个字符串是否符合规则的函数，匹配成功返回一个 match 对象，否则返回 None，下面是以上边 compile 函数返回的正则表达式为基础，对字符串检测的语句</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">result = re.match(pattern, <span class="string">'hello'</span>)</span><br><span class="line">result = re.match(pattern, <span class="string">'hello'</span>, re.l)</span><br><span class="line"><span class="comment"># match 函数的第三个参数 flag 为可选参数，表示标志位，用于控制正则表达式的匹配方式，有如下用法：</span></span><br><span class="line"><span class="comment"># re.l 使匹配对大小写不敏感</span></span><br><span class="line"><span class="comment"># re.L 使匹配对大小写不敏感</span></span><br><span class="line"><span class="comment"># re.M 多行匹配</span></span><br><span class="line"><span class="comment"># re.S 使 . 匹配包括换行在内的左右字符</span></span><br><span class="line"><span class="comment"># re.U 根据 Unicode 字符集解析字符</span></span><br><span class="line"><span class="comment"># re.X 使格式更灵活，以便正则表达式更易于理解</span></span><br></pre></td></tr></table></figure><h3 id="match-group"><a href="#match-group" class="headerlink" title="match.group"></a>match.group</h3><p>​        这个函数是用来获取匹配后的字符串的，它的返回值是一个元组</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 返回一个包含所有小组字符串的元组，从 1 到 所含的小组号</span></span><br><span class="line">result.group()</span><br><span class="line"><span class="comment"># 返回一个包含 num 指定小组所对应值的元组</span></span><br><span class="line">result.group(num)</span><br></pre></td></tr></table></figure><h3 id="re-search"><a href="#re-search" class="headerlink" title="re.search"></a>re.search</h3><p>​        search 函数的用法和 match 函数很接近，search 函数会扫描整个字符串并返回第一个成功的匹配，也是一个 match 对象，使用的参数也与 match 函数相同</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">res = re.search(pattern1, str)</span><br><span class="line">res = re.search(pattern1, str, re.l)</span><br></pre></td></tr></table></figure><p>​        二者的区别在于，match 函数只匹配字符串的开始，如果开始不符合，就会匹配失败，而 search 函数会匹配整个字符串，直到找到一个匹配</p><h3 id="re-findall"><a href="#re-findall" class="headerlink" title="re.findall"></a>re.findall</h3><p>​        findall 函数会找到字符串中所有符合正则表达式规则的字符串，返回值是一个列表，如果没有匹配，就会返回一个空列表</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">res1 = re.findall(pattern1, str)</span><br></pre></td></tr></table></figure><h3 id="re-finditer"><a href="#re-finditer" class="headerlink" title="re.finditer"></a>re.finditer</h3><p>​        finditer 也是查找所有符合正则表达式规则的字符串，不同的是返回值，finditer 返回的是一个迭代器，用法如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> re.finditer(pattern1, str):</span><br><span class="line">    print(item.group())</span><br></pre></td></tr></table></figure><h2 id="小样例"><a href="#小样例" class="headerlink" title="小样例"></a>小样例</h2><p>​        常用的正则表达式：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span> Email地址：^\w+([-+.]\w+)*@\w+([-.]\w+)*\.\w+([-.]\w+)*$</span><br><span class="line"></span><br><span class="line">2. 域名：[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;(/.[a-zA-Z0-9][-a-zA-Z0-9]&#123;0,62&#125;)+/.?</span><br><span class="line"></span><br><span class="line">3. InternetURL：[a-zA-z]+://[^\s]* 或 ^http://([\w-]+\.)+[\w-]+(/[\w-./?%&amp;=]*)?$</span><br><span class="line"></span><br><span class="line"><span class="number">4.</span> 手机号码：^(<span class="number">13</span>[<span class="number">0</span><span class="number">-9</span>]|<span class="number">14</span>[<span class="number">5</span>|<span class="number">7</span>]|<span class="number">15</span>[<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">5</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9</span>]|<span class="number">18</span>[<span class="number">0</span>|<span class="number">1</span>|<span class="number">2</span>|<span class="number">3</span>|<span class="number">5</span>|<span class="number">6</span>|<span class="number">7</span>|<span class="number">8</span>|<span class="number">9</span>])\d&#123;<span class="number">8</span>&#125;$</span><br><span class="line"></span><br><span class="line"><span class="number">5.</span> 电话号码(<span class="string">"XXX-XXXXXXX"</span>、<span class="string">"XXXX-XXXXXXXX"</span>、<span class="string">"XXX-XXXXXXX"</span>、<span class="string">"XXX-XXXXXXXX"</span>、<span class="string">"XXXXXXX"</span>和<span class="string">"XXXXXXXX)：^(\(\d&#123;3,4&#125;-)|\d&#123;3.4&#125;-)?\d&#123;7,8&#125;$</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">6. 国内电话号码(0511-4405222、021-87888822)：\d&#123;3&#125;-\d&#123;8&#125;|\d&#123;4&#125;-\d&#123;7&#125;</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">7. 身份证号(15位、18位数字)：^\d&#123;15&#125;|\d&#123;18&#125;$</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Python-中的正则表达式&quot;&gt;&lt;a href=&quot;#Python-中的正则表达式&quot; class=&quot;headerlink&quot; title=&quot;Python 中的正则表达式&quot;&gt;&lt;/a&gt;Python 中的正则表达式&lt;/h1&gt;&lt;p&gt;​        正则表达式是对字符串操作的一种逻辑公式，就是用事先定义好的一些特定的字符串、及这些特定字符的组合，组成一个”规则字符串“，这个规则字符串用来表示对字符串的一种过滤逻辑&lt;/p&gt;
&lt;p&gt;​        字符串是编程时涉及到的最多的一种数据结构，使用正则表达式可以完成判断一个字符串是否为合法电话号、是否是 Email 格式等操作&lt;/p&gt;
&lt;p&gt;​        文章最后符一些常用的正则表达式！&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的Python" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84Python/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JAVA中的流</title>
    <link href="http://yoursite.com/2020/01/31/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JAVA%E4%B8%AD%E7%9A%84%E6%B5%81/"/>
    <id>http://yoursite.com/2020/01/31/JAVA基础——JAVA中的流/</id>
    <published>2020-01-31T11:41:20.000Z</published>
    <updated>2020-01-31T13:33:13.112Z</updated>
    
    <content type="html"><![CDATA[<h1 id="什么是-JAVA-中的“流”"><a href="#什么是-JAVA-中的“流”" class="headerlink" title="什么是 JAVA 中的“流”"></a>什么是 JAVA 中的“流”</h1><p>​        流是一种抽象出来的概念，当数据在介质中传输，就形成了流，所以流就是用来进行数据的传输的</p><a id="more"></a><h2 id="流的分类"><a href="#流的分类" class="headerlink" title="流的分类"></a>流的分类</h2><p>​        JAVA 中的流根据其在方向上、处理数据单元上、使用方式上可以分为很多种类</p><p>​        流可以分为输入流和输出流两大类， I（input）和 O（output），即我们常说的 I/O 流，这里的输入和输出是对 JAVA 程序来说的，数据流向 JAVA 程序时，是流入，即输入流，数据从 JAVA 程序中输出时，是流出，即输出流</p><p>​        又可以根据数据单元的不同，分为字节流和字符流，字节流可以处理所有类型的数据，因为它是一个字节一个字节的去读取数据的，而字符流则更适合处理文本数据，他们和输入流及输出流的概念并不冲突</p><h2 id="输入流"><a href="#输入流" class="headerlink" title="输入流"></a>输入流</h2><p>​        输入流是指将数据读入到 JAVA 程序中，包括 <code>Reader</code>、<code>InputStream</code> 以及它们的子类，一下以实例说明用法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">    br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"F://lmh.txt"</span>));</span><br><span class="line">    String str = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((str = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        System.out.println(str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (br != <span class="keyword">null</span>) &#123;</span><br><span class="line">        br.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这个样例是以 <code>FileReader</code> 为基础，使用包装流 <code>Buffered</code> 包装，将一个文件中的数据读入程序中，所有的输入流中，都包含 read 方法用来读入数据，与字节流不同的是，字符流中的 <code>Reader</code> 支持 <code>readLine</code> 方法，可以将一行数据一次性读入，这也证明了字符流更适合操作文本数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    File file = <span class="keyword">new</span> File(<span class="string">"F:/lmh.txt"</span>);</span><br><span class="line">    <span class="keyword">if</span> (!file.exists())</span><br><span class="line">        file.createNewFile();</span><br><span class="line">    String path = file.getPath();</span><br><span class="line">    <span class="keyword">byte</span>[] buf = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">10000</span>];</span><br><span class="line">    FileInputStream fis = <span class="keyword">new</span> FileInputStream(path);</span><br><span class="line">    <span class="keyword">int</span> fisRead = <span class="number">0</span>;</span><br><span class="line">    fisRead = fis.read(buf);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这个样例是一个典型的，使用字节流向 JAVA 程序读入数据的功能，这里的读入使用 read 函数，read 函数有三种使用方法，一种是无参的读入，<code>read()</code> ，它不会存储读入的数据，只是一味的将读入指针在文件中后移，第二种是有参的读入，<code>read(byte[] bt)</code>，它会存储读入的数据，保存在名为 bt 的 byte 数组中，第三种是 <code>read(byte[] bt, int orr, int len)</code>，它是从输入流读取 len 个字节的数据到 bt 数组，off 为 bt 数组的起始偏移量，这也体现了字符流和字节流在读入数据时的区别</p><h2 id="输出流"><a href="#输出流" class="headerlink" title="输出流"></a>输出流</h2><p>​        输出流是将数据从 JAVA 程序输出到控制台或者文件中的流，可以理解为流出 JAVA 程序，包括 <code>Writer</code> 和 <code>OutputStream</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    BufferedReader br = <span class="keyword">null</span>;</span><br><span class="line">    BufferedWriter bw = <span class="keyword">null</span>;</span><br><span class="line">    br = <span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> FileReader(<span class="string">"F://lmh.txt"</span>));</span><br><span class="line">    bw = <span class="keyword">new</span> BufferedWriter(<span class="keyword">new</span> FileWriter(<span class="string">"F://lmh01.txt"</span>));</span><br><span class="line">    String str = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">while</span> ((str = br.readLine()) != <span class="keyword">null</span>) &#123;</span><br><span class="line">        bw.write(str, <span class="number">0</span>, str.length());</span><br><span class="line">        bw.newLine();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (br != <span class="keyword">null</span> || bw != <span class="keyword">null</span>) &#123;</span><br><span class="line">        br.close();</span><br><span class="line">        bw.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这个样例是一个先使用 <code>Reader</code> 读入数据，再将读入到的数据使用 <code>Writer</code> 写入另一个文件的功能，使用包装流 <code>BufferedWriter</code> 对 <code>FileWriter</code> 进行包装，可以提高运行效率，在使用 <code>Writer</code> 中定义的 write 方法，将其写入到文件中，write 方法有三种，一种是<code>write(char c)</code>，将指定的字符写入，第二种是<code>write(CharSequence cs)</code>，将指定的字符序列写入，第三种是<code>write(CharSequence cs, int off, int len)</code>，写入字符序列 cs 中从 off 位置开始，长度为 len 的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    DataInputStream dis = <span class="keyword">null</span>;</span><br><span class="line">    DataOutputStream dos = <span class="keyword">null</span>;</span><br><span class="line">    dis = <span class="keyword">new</span> DataInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"C://Users//StephenCurry//Desktop//chance//IMA//curry.jpg"</span>));</span><br><span class="line">    dos = <span class="keyword">new</span> DataOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"C://Users//StephenCurry//Desktop//chance//IMA//curry5.jpg"</span>));</span><br><span class="line">    <span class="keyword">byte</span>[] bt = <span class="keyword">new</span> <span class="keyword">byte</span>[<span class="number">1024000</span>];</span><br><span class="line">    <span class="keyword">int</span> length = dis.read(bt);</span><br><span class="line">    dos.write(bt, <span class="number">0</span>, length);</span><br><span class="line">    <span class="keyword">if</span> (dis != <span class="keyword">null</span> || dos != <span class="keyword">null</span>) &#123;</span><br><span class="line">        dis.close();</span><br><span class="line">        dos.close();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这个样例就比较有趣了，使用字节流读入一张 jpg 的图片，再使用字节流输出到一个空的 jpg 文件中，实现文件的复制，因为是图片，这里必须使用字节流，使用 write 函数，将读入的字节数据，全部写入到另一个文件中，便完成了文件的复制</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>​        这里说的只不过是流的简单用法，最重要的是，每种流都有它最擅长的地方，学会在什么情景下使用什么流，才是最关键的</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;什么是-JAVA-中的“流”&quot;&gt;&lt;a href=&quot;#什么是-JAVA-中的“流”&quot; class=&quot;headerlink&quot; title=&quot;什么是 JAVA 中的“流”&quot;&gt;&lt;/a&gt;什么是 JAVA 中的“流”&lt;/h1&gt;&lt;p&gt;​        流是一种抽象出来的概念，当数据在介质中传输，就形成了流，所以流就是用来进行数据的传输的&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>算法——双指针算法</title>
    <link href="http://yoursite.com/2020/01/17/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%8F%8C%E6%8C%87%E9%92%88%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/01/17/算法——双指针算法/</id>
    <published>2020-01-17T13:56:51.000Z</published>
    <updated>2020-01-17T14:38:40.288Z</updated>
    
    <content type="html"><![CDATA[<h1 id="双指针算法"><a href="#双指针算法" class="headerlink" title="双指针算法"></a>双指针算法</h1><p>​        双指针算法是指一切采用双指针的方式，降低原本暴力解法的时间复杂度的算法，通常双指针算法可以将暴力的 <code>O(n^2)</code>降低到 <code>O(n)</code></p><p>​        由于双指针算法指的是一类算法，下面我用两道题来简单解释一下</p><a id="more"></a><h2 id="单词个数问题"><a href="#单词个数问题" class="headerlink" title="单词个数问题"></a>单词个数问题</h2><p>​        即查找一段字符串中，以空格为分隔的单词的个数，这道题用暴力法完全可解，外层 for 循环遍历整个字符数组，内层 for 循环检测 <code>&#39; &#39;</code> 字符，但是显然这种方法时间复杂度是 <code>O(n^2)</code></p><p>​        如果采用双指针算法， 外层循环用来控制遍历字符串，内层循环直接跳到 <code>&#39; &#39;</code> 处，记住这个单词后，直接将外层循环跳到 <code>&#39; &#39;</code> 的下一位继续执行，时间复杂度便为 <code>&#39;O(n)&#39;</code></p><h3 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">numStr</span><span class="params">(<span class="keyword">char</span> str[])</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> l = <span class="number">0</span>, r = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">int</span> length = <span class="built_in">strlen</span>(str);</span><br><span class="line"><span class="keyword">while</span> (str[l]) &#123;</span><br><span class="line"><span class="keyword">while</span> (r &lt;= length &amp;&amp; str[r] != <span class="string">' '</span>)</span><br><span class="line">r++;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = l; k &lt; r; k++)</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; str[k];</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">sum++;</span><br><span class="line">l = ++r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum = numStr(<span class="string">"hello world !"</span>);</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="string">"有 "</span> &lt;&lt; sum &lt;&lt; <span class="string">" 个单词"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="最长连续不重复子序列问题"><a href="#最长连续不重复子序列问题" class="headerlink" title="最长连续不重复子序列问题"></a>最长连续不重复子序列问题</h2><p>​        首先，这个问题也可以使用暴力法，嵌套 for 循环，可以解决问题，但是速度慢且代码复杂</p><p>​        采用双指针算法的思想，第一个指针持续后移，使用另一个数组统计每个数字出现的次数来控制第二个指针的移动，以此来计算不重复子序列，时间复杂度可达到 <code>O(n)</code></p><h3 id="代码-1"><a href="#代码-1" class="headerlink" title="代码"></a>代码</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Windows.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> a[N];</span><br><span class="line"><span class="keyword">int</span> s[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; a[i];</span><br><span class="line"><span class="keyword">int</span> res = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">s[a[i]]++;</span><br><span class="line"><span class="keyword">while</span> (s[a[i]] &gt; <span class="number">1</span>) &#123;</span><br><span class="line">s[a[j]]--;</span><br><span class="line">j++;</span><br><span class="line">&#125;</span><br><span class="line">res = max(res, i - j + <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; res &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h2><p>​        另外归并排序也是双指针算法的一个实例，归并排序在我之前的博客有讲过，链接是：<a href="https://stephencuhui.github.io/2020/01/14/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/" target="_blank" rel="noopener">归并排序讲解</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;双指针算法&quot;&gt;&lt;a href=&quot;#双指针算法&quot; class=&quot;headerlink&quot; title=&quot;双指针算法&quot;&gt;&lt;/a&gt;双指针算法&lt;/h1&gt;&lt;p&gt;​        双指针算法是指一切采用双指针的方式，降低原本暴力解法的时间复杂度的算法，通常双指针算法可以将暴力的 &lt;code&gt;O(n^2)&lt;/code&gt;降低到 &lt;code&gt;O(n)&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;​        由于双指针算法指的是一类算法，下面我用两道题来简单解释一下&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法——二分查找</title>
    <link href="http://yoursite.com/2020/01/15/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    <id>http://yoursite.com/2020/01/15/算法——二分查找/</id>
    <published>2020-01-15T05:25:57.000Z</published>
    <updated>2020-01-15T07:07:46.598Z</updated>
    
    <content type="html"><![CDATA[<h1 id="二分算法"><a href="#二分算法" class="headerlink" title="二分算法"></a>二分算法</h1><p>​        二分算法分为浮点数二分和整数二分，整数二分相对于浮点数二分来讲更复杂，需要考虑边界问题等</p><a id="more"></a><h2 id="二分思想"><a href="#二分思想" class="headerlink" title="二分思想"></a>二分思想</h2><p>​        二分算法的思想是就一段有序序列来讲，想要查找其中某一个数，可以先找到位于序列中点的数，如果目标值小等于中点值，且序列是单调递增的，那么目标值一定在中点左侧，这样再用同样的方式对左侧区间进行二分，如此查找，最后就会找到要找的数字</p><h2 id="整数二分"><a href="#整数二分" class="headerlink" title="整数二分"></a>整数二分</h2><p>​        整数二分思想上很好理解，就是将有序的序列从中间分开，判断目标值在哪半边，再继续二分那段序列就可以</p><p>​        下面给出整数二分的一个例子，包括了整数二分的两种写法</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"><span class="keyword">int</span> q[N];</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">quick_sort</span><span class="params">(<span class="keyword">int</span> l, <span class="keyword">int</span> r, <span class="keyword">int</span> k)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line"><span class="keyword">return</span> q[l];</span><br><span class="line"><span class="keyword">int</span> x = q[l], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line"><span class="keyword">while</span> (x &gt; q[++i]);</span><br><span class="line"><span class="keyword">while</span> (x &lt; q[--j]);</span><br><span class="line"><span class="keyword">if</span> (i &lt; j)</span><br><span class="line">swap(q[i], q[j]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> sl = j - l + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">if</span> (k &lt;= sl)</span><br><span class="line"><span class="keyword">return</span> quick_sort(l, j, k);</span><br><span class="line"><span class="keyword">return</span> quick_sort(j + <span class="number">1</span>, r, k - sl);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d %d"</span>, &amp;n, &amp;k);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">scanf</span>(<span class="string">"%d"</span>, &amp;q[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; quick_sort(<span class="number">0</span>, n - <span class="number">1</span>, k);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        这里之所以存在两种写法，主要区别在于求中点 mid 的值时，如果边界值采取不当的话，整数二分极有可能产生死循环导致程序崩溃，所以须在求 mid 时进行向下取整，即 <code>mid = (l + r + 1) / 2</code></p><h2 id="浮点数二分"><a href="#浮点数二分" class="headerlink" title="浮点数二分"></a>浮点数二分</h2><p>​        在理解了整数二分的基础上，理解浮点数二分就变得十分简单了，因为浮点数二分不会涉及到边界问题，所以在确定边界值上十分简单，下面是用浮点数二分的思想实现的开平方问题</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="keyword">double</span> x;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; x;</span><br><span class="line"><span class="keyword">double</span> l = <span class="number">0</span>, r = x;</span><br><span class="line"><span class="keyword">while</span> (r - l &gt; <span class="number">1e-6</span>) &#123;</span><br><span class="line"><span class="keyword">double</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line"><span class="keyword">if</span> (mid * mid &gt;= x)</span><br><span class="line">r = mid;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">l = mid;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;二分算法&quot;&gt;&lt;a href=&quot;#二分算法&quot; class=&quot;headerlink&quot; title=&quot;二分算法&quot;&gt;&lt;/a&gt;二分算法&lt;/h1&gt;&lt;p&gt;​        二分算法分为浮点数二分和整数二分，整数二分相对于浮点数二分来讲更复杂，需要考虑边界问题等&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法——归并排序</title>
    <link href="http://yoursite.com/2020/01/14/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%BD%92%E5%B9%B6%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/01/14/算法——归并排序/</id>
    <published>2020-01-14T09:54:45.000Z</published>
    <updated>2020-01-14T10:39:35.363Z</updated>
    
    <content type="html"><![CDATA[<h1 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h1><p>​        归并排序是另一种排序算法，也是采用分治的思想，但是和快排有很大的区别，归并排序是稳定的，而快排则不稳定</p><a id="more"></a><h2 id="归并的思想"><a href="#归并的思想" class="headerlink" title="归并的思想"></a>归并的思想</h2><p>​        归并排序的思想可以简单的分为三个步骤：</p><ol><li>确定分界点 mid</li><li>递归分界点得到左右空间</li><li>归并，将若干数组合并为一个有序数组</li></ol><h2 id="确定分界点"><a href="#确定分界点" class="headerlink" title="确定分界点"></a>确定分界点</h2><p>​        确定分界点，归并排序的分界点即为数组的中点，设数组左边界为 left，有边界为 right，那么分界点 mid 便为 </p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br></pre></td></tr></table></figure><p>​        归并排序的分界点和快排的分界点有本质的区别，快排的分界点是对数组的元素值而言的，而归并排序的分界点是就数组的 index 来说的</p><p>​        通过确定的分界点，一个数组就被分解成了两个以 mid 为分界的数组，第一个数组的就原素组而言的下标范围是 left &lt;= index &lt;= mid，第二个数组是 mid + 1 &lt;= index &lt;= right</p><h2 id="递归分界点左右空间"><a href="#递归分界点左右空间" class="headerlink" title="递归分界点左右空间"></a>递归分界点左右空间</h2><p>​        根据第一步得到的结果，可以使用递归将得到的两个数组继续分解，即</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">merge_sort(q, l, mid);</span><br><span class="line">merge_sort(q, mid + <span class="number">1</span>, r);</span><br></pre></td></tr></table></figure><h2 id="归并"><a href="#归并" class="headerlink" title="归并"></a>归并</h2><p>​        这是归并排序最重要的一步，是对归并得到的数组得处理，对于两个有序数组来说，想要合并，就要不断得对比数组头位置元素的大小，这又是使用双指针，分别指向两个数组的头元素，不断对比两个指针对应元素大小，保存较小的那个，并后移与其对应的指针，由于两个指针实际上是分步执行的，当其中一个数组被遍历完后，直接将另一个数组接到答案数组的尾部即可，代码如下</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//k 用来记录答案数组中现存元素的数量</span></span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line"><span class="keyword">if</span> (q[i] &lt;= q[j])</span><br><span class="line">tmp[k++] = q[i++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tmp[k++] = q[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">tmp[k++] = q[i++];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">tmp[k++] = q[j++];</span><br><span class="line"><span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++)</span><br><span class="line">q[i] = tmp[j];</span><br></pre></td></tr></table></figure><h2 id="全部代码"><a href="#全部代码" class="headerlink" title="全部代码"></a>全部代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100000</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> q[N], tmp[N];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="keyword">int</span> q[], <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line"><span class="keyword">if</span> (l == r)</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line"><span class="keyword">int</span> mid = (l + r) / <span class="number">2</span>;</span><br><span class="line">merge_sort(q, l, mid);</span><br><span class="line">merge_sort(q, mid + <span class="number">1</span>, r);</span><br><span class="line"><span class="keyword">int</span> k = <span class="number">0</span>, i = l, j = mid + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid &amp;&amp; j &lt;= r) &#123;</span><br><span class="line"><span class="keyword">if</span> (q[i] &lt;= q[j])</span><br><span class="line">tmp[k++] = q[i++];</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">tmp[k++] = q[j++];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">while</span> (i &lt;= mid)</span><br><span class="line">tmp[k++] = q[i++];</span><br><span class="line"><span class="keyword">while</span> (j &lt;= r)</span><br><span class="line">tmp[k++] = q[j++];</span><br><span class="line"><span class="keyword">for</span> (i = l, j = <span class="number">0</span>; i &lt;= r; i++, j++)</span><br><span class="line">q[i] = tmp[j];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cin</span> &gt;&gt; q[i];</span><br><span class="line">&#125;</span><br><span class="line">merge_sort(q, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; q[i] &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;归并排序&quot;&gt;&lt;a href=&quot;#归并排序&quot; class=&quot;headerlink&quot; title=&quot;归并排序&quot;&gt;&lt;/a&gt;归并排序&lt;/h1&gt;&lt;p&gt;​        归并排序是另一种排序算法，也是采用分治的思想，但是和快排有很大的区别，归并排序是稳定的，而快排则不稳定&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算法——快速排序</title>
    <link href="http://yoursite.com/2020/01/13/%E7%AE%97%E6%B3%95%E2%80%94%E2%80%94%E5%BF%AB%E9%80%9F%E6%8E%92%E5%BA%8F/"/>
    <id>http://yoursite.com/2020/01/13/算法——快速排序/</id>
    <published>2020-01-13T09:53:56.000Z</published>
    <updated>2020-01-14T10:40:00.623Z</updated>
    
    <content type="html"><![CDATA[<h1 id="快排"><a href="#快排" class="headerlink" title="快排"></a>快排</h1><p>​        从头开始学习算法，从最简单的排序算法开始，第一个接触的就是快排，学习的平台是 AcWing，希望现在学习还不晚，对以后能有帮助</p><a id="more"></a><h2 id="快排的原理"><a href="#快排的原理" class="headerlink" title="快排的原理"></a>快排的原理</h2><p>​        快排使用的是分治的思想，有三个关键点：确定分界点、调整区间、递归处理左右两段，这里的思想是使用两个指针，分别对应数组的左右边界，一下简称 l 和 r，通过循环来将两个指针向中间移动直到 l 和 r 相遇，在这期间，将数组调整为小于等于分界点的值和大于等于分界点的值两部分，再使用递归的思想处理</p><p>​        首先要做的是确定一个分治的分界点，这个点可以是任意的一个数组元素，但不要给它设置成固定值，最好通过变量来对它进行定义，例如 array[l]、array[r]、array[(l + r) / 2] 这种都可以</p><p>​        然后通过分界点的值来调整数组空间，，这里需要用到刚才提到的 l 和 r 两个指针，过程是：先将 l 向后移动，检验 l 对应的值是否小于分界点，如果小于则继续后移 l，否则 l 就会停下，这是 r 开始前移，检测移动后的 r 所对应的值是否大于分界点，如果大于则继续前移 r，否则 r 也会停下，这个时候 l 和 r 都已经停下了，说明 l 和 r 都已经遇到了不属于自己对应空间的值，直接交换两个指针当前所对应的值，然后继续移动 l 和 r 指针，直到 l 和 r 相遇</p><p>​        最后便是使用递归的思想，对分界点左边（大小意义上的左，并非是排序上的左）和分界点右边的元素再进行第二步的过程，当最后一次递归结束后，数组便完成了排序</p><h2 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span> <span class="params">(<span class="keyword">int</span>[] arr, <span class="keyword">int</span> l, <span class="keyword">int</span> r)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (l == r)</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line"><span class="comment">//x:分治变量 循环变量需在两侧边界外一个偏移量的位置，因为每次都是先让指针后/前移一格，所以循环变量需要在边界的前/后一个偏移量的位置</span></span><br><span class="line">    <span class="keyword">int</span> x = arr[l], i = l - <span class="number">1</span>, j = r + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span> (l &lt; r) &#123;</span><br><span class="line">        <span class="keyword">do</span></span><br><span class="line">        i++;</span><br><span class="line">    <span class="keyword">while</span> (arr[i] &lt; x);</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">        j++;</span><br><span class="line">    <span class="keyword">while</span> (arr[j] &gt; x);</span><br><span class="line">    <span class="keyword">if</span> (i &lt; j) </span><br><span class="line">       swap(arr[i], arr[j]);</span><br><span class="line">    &#125;</span><br><span class="line">    quick_sort(arr, l, j);</span><br><span class="line">    quick_sort(arr, j + <span class="number">1</span>, r);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        </p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;快排&quot;&gt;&lt;a href=&quot;#快排&quot; class=&quot;headerlink&quot; title=&quot;快排&quot;&gt;&lt;/a&gt;快排&lt;/h1&gt;&lt;p&gt;​        从头开始学习算法，从最简单的排序算法开始，第一个接触的就是快排，学习的平台是 AcWing，希望现在学习还不晚，对以后能有帮助&lt;/p&gt;
    
    </summary>
    
    
      <category term="李明徽的算法" scheme="http://yoursite.com/tags/%E6%9D%8E%E6%98%8E%E5%BE%BD%E7%9A%84%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JAVA线程简介及两种创建方式</title>
    <link href="http://yoursite.com/2020/01/04/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JAVA%E7%BA%BF%E7%A8%8B%E7%AE%80%E4%BB%8B%E5%8F%8A%E4%B8%A4%E7%A7%8D%E5%88%9B%E5%BB%BA%E6%96%B9%E5%BC%8F/"/>
    <id>http://yoursite.com/2020/01/04/JAVA基础——JAVA线程简介及两种创建方式/</id>
    <published>2020-01-04T01:34:30.000Z</published>
    <updated>2020-01-04T03:07:25.028Z</updated>
    
    <content type="html"><![CDATA[<h1 id="进程与线程"><a href="#进程与线程" class="headerlink" title="进程与线程"></a>进程与线程</h1><h2 id="什么是进程"><a href="#什么是进程" class="headerlink" title="什么是进程"></a>什么是进程</h2><p>​        进程是程序的一次执行过程，是一个动态的概念，是程序在执行过程中分配和管理资源的基本单位，每一个进程都有一个自己的地址空间，也就是说，进程是应用程序运行的状态，应用程序的执行实例，有独立的内存空间和系统资源</p><h2 id="什么是线程"><a href="#什么是线程" class="headerlink" title="什么是线程"></a>什么是线程</h2><p>​        一个进程中包括多个线程，线程是 CPU 调度和分派的基本单位，是进程中执行运算的最小单位，真正在 CPU 上运行的是线程，可以与同一个进程中的其他线程共享进程的全部资源</p><a id="more"></a><h2 id="线程的生命周期"><a href="#线程的生命周期" class="headerlink" title="线程的生命周期"></a>线程的生命周期</h2><p>​        线程是进程的一部分，它也是一个动态执行的概念，有从产生到死亡的过程，线程的生命周期可以分为五个部分：</p><p>​        新生状态-&gt;（线程创建了，还未运行）-&gt;可运行状态（CPU 准备调度线程）-&gt;（系统调度，获取 CPU 资源）-&gt;运行状态-&gt;阻塞状态（线程阻塞，让出 CPU 资源）-&gt;死亡状态</p><h3 id="新生状态"><a href="#新生状态" class="headerlink" title="新生状态"></a>新生状态</h3><p>​        线程对象被创建后，这个线程就处于新生状态，这个状态会一直持续到 start() 这个线程</p><h3 id="可运行状态"><a href="#可运行状态" class="headerlink" title="可运行状态"></a>可运行状态</h3><p>​        当线程调用了 start() 方法后，该线程就进入可运行状态，进入可运行状态的线程会被插入就绪队列中，等待 JVM 里线程调度器的调度</p><h3 id="运行状态"><a href="#运行状态" class="headerlink" title="运行状态"></a>运行状态</h3><p>​        当可运行状态的线程得到 CPU 资源后，该线程就可以执行 run()，此时线程便处于运行状态，运行状态的线程可以向阻塞状态、就绪状态和死亡状态转变</p><h3 id="阻塞状态"><a href="#阻塞状态" class="headerlink" title="阻塞状态"></a>阻塞状态</h3><p>​        当一个线程调用了 sleep()、join()、yield() 等方法，失去所占用的资源后，线程进入阻塞状态，在说的资源或者睡眠时间已到后可以重新进入就绪状态</p><h3 id="死亡状态"><a href="#死亡状态" class="headerlink" title="死亡状态"></a>死亡状态</h3><p>​        正常死亡和非正常死亡都会杀死进程，进程死亡即进程被销毁</p><h2 id="线程的优先级"><a href="#线程的优先级" class="headerlink" title="线程的优先级"></a>线程的优先级</h2><p>​        在 Java 中，线程有优先级的概念，其范围为 1 - 10，默认优先级为 5，但是优先级是概率性的，优先级高的线程并不一定优先执行，只是被分配资源的概率更高</p><p>​        setPriority() 方法有三种常量：</p><p>​            MAX_PRIORITY (10)</p><p>​            MIN_PRIORITY (1)</p><p>​            NORM_PRIORITY (5)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Thread t = <span class="keyword">new</span> Thread(mt);</span><br><span class="line">t.setPriority(<span class="number">1</span>);</span><br><span class="line">t.start();</span><br><span class="line">Thread t2 = <span class="keyword">new</span> Thread(mt);</span><br><span class="line"><span class="comment">//设置线程名称</span></span><br><span class="line">t2.setName(<span class="string">"sc"</span>);</span><br><span class="line"><span class="comment">//设置线程优先级，但是是概率事件，并非优先级高一定先运行，1 - 10 表示，10 最高，默认值是 5</span></span><br><span class="line">t2.setPriority(Thread.MAX_PRIORITY);</span><br><span class="line">Thread.currentThread().setPriority(Thread.MIN_PRIORITY);</span><br></pre></td></tr></table></figure><h2 id="线程在-Java-中的两种创建方式"><a href="#线程在-Java-中的两种创建方式" class="headerlink" title="线程在 Java 中的两种创建方式"></a>线程在 Java 中的两种创建方式</h2><p>​        在 Java 中有两种创建线程的方法，下面逐个解释并说明他们的区别</p><h3 id="继承-Thread-类"><a href="#继承-Thread-类" class="headerlink" title="继承 Thread 类"></a>继承 Thread 类</h3><p>​        通过继承 Thread 类来创建线程，创建该类的实例，继承类必须重写 run() 方法，run() 方法中是线程所执行的代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest1</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread mt = <span class="keyword">new</span> MyThread();</span><br><span class="line">        mt.start();</span><br><span class="line">        </span><br><span class="line">        MyThread mt2 = <span class="keyword">new</span> MyThread();</span><br><span class="line">        mt2.start();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread</span> <span class="keyword">extends</span> <span class="title">Thread</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>​        Thread 类实际上是实现了 Runnable 接口的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Thread</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span></span><br></pre></td></tr></table></figure><h3 id="通过实现-Runnable-接口"><a href="#通过实现-Runnable-接口" class="headerlink" title="通过实现 Runnable 接口"></a>通过实现 Runnable 接口</h3><p>​        实现 Runnable 接口直需要重写其中的 run() 方法，Thread 的构造方法中，可以通过静态代理的方法，使用 Runnable 的实现类来创建进程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ThreadTest2</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        MyThread2 mt = <span class="keyword">new</span> MyThread2();</span><br><span class="line">        <span class="comment">//静态代理</span></span><br><span class="line">        Thread t = <span class="keyword">new</span> Thread(mt);</span><br><span class="line">        t.setPriority(<span class="number">1</span>);</span><br><span class="line">        t.start();</span><br><span class="line">        Thread t2 = <span class="keyword">new</span> Thread(mt);</span><br><span class="line">        t2.start();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyThread2</span> <span class="keyword">implements</span> <span class="title">Runnable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            count--;</span><br><span class="line">            System.out.println(Thread.currentThread().getName() + <span class="string">" "</span> + count);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><p>​        首先，单继承不能再继承其他类，而实现可以多实现，同时也可以继承</p><p>​        另外，通过实现 Runnable 接口来创建的线程可以共享实现类的资源，这是多线程实现的基础</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;进程与线程&quot;&gt;&lt;a href=&quot;#进程与线程&quot; class=&quot;headerlink&quot; title=&quot;进程与线程&quot;&gt;&lt;/a&gt;进程与线程&lt;/h1&gt;&lt;h2 id=&quot;什么是进程&quot;&gt;&lt;a href=&quot;#什么是进程&quot; class=&quot;headerlink&quot; title=&quot;什么是进程&quot;&gt;&lt;/a&gt;什么是进程&lt;/h2&gt;&lt;p&gt;​        进程是程序的一次执行过程，是一个动态的概念，是程序在执行过程中分配和管理资源的基本单位，每一个进程都有一个自己的地址空间，也就是说，进程是应用程序运行的状态，应用程序的执行实例，有独立的内存空间和系统资源&lt;/p&gt;
&lt;h2 id=&quot;什么是线程&quot;&gt;&lt;a href=&quot;#什么是线程&quot; class=&quot;headerlink&quot; title=&quot;什么是线程&quot;&gt;&lt;/a&gt;什么是线程&lt;/h2&gt;&lt;p&gt;​        一个进程中包括多个线程，线程是 CPU 调度和分派的基本单位，是进程中执行运算的最小单位，真正在 CPU 上运行的是线程，可以与同一个进程中的其他线程共享进程的全部资源&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>JAVA基础——JVM之G1（Garbage First）垃圾回收器</title>
    <link href="http://yoursite.com/2019/12/29/JAVA%E5%9F%BA%E7%A1%80%E2%80%94%E2%80%94JVM%E4%B9%8BG1%EF%BC%88Garbage-First%EF%BC%89%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8/"/>
    <id>http://yoursite.com/2019/12/29/JAVA基础——JVM之G1（Garbage-First）垃圾回收器/</id>
    <published>2019-12-29T02:16:26.000Z</published>
    <updated>2019-12-29T03:45:10.939Z</updated>
    
    <content type="html"><![CDATA[<h1 id="Garbage-First-垃圾回收器"><a href="#Garbage-First-垃圾回收器" class="headerlink" title="Garbage First 垃圾回收器"></a>Garbage First 垃圾回收器</h1><h2 id="G1-简介"><a href="#G1-简介" class="headerlink" title="G1 简介"></a>G1 简介</h2><p>​        G1（Garbage First）垃圾回收器是最新的 JDK 中默认的垃圾回收器，也是垃圾回收技术最前沿的成果，它同时注重吞吐量（Throughput）和低延迟（Low Latency），默认的暂停目标是 200ms，适用于超大的堆内存</p><p>​        G1 引入了分区（region）的思想，弱化了分代的概念，它将堆内存分为大小相等的区，每个区的大约是 1248M，并且每个区都可以是 Eden、Survivor、Old 或者大对象区，G1 垃圾回收器在整体上使用了标记整理算法，两个区域之间使用的是复制算法</p><a id="more"></a><h2 id="G1-垃圾回收流程"><a href="#G1-垃圾回收流程" class="headerlink" title="G1 垃圾回收流程"></a>G1 垃圾回收流程</h2><p>​        G1 垃圾回收器的名字来源于它的设计原则：优先收集回收效果最大的区域（Garbage First），G1 垃圾回收器不是等到内存耗尽开始进行垃圾回收的，它采用启发式算法，当内存使用达到一定比例时就会开始进行垃圾回收，G1 垃圾回收器的工作流程大体上可以分为三个步骤的循环执行：Young Collection、Young Collection + CM、Mixed Collection</p><p><img src="https://img-blog.csdnimg.cn/20191229114401950.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NjZm9yMzMz,size_16,color_FFFFFF,t_70" alt></p><h3 id="Young-Collection"><a href="#Young-Collection" class="headerlink" title="Young Collection"></a>Young Collection</h3><p>​        Young Collection 阶段主要进行新生代的垃圾回收，和其他垃圾回收器一样，当 Eden 区逐渐被沾满时，会将 Eden 区中的幸存对象复制进 Survivor 区，这期间会造成 STW，当 Survivor 区中对象逐渐被占满时，被占满的 Survivor 区的对象中，符合晋升条件的会晋升到老年代，其余的会复制到其他 Survivor 区，另外，在进行 Young Collection 时，JVM 会对对象进行初始标记</p><h3 id="Young-Collection-Concurrent-Mark"><a href="#Young-Collection-Concurrent-Mark" class="headerlink" title="Young Collection + Concurrent Mark"></a>Young Collection + Concurrent Mark</h3><p>​        当老年代占用堆空间比例达到一定的阈值时，会进行并发标记，并发标记不会造成 STW，也就是不会影响其他的用户线程，阈值的默认值是 45%，即老年代占比达到堆空间的 45% 时会开始进行并发标记，这里的并发标记过程也和其他的垃圾回收器一样，就是对初始标记后的对象再进行一次更细致的标记</p><h3 id="Mixed-Collection"><a href="#Mixed-Collection" class="headerlink" title="Mixed Collection"></a>Mixed Collection</h3><p>​        混合回收是 G1 垃圾回收循环中的最后一项，在混合回收中，G1 可以将一些老年代区域添加到将回收的 Eden 和 Survivor，G1 垃圾回收器回收足够数量的老年代区域后，G1 会恢复到执行 Young Collection，直到下一个并发标记周期的完成</p><p>​        Mixed Collection 分为最终标记（Remark）和拷贝存活（Evacuation）两个阶段，两个阶段都会造成 STW</p><h4 id="Remark（重标记、最终标记）"><a href="#Remark（重标记、最终标记）" class="headerlink" title="Remark（重标记、最终标记）"></a>Remark（重标记、最终标记）</h4><p>​        最终标记（重标记）对于垃圾回收的过程是十分必要的，比如有如下情况：对象 C 在初始标记时因为没有被强引用所引用，初始标记的过程就不会标记 C 对象，而在垃圾回收之前和并发标记这段时间里，强引用对象 A 又引用了对象 C，如果不在垃圾回收之前进行一次 Remark，这时的对象 C 毫无疑问会被当作垃圾回收掉</p><p>​        为了防止这种事情发生，在并发标记之后，如果对象的引用发生了改变，JVM 会执行写屏障指令，将发生引用改变的对象放入一个 satb_mark_queue 中，当重新标记进行时会检查这个队列，检测其中的对象是否有强引用所引用</p><h4 id="Evacuation（拷贝存活）"><a href="#Evacuation（拷贝存活）" class="headerlink" title="Evacuation（拷贝存活）"></a>Evacuation（拷贝存活）</h4><p>​        拷贝存活即最后的整理，将多个区域的存活对象整理进一个或几个区域，并完成 Eden 到 Survivor，Survivor 到 Old，Old 到 Eden 和 Survivor 的过程，回收老年代的对象时，G1 会优先回收垃圾最多的区域，以达到暂停时间短的目标</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;Garbage-First-垃圾回收器&quot;&gt;&lt;a href=&quot;#Garbage-First-垃圾回收器&quot; class=&quot;headerlink&quot; title=&quot;Garbage First 垃圾回收器&quot;&gt;&lt;/a&gt;Garbage First 垃圾回收器&lt;/h1&gt;&lt;h2 id=&quot;G1-简介&quot;&gt;&lt;a href=&quot;#G1-简介&quot; class=&quot;headerlink&quot; title=&quot;G1 简介&quot;&gt;&lt;/a&gt;G1 简介&lt;/h2&gt;&lt;p&gt;​        G1（Garbage First）垃圾回收器是最新的 JDK 中默认的垃圾回收器，也是垃圾回收技术最前沿的成果，它同时注重吞吐量（Throughput）和低延迟（Low Latency），默认的暂停目标是 200ms，适用于超大的堆内存&lt;/p&gt;
&lt;p&gt;​        G1 引入了分区（region）的思想，弱化了分代的概念，它将堆内存分为大小相等的区，每个区的大约是 1248M，并且每个区都可以是 Eden、Survivor、Old 或者大对象区，G1 垃圾回收器在整体上使用了标记整理算法，两个区域之间使用的是复制算法&lt;/p&gt;
    
    </summary>
    
    
      <category term="JAVA基础" scheme="http://yoursite.com/tags/JAVA%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
